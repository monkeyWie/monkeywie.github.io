[{"title":"chrome清除HSTS记录","url":"/2020/04/23/chrome-clear-hsts/","content":"<h2 id=\"HSTS-简介\"><a href=\"#HSTS-简介\" class=\"headerlink\" title=\"HSTS 简介\"></a>HSTS 简介</h2><p>HSTS(HTTP Strict Transport Security)是一套由互联网工程任务组发布的互联网安全策略机制。网站可以选择使用 HSTS 策略，来让浏览器强制使用 HTTPS 与网站进行通信，以减少会话劫持风险。</p><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>有时候由于某些开发的需要，想访问 http 协议的接口，但是由于 HSTS 的机制，浏览器一直会强制跳转到 https，没办法调试，所以得把 HSTS 记录清除掉。</p><h2 id=\"清除步骤\"><a href=\"#清除步骤\" class=\"headerlink\" title=\"清除步骤\"></a>清除步骤</h2><ol><li>浏览器访问<code>chrome://net-internals/#hsts</code></li><li>找到<code>Delete domain security policies</code>选项，输入对应的域名点击删除即可<br><img src=\"/2020/04/23/chrome-clear-hsts/2020-04-23-10-17-33.png\" alt></li></ol>","categories":["浏览器"],"tags":["chrome","hsts"]},{"title":"OpenSSL创建带SAN扩展的证书并进行CA自签","url":"/2019/11/15/create-ssl-cert-with-san/","content":"<h2 id=\"什么是-SAN\"><a href=\"#什么是-SAN\" class=\"headerlink\" title=\"什么是 SAN\"></a>什么是 SAN</h2><p>SAN(Subject Alternative Name) 是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩展此证书支持的域名，使得一个证书可以支持多个不同域名的解析。</p><a id=\"more\"></a><p>来看看百度的证书，百度证书的扩展域名有这么多，其中还有了*.hao123.com，那我们再看看 <a href=\"http://www.hao123.com\" target=\"_blank\" rel=\"noopener\">www.hao123.com</a> 的证书<br><img src=\"/2019/11/15/create-ssl-cert-with-san/2019-11-15-16-54-49.png\" alt><br>发现的确是用的前面的百度证书</p><p><img src=\"/2019/11/15/create-ssl-cert-with-san/2019-11-15-16-55-08.png\" alt><br>所以 SAN 带来的好处就可以看出来了，一个证书可以用在各种不同的域名下，不需要一个域名买一个证书了。</p><h2 id=\"利用-OpenSSL-创建证书\"><a href=\"#利用-OpenSSL-创建证书\" class=\"headerlink\" title=\"利用 OpenSSL 创建证书\"></a>利用 OpenSSL 创建证书</h2><p>因为是本地环境，直接用 OpenSSL 给自己颁发一个 CA 根证书用于后面给服务器做 CA 签署。</p><ol><li>生成 CA 密钥</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out ca.key 2048</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>生成 CA 根证书</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -sha256 -new -x509 -days 365 -key ca.key -out ca.crt \\</span><br><span class=\"line\">    -subj &quot;/C=CN/ST=GD/L=SZ/O=lee/OU=study/CN=testRoot&quot;</span><br></pre></td></tr></table></figure><ol start=\"3\"><li>生成服务器密钥</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -des3 -out server.key 2048</span><br></pre></td></tr></table></figure><ol start=\"4\"><li>生成服务器证书请求文件</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl req -new \\</span><br><span class=\"line\">    -sha256 \\</span><br><span class=\"line\">    -key server.key \\</span><br><span class=\"line\">    -subj &quot;/C=CN/ST=GD/L=SZ/O=lee/OU=study/CN=bdstatic.com&quot; \\</span><br><span class=\"line\">    -reqexts SAN \\</span><br><span class=\"line\">    -config &lt;(cat /etc/pki/tls/openssl.cnf \\</span><br><span class=\"line\">        &lt;(printf &quot;[SAN]\\nsubjectAltName=DNS:*.bdstatic.com,DNS:*.baidu.com&quot;)) \\</span><br><span class=\"line\">    -out server.csr</span><br></pre></td></tr></table></figure><ol start=\"5\"><li>CA 签署服务器证书</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl ca -in server.csr \\</span><br><span class=\"line\">    -md sha256 \\</span><br><span class=\"line\">    -keyfile ca.key \\</span><br><span class=\"line\">    -cert ca.crt \\</span><br><span class=\"line\">    -extensions SAN \\</span><br><span class=\"line\">    -config &lt;(cat /etc/pki/tls/openssl.cnf \\</span><br><span class=\"line\">        &lt;(printf &quot;[SAN]\\nsubjectAltName=DNS:*.bdstatic.com,DNS:*.baidu.com&quot;)) \\</span><br><span class=\"line\">    -out server.crt</span><br></pre></td></tr></table></figure><p>之后把生成好的服务器证书和服务器密钥在服务器(ngnix,tomcat)里配置好，并且把 ca.crt 证书导入到浏览器的受信任的根证书颁发机构里，在浏览器访问就不会有红叉叉了。</p><p><img src=\"/2019/11/15/create-ssl-cert-with-san/2019-11-15-16-55-23.png\" alt></p><p><img src=\"/2019/11/15/create-ssl-cert-with-san/2019-11-15-16-55-29.png\" alt></p><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol><li><p>-subj “/C=CN/ST=GD/L=SZ/O=lee/OU=study/CN=testRoot”这行可以不要，会有命令交互填写相关信息。<br><img src=\"/2019/11/15/create-ssl-cert-with-san/2019-11-15-16-58-23.png\" alt></p></li><li><p>哈希算法不要使用 sha1,因为 Chrome 浏览器下会提示不安全，上面都是用的 sha256。</p></li><li>/etc/pki/tls/openssl.cnf 文件是缺省的 OpenSSL 配置文件，可能环境不同路径也不同。</li><li><p>服务器证书请求文件的国家，省，市要和 CA 证书一致,这个在 openssl.cnf 默认配置中指定了，可以修改。<br><img src=\"/2019/11/15/create-ssl-cert-with-san/2019-11-15-16-56-34.png\" alt></p></li><li><p>关于私钥的加密格式，因为笔者是在 netty 里使用的 ssl 协议，而 netty 仅支持 PKCS8 格式的私钥见<a href=\"http://netty.io/wiki/sslcontextbuilder-and-private-key.html\" target=\"_blank\" rel=\"noopener\">http://netty.io/wiki/sslcontextbuilder-and-private-key.html</a>，需要对密钥格式进行转换</p></li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl pkcs8 -topk8 -nocrypt -in server.key -out server.pem</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SslContext serverSslCtx = SslContextBuilder.forServer(new File(&quot;E:/server.crt&quot;),new File(&quot;E:/server.pem&quot;)).build();</span><br></pre></td></tr></table></figure><h2 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h2><ol><li><p>遇到<code>unable to open &#39;/etc/pki/CA/index.txt&#39;</code>解决办法：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch /etc/pki/CA/index.txt</span><br></pre></td></tr></table></figure></li><li><p>遇到<code>error while loading serial number</code>解决办法：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch /etc/pki/CA/serial</span><br><span class=\"line\">echo 00 &gt; /etc/pki/CA/serial</span><br></pre></td></tr></table></figure></li><li><p>遇到<code>failed to update database TXT_DB error number 2</code>解决办法：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm -rf /etc/pki/CA/index.txt</span><br><span class=\"line\">touch /etc/pki/CA/index.txt</span><br></pre></td></tr></table></figure></li></ol><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://liaoph.com/openssl-san/\" target=\"_blank\" rel=\"noopener\">OpenSSL SAN 证书</a><br><a href=\"https://zhuanlan.zhihu.com/p/26646377\" target=\"_blank\" rel=\"noopener\">使用 OpenSSL 生成多域名自签名证书进行 HTTPS 开发调试</a></p>","categories":["DevOps"],"tags":["openssl","https","ssl"]},{"title":"做个优雅的CRUD boy","url":"/2020/05/25/crud-gracefully/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>网上都在调侃<code>CRUD</code>没有技术含量，但是不可否认的是在工作中无可避免的要做大量的<code>CRUD</code>，这里面会存在大量的重复工作，意味着可能会写大量的冗余代码，秉着能少写一行代码绝不多写一行的原则，不应该把时间浪费在这些重复的工作中的，在这里分享两个方案来用尽量少的代码实现<code>CRUD</code>,一个是<code>spring-data-rest</code>还有一个是我自己封装的一套框架<code>monkey-spring-boot-starter</code>，下面一一进行介绍。</p><a id=\"more\"></a><h2 id=\"spring-data-rest\"><a href=\"#spring-data-rest\" class=\"headerlink\" title=\"spring-data-rest\"></a>spring-data-rest</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Spring Data REST 是 Spring Data 项目的一部分，可轻松在 Spring Data repository 上构建 REST 服务，目前支持<code>JPA</code>、<code>MongoDB</code>、<code>Neo4j</code>、<code>Solr</code>、<code>Cassandra</code>、<code>Gemfire</code>，只需要定义一个<code>repository</code>就可以自动转换成 REST 服务。</p><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>先通过一个例子看看，只需要两个类：</p><ul><li>User.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>UserRepository.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">User</span>,<span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>就这样<code>User表</code>相关的<code>REST接口</code>就已经生成好了，来测试下看看。</p><ul><li>访问根目录，会列出所有可用的资源列表</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl localhost:8080</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"users\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users&#123;?page,size,sort&#125;\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"templated\"</span> : <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"profile\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/profile\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的响应，可以看到<code>User资源</code>对应的接口地址，接着继续测试。</p><ul><li>添加用户</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -X POST -i -H <span class=\"string\">\"Content-Type:application/json\"</span> -d <span class=\"string\">'&#123;\"name\":\"lee\",\"age\":18&#125;'</span> localhost:8080/users</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"lee\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"age\"</span> : 18,</span><br><span class=\"line\">  <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询用户</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl localhost:8080/users</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_embedded\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"users\"</span> : [ &#123;</span><br><span class=\"line\">      <span class=\"string\">\"name\"</span> : <span class=\"string\">\"lee\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"age\"</span> : 18,</span><br><span class=\"line\">      <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"user\"</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"profile\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/profile/users\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"page\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span> : 20,</span><br><span class=\"line\">    <span class=\"string\">\"totalElements\"</span> : 1,</span><br><span class=\"line\">    <span class=\"string\">\"totalPages\"</span> : 1,</span><br><span class=\"line\">    <span class=\"string\">\"number\"</span> : 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>分页查询用户</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl <span class=\"string\">\"localhost:8080/users?page=0&amp;size=10\"</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_embedded\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"users\"</span> : [ &#123;</span><br><span class=\"line\">      <span class=\"string\">\"name\"</span> : <span class=\"string\">\"lee\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"age\"</span> : 18,</span><br><span class=\"line\">      <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">\"user\"</span> : &#123;</span><br><span class=\"line\">          <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users?page=0&amp;size=10\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"profile\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/profile/users\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"page\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"size\"</span> : 10,</span><br><span class=\"line\">    <span class=\"string\">\"totalElements\"</span> : 1,</span><br><span class=\"line\">    <span class=\"string\">\"totalPages\"</span> : 1,</span><br><span class=\"line\">    <span class=\"string\">\"number\"</span> : 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改用户</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -X PUT -H <span class=\"string\">\"Content-Type:application/json\"</span> -d <span class=\"string\">'&#123;\"name\":\"hello\",\"age\":20&#125;'</span> localhost:8080/users/1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"age\"</span> : 20,</span><br><span class=\"line\">  <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -X PATCH -H <span class=\"string\">\"Content-Type:application/json\"</span> -d <span class=\"string\">'&#123;\"age\":18&#125;'</span> localhost:8080/users/1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"age\"</span> : 18,</span><br><span class=\"line\">  <span class=\"string\">\"_links\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"self\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : &#123;</span><br><span class=\"line\">      <span class=\"string\">\"href\"</span> : <span class=\"string\">\"http://localhost:8080/users/1\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -i -X DELETE localhost:8080/users/1</span><br></pre></td></tr></table></figure><p>核心代码只有十几行就完成了一个基本的<code>CRUD</code>功能，在开发小项目的时候效率非常的高，但是由于屏蔽了<code>controller</code>层，如果有基于<code>拦截器</code>或者<code>AOP</code>做一些定制化的功能就比较麻烦了，例如：<code>日志审计</code>、<code>权限校验</code>之类的。</p><h2 id=\"未完待续\"><a href=\"#未完待续\" class=\"headerlink\" title=\"未完待续\"></a>未完待续</h2>","categories":["后端"],"tags":["java","spring-boot","jpa"]},{"title":"通过nginx反向代理来调试代码","url":"/2019/12/30/debug-use-nginx-proxy/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>现在公司项目都是前后端分离的方式开发，有些时候由于某些新需求开发或者 bug 修改，想要让前端直接连到我本地开发环境进行调试，而前端代码我并没有，只能通过前端部署的测试环境进行测试，最简单的办法就是直接改 host 把后端测试环境的域名指向我本地的 IP，这对于 HTTP 协议的服务来说是很轻易做到的，不过公司的测试环境全部上了 HTTPS，而我本地的服务是 HTTP 协议这样就算是改了 host 也会由于协议不同导致请求失败，所以需要将本地的服务升级成 HTTPS 才行。</p><a id=\"more\"></a><h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>其实 springboot 本身就支持 HTTPS(<a href=\"https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/howto.html#howto-configure-ssl\" target=\"_blank\" rel=\"noopener\">howto-configure-ssl</a>)，但是这需要改项目代码不太优雅，于是就想直接用<code>nginx</code>反向代理到本地服务，这样在<code>nginx</code>层面做 HTTPS 就不需要改代码了，只需修改 host 将<code>后端测试环境域名</code>指向 <code>nginx</code> 服务的 IP 即可，而且可以适用于其它的 HTTP 服务开发调试。</p><p><img src=\"/2019/12/30/debug-use-nginx-proxy/2019-12-31-14-16-07.png\" alt></p><h3 id=\"签发证书\"><a href=\"#签发证书\" class=\"headerlink\" title=\"签发证书\"></a>签发证书</h3><p>首先要生成一套证书用于 nginx 的 ssl 配置，直接使用<code>openssl</code>工具生成一套<code>根证书</code>和对应的<code>服务证书</code>。</p><blockquote><p>注意将命令行中的<code>xxx.com</code>替换成真实的域名。</p></blockquote><ol><li>根证书生成</li></ol><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成一个RSA私钥</span></span><br><span class=\"line\">openssl genrsa -out root.key 2048</span><br><span class=\"line\"><span class=\"comment\"># 通过私钥生成一个根证书</span></span><br><span class=\"line\">openssl req -sha256 -new -x509 -days 365 -key root.key -out root.crt \\</span><br><span class=\"line\">    -subj <span class=\"string\">\"/C=CN/ST=GD/L=SZ/O=lee/OU=work/CN=fakerRoot\"</span></span><br></pre></td></tr></table></figure><ol start=\"2\"><li>服务器证书生成</li></ol><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成一个RSA私钥</span></span><br><span class=\"line\">openssl genrsa -out server.key 2048</span><br><span class=\"line\"><span class=\"comment\"># 生成一个带SAN扩展的证书签名请求文件</span></span><br><span class=\"line\">openssl req -new \\</span><br><span class=\"line\">    -sha256 \\</span><br><span class=\"line\">    -key server.key \\</span><br><span class=\"line\">    -subj <span class=\"string\">\"/C=CN/ST=GD/L=SZ/O=lee/OU=work/CN=xxx.com\"</span> \\</span><br><span class=\"line\">    -reqexts SAN \\</span><br><span class=\"line\">    -config &lt;(cat /etc/pki/tls/openssl.cnf \\</span><br><span class=\"line\">        &lt;(<span class=\"built_in\">printf</span> <span class=\"string\">\"[SAN]\\nsubjectAltName=DNS:*.xxx.com,DNS:*.test.xxx.com\"</span>)) \\</span><br><span class=\"line\">    -out server.csr</span><br><span class=\"line\"><span class=\"comment\"># 使用之前生成的根证书做签发</span></span><br><span class=\"line\">openssl ca -<span class=\"keyword\">in</span> server.csr \\</span><br><span class=\"line\">    -md sha256 \\</span><br><span class=\"line\">    -keyfile root.key \\</span><br><span class=\"line\">    -cert root.crt \\</span><br><span class=\"line\">    -extensions SAN \\</span><br><span class=\"line\">    -config &lt;(cat /etc/pki/tls/openssl.cnf \\</span><br><span class=\"line\">        &lt;(<span class=\"built_in\">printf</span> <span class=\"string\">\"[SAN]\\nsubjectAltName=DNS:xxx.com,DNS:*.test.xxx.com\"</span>)) \\</span><br><span class=\"line\">    -out server.crt</span><br></pre></td></tr></table></figure><p>如果上面步骤发送错误，可以<a href=\"https://monkeywie.github.io/2019/11/15/create-ssl-cert-with-san/#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF\">参考</a>常见错误解决办法，成功之后就得到了三个关键文件：</p><ul><li><code>root.crt</code>:根证书</li><li><code>server.key</code>:服务证书私钥</li><li><code>server.crt</code>:服务证书</li></ul><blockquote><p>注：生成的服务器证书域名要支持测试环境访问的域名，否则浏览器会提示证书不安全。</p></blockquote><h3 id=\"nginx-配置\"><a href=\"#nginx-配置\" class=\"headerlink\" title=\"nginx 配置\"></a>nginx 配置</h3><p>为了方便，直接使用<code>docker</code>启动了一个 nginx 容器进行访问，并将证书和配置文件挂载到对应的目录：</p><ul><li>nginx.conf</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 443 ssl;</span><br><span class=\"line\">    server_name _;</span><br><span class=\"line\">    ssl_certificate &quot;/usr/local/nginx/ssl/server.crt&quot;;</span><br><span class=\"line\">    ssl_certificate_key &quot;/usr/local/nginx/ssl/server.key&quot;;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">        proxy_set_header Host $http_host;</span><br><span class=\"line\">        proxy_set_header X-NginX-Proxy true;</span><br><span class=\"line\">        proxy_set_header Upgrade $http_upgrade;</span><br><span class=\"line\">        proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class=\"line\">        proxy_pass http://127.0.0.1:3000;</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_http_version 1.1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过配置<code>ssl_certificate</code>和<code>ssl_certificate_key</code>来指定服务器的证书和私钥，<code>proxy_pass</code>指定开发环境的访问地址。</p><ul><li>启动</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --name https -p 443:443 -v ~/forword/ssl:/usr/<span class=\"built_in\">local</span>/nginx/ssl -v ~/forword/config/nginx.conf:/etc/nginx/conf.d/default.conf  nginx</span><br></pre></td></tr></table></figure><p>将 nginx 配置和证书相关文件挂载至对应的目录，并暴露 443 端口，这样服务启动后即可通过 https 访问到本地开发环境了。</p><h3 id=\"安装根证书\"><a href=\"#安装根证书\" class=\"headerlink\" title=\"安装根证书\"></a>安装根证书</h3><p>由于服务证书是自己签发的，并不会被浏览器所信任，所以需要将<code>根证书</code>安装至操作系统中。</p><ol><li><p>打开 chrome 浏览器-&gt;设置-&gt;高级-&gt;管理证书<br><img src=\"/2019/12/30/debug-use-nginx-proxy/2019-12-31-14-50-42.png\" alt></p></li><li><p>受信任的根证书颁发机构-&gt;导入<br><img src=\"/2019/12/30/debug-use-nginx-proxy/2019-12-31-14-51-33.png\" alt></p></li><li><p>选择之前生成的根证书<code>root.crt</code>导入即可</p></li></ol><h3 id=\"修改-host\"><a href=\"#修改-host\" class=\"headerlink\" title=\"修改 host\"></a>修改 host</h3><p>在需要调试时，只需要将本地服务启动，再将 host 中将要测试的域名解析到<code>nginx</code>服务器的 IP，即可将前端请求转发到开发环境上，通过浏览器地址栏的<code>小锁图标</code>可以看到证书，已验证服务已经部署成功。</p><p><img src=\"/2019/12/30/debug-use-nginx-proxy/2019-12-31-14-57-11.png\" alt></p><p><img src=\"/2019/12/30/debug-use-nginx-proxy/2019-12-31-14-54-46.png\" alt></p><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本文中其实已经提到了两种解决方案了，其实还有其它的解决方案，例如使用<code>fidder</code>这种中间人攻击的方式来实现，这里就不做多叙了。</p>","categories":["后端"],"tags":["docker","nginx"]},{"title":"docker清理","url":"/2020/02/21/docker-clean/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>docker 在使用过程中，可能会产生很多冗余无用的数据，这些数据会占用大量硬盘空间，这里记录下如何清理 docker。</p><h3 id=\"容器清理\"><a href=\"#容器清理\" class=\"headerlink\" title=\"容器清理\"></a>容器清理</h3><ul><li>删除所有关闭的容器</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker rm $(docker ps -a -f status=exited -q)</span><br></pre></td></tr></table></figure><ul><li>关闭并删除所有容器</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker stop $(docker ps -aq)</span><br><span class=\"line\">docker rm $(docker ps -q)</span><br></pre></td></tr></table></figure><h3 id=\"镜像清理\"><a href=\"#镜像清理\" class=\"headerlink\" title=\"镜像清理\"></a>镜像清理</h3><ul><li>删除 dangling images</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker image prune</span><br></pre></td></tr></table></figure><ul><li>删除所有镜像</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h3 id=\"挂载清理\"><a href=\"#挂载清理\" class=\"headerlink\" title=\"挂载清理\"></a>挂载清理</h3><ul><li>删除 dangling volmue</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker volume rm $(docker volume ls -f dangling=true -q)</span><br></pre></td></tr></table></figure>","categories":["DevOps"],"tags":["docker"]},{"title":"docker远程连接","url":"/2019/11/15/docker-connect-remote/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>docker 其实是一个 C/S 程序，执行<code>docker</code>命令行其实就是在与<code>docker daemon</code>服务进行通讯，这里主要是记录下<code>linux</code>下的 <code>docker</code> 如何配置可以被远程访问。</p><h2 id=\"服务端配置\"><a href=\"#服务端配置\" class=\"headerlink\" title=\"服务端配置\"></a>服务端配置</h2><p>在<code>linux</code>上 docker 默认是使用<code>unix socket</code>进行通讯的，如果要远程访问是不支持的，对此需要开启 <code>tcp协议</code>，以支持外部访问。</p><a id=\"more\"></a><h3 id=\"开启-tcp-协议\"><a href=\"#开启-tcp-协议\" class=\"headerlink\" title=\"开启 tcp 协议\"></a>开启 tcp 协议</h3><ol><li><p>修改<code>/lib/systemd/system/docker.service</code>文件</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure></li><li><p>找到<code>ExecStart=/usr/bin/dockerd</code>这一行，添加命令行参数<code>-H tcp://0.0.0.0:3272</code></p><figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[Service]</span></span><br><span class=\"line\"><span class=\"attr\">Type</span>=notify</span><br><span class=\"line\"><span class=\"comment\"># the default is not to use systemd for cgroups because the delegate issues still</span></span><br><span class=\"line\"><span class=\"comment\"># exists and systemd currently does not support the cgroup feature set required</span></span><br><span class=\"line\"><span class=\"comment\"># for containers run by docker</span></span><br><span class=\"line\"><span class=\"attr\">ExecStart</span>=/usr/bin/dockerd -H fd:// -H tcp://<span class=\"number\">0.0</span>.<span class=\"number\">0.0</span>:<span class=\"number\">3272</span> --containerd=/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure></li><li><p>重启 docker</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><p>这样服务端就已经配置好了。</p><h2 id=\"客户端配置\"><a href=\"#客户端配置\" class=\"headerlink\" title=\"客户端配置\"></a>客户端配置</h2><p>首先需要下载一个 docker 客户端，这是一个非常小的可执行文件，不需要为了一个客户端安装整个 docker 应用。</p><h3 id=\"docker-客户端下载\"><a href=\"#docker-客户端下载\" class=\"headerlink\" title=\"docker 客户端下载\"></a>docker 客户端下载</h3><ul><li>linux<ul><li>通过<a href=\"https://download.docker.com/linux/static/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/static/</a>下载</li><li>(Ubuntu/Debian): <code>apt-get install docker-ce-cli</code></li><li>(Centos): <code>yum install docker-ce-cli</code></li></ul></li><li>windows<ul><li>通过<a href=\"https://download.docker.com/win/static/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/win/static/</a>下载</li></ul></li><li>mac<ul><li>通过<a href=\"https://download.docker.com/mac/static/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/mac/static/</a>下载</li></ul></li></ul><p>下载完之后将<code>docker</code>文件加入到<code>PATH</code>中,即可在终端使用了。</p><h3 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h3><p>可以直接使用命令行参数来指定远程 docker 进行访问：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker -H 192.168.1.1:3272 ps</span><br></pre></td></tr></table></figure><p>如果不想每次都输入命令行参数，可以配置<code>DOCKER_HOST</code>环境变量，这样每次运行<code>docker</code>命令时，都会自动设定好对应的远程地址。</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">export DOCKER_HOST=\"tcp://192.168.1.1:3272\"</span><br></pre></td></tr></table></figure><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul><li><a href=\"https://gist.github.com/kekru/4e6d49b4290a4eebc7b597c07eaf61f2\" target=\"_blank\" rel=\"noopener\">Docker connect to remote server.md</a></li></ul>","categories":["DevOps"],"tags":["docker"]},{"title":"docker镜像加速器","url":"/2019/12/06/docker-registry-mirror/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>国内从 docker hub 拉取镜像时速度非常慢，这里记录下国内的一些免费加速镜像服务器。</p><a id=\"more\"></a><h2 id=\"docker-bub\"><a href=\"#docker-bub\" class=\"headerlink\" title=\"docker bub\"></a>docker bub</h2><p>docker 官方仓库加速镜像配置：</p><ol><li><p>修改<code>/etc/docker/daemon.json</code>文件：</p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"registry-mirrors\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"https://docker.mirrors.ustc.edu.cn\"</span>，</span><br><span class=\"line\">    <span class=\"string\">\"https://registry.docker-cn.com\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"http://hub-mirror.c.163.com\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改后重启 docker 服务：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注：也可以使用阿里云的 docker <a href=\"https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\" target=\"_blank\" rel=\"noopener\">镜像服务</a>，但是需要注册账号开启容器服务之后才有</p></blockquote><h2 id=\"gcr-io-以下方法已失效\"><a href=\"#gcr-io-以下方法已失效\" class=\"headerlink\" title=\"gcr.io(以下方法已失效)\"></a><del>gcr.io(以下方法已失效)</del></h2><p>google 仓库加速镜像，需要手动将前缀改一下，替换为<code>gcr.azk8s.cn/google_containers/&lt;image-name&gt;:&lt;version&gt;</code> ,例如：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#docker pull k8s.gcr.io/k8s-dns-node-cache:1.15.7</span><br><span class=\"line\"># 通过镜像仓库拉取</span><br><span class=\"line\">docker pull gcr.azk8s.cn/google_containers/k8s-dns-node-cache:1.15.7</span><br><span class=\"line\"># 重新打tag</span><br><span class=\"line\">docker tag gcr.azk8s.cn/google_containers/k8s-dns-node-cache:1.15.7 k8s.gcr.io/k8s-dns-node-cache:1.15.7</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#docker pull gcr.io/kubernetes-e2e-test-images/echoserver:2.2</span><br><span class=\"line\">docker pull gcr.azk8s.cn/kubernetes-e2e-test-images/echoserver:2.2</span><br><span class=\"line\">docker tag gcr.azk8s.cn/kubernetes-e2e-test-images/echoserver:2.2 gcr.io/kubernetes-e2e-test-images/echoserver:2.2</span><br></pre></td></tr></table></figure><h2 id=\"quay-io-以下方法已失效\"><a href=\"#quay-io-以下方法已失效\" class=\"headerlink\" title=\"quay.io(以下方法已失效)\"></a><del>quay.io(以下方法已失效)</del></h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#docker pull quay.io/deis/go-dev:v1.10.0</span><br><span class=\"line\">docker pull quay.azk8s.cn/deis/go-dev:v1.10.0</span><br><span class=\"line\">docker tag quay.azk8s.cn/deis/go-dev:v1.10.0 quay.io/deis/go-dev:v1.10.0</span><br></pre></td></tr></table></figure><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md</a></p>","categories":["运维"],"tags":["docker","DevOps"]},{"title":"通过web terminal来连接docker容器","url":"/2019/07/19/docker-web-terminal/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在公司内部使用 Jenkins 做 CI/CD 时，经常会碰到项目构建失败的情况，一般情况下通过 Jenkins 的构建控制台输出都可以了解到大概发生的问题，但是有些特殊情况开发需要在 Jenkins 服务器上排查问题，这个时候就只能找运维去调试了，为了开发人员的体验就调研了下 web terminal，能够在构建失败时提供容器终端给开发进行问题的排查。</p><h2 id=\"效果展示\"><a href=\"#效果展示\" class=\"headerlink\" title=\"效果展示\"></a>效果展示</h2><p><img src=\"/2019/07/19/docker-web-terminal/2019-07-22-09-24-49.png\" alt><br>支持颜色高亮，支持<kbd>tab</kbd>键补全，支持复制粘贴，体验基本上与平常的 terminal 一致。</p><a id=\"more\"></a><h2 id=\"基于-docker-的-web-terminal-实现\"><a href=\"#基于-docker-的-web-terminal-实现\" class=\"headerlink\" title=\"基于 docker 的 web terminal 实现\"></a>基于 docker 的 web terminal 实现</h2><h3 id=\"docker-exec-调用\"><a href=\"#docker-exec-调用\" class=\"headerlink\" title=\"docker exec 调用\"></a>docker exec 调用</h3><p>首先想到的就是通过<code>docker exec -it ubuntu /bin/bash</code>命令来开启一个终端，然后将标准输入和输出通过 <code>websocket</code> 与前端进行交互。</p><p>然后发现 docker 有提供 API 和 <a href=\"https://docs.docker.com/develop/sdk/\" target=\"_blank\" rel=\"noopener\">SDK</a> 进行开发的，通过 <code>Go SDK</code>可以很方便的在 docker 里创建一个终端进程:</p><ul><li>安装 sdk</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> get -u github.com/docker/docker/client@<span class=\"number\">8</span>c8457b0f2f8</span><br></pre></td></tr></table></figure><p>这个项目新打的 tag 没有遵循 go mod server 语义，所以如果直接<code>go get -u github.com/docker/docker/client</code>默认安装的是 2017 年的打的一个 tag 版本，这里我直接在 master 分支上找了一个 commit ID，具体原因参考<a href=\"https://github.com/moby/moby/issues/39056\" target=\"_blank\" rel=\"noopener\">issue</a></p><ul><li>调用 exec</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"bufio\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/docker/docker/api/types\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"github.com/docker/docker/client\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化 go sdk</span></span><br><span class=\"line\">\tctx := context.Background()</span><br><span class=\"line\">\tcli, err := client.NewClientWithOpts(client.FromEnv)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcli.NegotiateAPIVersion(ctx)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 在指定容器中执行/bin/bash命令</span></span><br><span class=\"line\">\tir, err := cli.ContainerExecCreate(ctx, <span class=\"string\">\"test\"</span>, types.ExecConfig&#123;</span><br><span class=\"line\">\t\tAttachStdin:  <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tAttachStdout: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tAttachStderr: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tCmd:          []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"/bin/bash\"</span>&#125;,</span><br><span class=\"line\">\t\tTty:          <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 附加到上面创建的/bin/bash进程中</span></span><br><span class=\"line\">\thr, err := cli.ContainerExecAttach(ctx, ir.ID, types.ExecStartCheck&#123;Detach: <span class=\"literal\">false</span>, Tty: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭I/O</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> hr.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 输入</span></span><br><span class=\"line\">\thr.Conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"ls\\r\"</span>))</span><br><span class=\"line\">\t<span class=\"comment\">// 输出</span></span><br><span class=\"line\">\tscanner := bufio.NewScanner(hr.Conn)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> scanner.Scan() &#123;</span><br><span class=\"line\">\t\tfmt.Println(scanner.Text())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个时候 docker 的终端的输入输出已经可以拿到了，接下来要通过 websocket 来和前端进行交互。</p><h3 id=\"前端页面\"><a href=\"#前端页面\" class=\"headerlink\" title=\"前端页面\"></a>前端页面</h3><p>当我们在 linux terminal 上敲下<code>ls</code>命令时，看到的是：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">root@a09f2e7ded0d:/# ls</span><br><span class=\"line\">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class=\"line\">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure><p>实际上从标准输出里返回的字符串却是：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">\u001b[0m\u001b[01;34mbin\u001b[0m   \u001b[01;34mdev\u001b[0m  \u001b[01;34mhome\u001b[0m  \u001b[01;34mlib64\u001b[0m  \u001b[01;34mmnt\u001b[0m  \u001b[01;34mproc\u001b[0m  \u001b[01;34mrun\u001b[0m   \u001b[01;34msrv\u001b[0m  \u001b[30;42mtmp\u001b[0m  \u001b[01;34mvar\u001b[0m</span><br><span class=\"line\">\u001b[01;34mboot\u001b[0m  \u001b[01;34metc\u001b[0m  \u001b[01;34mlib\u001b[0m   \u001b[01;34mmedia\u001b[0m  \u001b[01;34mopt\u001b[0m  \u001b[01;34mroot\u001b[0m  \u001b[01;34msbin\u001b[0m  \u001b[01;34msys\u001b[0m  \u001b[01;34musr\u001b[0m</span><br></pre></td></tr></table></figure><p>对于这种情况，已经有了一个叫<code>xterm.js</code>的库，专门用来模拟 Terminal 的，我们需要通过这个库来做终端的显示。</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> term = <span class=\"keyword\">new</span> Terminal();</span><br><span class=\"line\">term.open(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"terminal\"</span>));</span><br><span class=\"line\">term.write(<span class=\"string\">\"Hello from \\x1B[1;3;31mxterm.js\\x1B[0m $ \"</span>);</span><br></pre></td></tr></table></figure><p>通过官方的例子，可以看到它会将特殊字符做对应的显示：<br><img src=\"/2019/07/19/docker-web-terminal/2019-07-22-10-59-13.png\" alt></p><p>这样的话只需要在 websocket 连上服务器时，将获取到的终端输出使用<code>term.write()</code>写出来，再把前端的输入作为终端的输入就可以实现我们需要的功能了。</p><p>思路是没错的，但是没必要手写，<code>xterm.js</code>已经提供了一个 websocket 插件就是来做这个事的，我们只需要把标准输入和输出的内容通过 websocket 传输就可以了。</p><ul><li>安装 xterm.js</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install xterm</span><br></pre></td></tr></table></figure><ul><li>基于 vue 写的前端页面</li></ul><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div ref=<span class=\"string\">\"terminal\"</span>&gt;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\"><span class=\"comment\">// 引入css</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"xterm/dist/xterm.css\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"xterm/dist/addons/fullscreen/fullscreen.css\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Terminal &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"xterm\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 自适应插件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> fit <span class=\"keyword\">from</span> <span class=\"string\">\"xterm/lib/addons/fit/fit\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 全屏插件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> fullscreen <span class=\"keyword\">from</span> <span class=\"string\">\"xterm/lib/addons/fullscreen/fullscreen\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// web链接插件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> webLinks <span class=\"keyword\">from</span> <span class=\"string\">\"xterm/lib/addons/webLinks/webLinks\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// websocket插件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> attach <span class=\"keyword\">from</span> <span class=\"string\">\"xterm/lib/addons/attach/attach\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"Index\"</span>,</span><br><span class=\"line\">  created() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安装插件</span></span><br><span class=\"line\">    Terminal.applyAddon(attach);</span><br><span class=\"line\">    Terminal.applyAddon(fit);</span><br><span class=\"line\">    Terminal.applyAddon(fullscreen);</span><br><span class=\"line\">    Terminal.applyAddon(webLinks);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化终端</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> terminal = <span class=\"keyword\">new</span> Terminal();</span><br><span class=\"line\">    <span class=\"comment\">// 打开websocket</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">\"ws://127.0.0.1:8000/terminal?container=test\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定到dom上</span></span><br><span class=\"line\">    terminal.open(<span class=\"keyword\">this</span>.$refs.terminal);</span><br><span class=\"line\">    <span class=\"comment\">// 加载插件</span></span><br><span class=\"line\">    terminal.fit();</span><br><span class=\"line\">    terminal.toggleFullScreen();</span><br><span class=\"line\">    terminal.webLinksInit();</span><br><span class=\"line\">    terminal.attach(ws);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id=\"后端-websocket-支持\"><a href=\"#后端-websocket-支持\" class=\"headerlink\" title=\"后端 websocket 支持\"></a>后端 websocket 支持</h3><p>在 go 的标准库中是没有提供 websocket 模块的，这里我们使用官方钦点的 websocket 库。</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">go</span> get -u github.com/gorilla/websocket</span><br></pre></td></tr></table></figure><p>核心代码如下：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// websocket握手配置，忽略Origin检测</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> upgrader = websocket.Upgrader&#123;</span><br><span class=\"line\">\tCheckOrigin: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(r *http.Request)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">terminal</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// websocket握手</span></span><br><span class=\"line\">\tconn, err := upgrader.Upgrade(w, r, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.ParseForm()</span><br><span class=\"line\">\t<span class=\"comment\">// 获取容器ID或name</span></span><br><span class=\"line\">\tcontainer := r.Form.Get(<span class=\"string\">\"container\"</span>)</span><br><span class=\"line\">\t<span class=\"comment\">// 执行exec，获取到容器终端的连接</span></span><br><span class=\"line\">\thr, err := exec(container)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭I/O流</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> hr.Close()</span><br><span class=\"line\">\t<span class=\"comment\">// 退出进程</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\thr.Conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"exit\\r\"</span>))</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 转发输入/输出至websocket</span></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\twsWriterCopy(hr.Conn, conn)</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\twsReaderCopy(conn, hr.Conn)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">exec</span><span class=\"params\">(container <span class=\"keyword\">string</span>)</span> <span class=\"params\">(hr types.HijackedResponse, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 执行/bin/bash命令</span></span><br><span class=\"line\">\tir, err := cli.ContainerExecCreate(ctx, container, types.ExecConfig&#123;</span><br><span class=\"line\">\t\tAttachStdin:  <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tAttachStdout: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tAttachStderr: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tCmd:          []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"/bin/bash\"</span>&#125;,</span><br><span class=\"line\">\t\tTty:          <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 附加到上面创建的/bin/bash进程中</span></span><br><span class=\"line\">\thr, err = cli.ContainerExecAttach(ctx, ir.ID, types.ExecStartCheck&#123;Detach: <span class=\"literal\">false</span>, Tty: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将终端的输出转发到前端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">wsWriterCopy</span><span class=\"params\">(reader io.Reader, writer *websocket.Conn)</span></span> &#123;</span><br><span class=\"line\">\tbuf := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">8192</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tnr, err := reader.Read(buf)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nr &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\terr := writer.WriteMessage(websocket.BinaryMessage, buf[<span class=\"number\">0</span>:nr])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将前端的输入转发到终端</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">wsReaderCopy</span><span class=\"params\">(reader *websocket.Conn, writer io.Writer)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tmessageType, p, err := reader.ReadMessage()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> messageType == websocket.TextMessage &#123;</span><br><span class=\"line\">\t\t\twriter.Write(p)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>以上就完成了一个简单的 docker web terminal 功能，之后只需要通过前端传递<code>container ID</code>或<code>container name</code>就可以打开指定的容器进行交互了。</p><p>完整代码：<a href=\"https://github.com/monkeyWie/docker-web-terminal\" target=\"_blank\" rel=\"noopener\">https://github.com/monkeyWie/docker-web-terminal</a></p>","categories":["DevOps"],"tags":["docker","go"]},{"title":"HTTP调试工具之Fiddler使用教程","url":"/2019/05/24/fiddler-tutorial/","content":"<h2 id=\"Fidder-简介\"><a href=\"#Fidder-简介\" class=\"headerlink\" title=\"Fidder 简介\"></a>Fidder 简介</h2><p><code>Fiddler</code>是一个用于 HTTP 调试的代理服务器应用程序，最初由微软 Internet Explorer 开发团队的前程序经理 Eric Lawrence 编写。通过<code>Fiddler</code>的代理服务器，可以捕获<code>HTTP</code>和<code>HTTPS</code>协议流量，并且可对<code>HTTP</code>请求和响应做出修改，使用<code>Fiddler</code>可以很方便的对<code>HTTP</code>协议进行分析和调试。</p><h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><p><img src=\"/2019/05/24/fiddler-tutorial/2019-05-25-18-17-30.png\" alt><br>客户端的请求经过 Fiddler 的代理服务器转发，再由<code>Fidder</code>对目标服务器进行请求，得到响应之后再返回给客户端，在整个通讯过程中 Fidder 是一个中间人的角色，可以捕获到所有的请求和响应报文。</p><a id=\"more\"></a><h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><code>Fidder</code> 是一款免费的应用，可以直接通过<a href=\"https://www.telerik.com/download/fiddler\" target=\"_blank\" rel=\"noopener\">官网</a>下载，目前只支持 windows 操作系统(官网已经有 mac 和 linux 的 beta 版本)，不过本文只针对 windows 操作系统 下的 fiddler 使用。</p><h2 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h2><p>在下载并安装完成之后，运行<code>Fidder</code>就会启动一个<code>8888</code>端口的 HTTP 代理服务器，并且默认配置下在启动完之后会自动修改<code>IE</code>浏览器中的 HTTP 代理，如果不需要可以在设置(<code>Tools-Options</code>)里面关掉此功能(推荐使用<code>Chrome浏览器</code>+<code>SwitchyOmega插件</code>来进行浏览器代理的设置)。<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-25-17-52-45.png\" alt></p><p>运行完之后可以看到如下界面，软件的左侧<code>会话列表面板</code>中会列出所有捕获的 HTTP 请求，当选中一个请求之后，右侧就会列出该请求的详细数据。<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-26-15-41-46.png\" alt></p><h3 id=\"嗅探-HTTP-报文\"><a href=\"#嗅探-HTTP-报文\" class=\"headerlink\" title=\"嗅探 HTTP 报文\"></a>嗅探 HTTP 报文</h3><p>嗅探报文时只需要为待调试的应用程序设置 HTTP 代理就可以在<code>Fidder</code>中看到 HTTP 报文了，这里就以<code>Chrome</code>为例来演示一下。</p><p>首先给 Chrome 浏览器设置<code>127.0.0.1:8888</code>的 HTTP 代理，这里使用<code>SwitchyOmega插件</code>来进行代理设置：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-25-18-00-15.png\" alt></p><p>如果不安装插件也可以直接通过<code>设置-高级-打开代理设置</code>中进行代理设置：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-26-15-52-33.png\" alt></p><p>然后通过浏览器访问<a href=\"http://www.apache.org\" target=\"_blank\" rel=\"noopener\">http://www.apache.org</a>，就可以在<code>Fiddler</code>中看到刚刚的 HTTP 报文：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-26-15-20-53.png\" alt></p><p>上图中选中的都是<code>Raw</code>选项卡，即展示原始的 HTTP 报文内容，其它选项卡即根据报文做对应的视图展示，这里就不一一介绍了。</p><h3 id=\"解码压缩报文\"><a href=\"#解码压缩报文\" class=\"headerlink\" title=\"解码压缩报文\"></a>解码压缩报文</h3><p>现在大多数 HTTP 服务器都开启了<code>gzip、deflate</code>之类的压缩功能，在 fiddler 中默认捕获的响应是不会解码这些压缩报文的，需要手动解码或者设置 fiddler 自动解码，如下图：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-30-18-30-54.png\" alt></p><h3 id=\"过滤报文\"><a href=\"#过滤报文\" class=\"headerlink\" title=\"过滤报文\"></a>过滤报文</h3><p>在 fiddler 中默认是显示所有捕获到的 HTTP 请求，但有的时候不需要看到这么多不关心的请求，对此 fiddler 提供了<code>filter</code>功能可以自定义过滤出需要关心的请求。</p><p>通过右侧面板-filter 选项，即可进入<code>filter</code>配置页面，可以支持各种各样的过滤规则，这里展示下按域名过滤，可以看到只显示了对应域名下的请求：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-05-30-18-46-40.png\" alt></p><h2 id=\"高级功能\"><a href=\"#高级功能\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h2><h3 id=\"HTTPS-支持\"><a href=\"#HTTPS-支持\" class=\"headerlink\" title=\"HTTPS 支持\"></a>HTTPS 支持</h3><p>默认情况情况下<code>Fidder</code>是不支持嗅探<code>HTTPS</code>报文的，需要在设置里手动开启，通过<code>Tools-Options</code>打开设置面板，切换到<code>https</code>标签页进行以下配置：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-06-13-15-59-07.png\" alt></p><p>在首次开启<code>HTTPS</code>支持时，会提示安装一个 Fidder 生成的<code>CA根证书</code>，安装完之后才能支持 HTTPS 的报文嗅探:<br><img src=\"/2019/05/24/fiddler-tutorial/2019-06-13-16-02-01.png\" alt></p><p>然后再访问下<code>https://www.baidu.com</code>，可以看到已经嗅探到了<code>HTTPS</code>的明文：<br><img src=\"/2019/05/24/fiddler-tutorial/2019-06-13-16-03-50.png\" alt></p><h3 id=\"AutoResponder\"><a href=\"#AutoResponder\" class=\"headerlink\" title=\"AutoResponder\"></a>AutoResponder</h3><p>使用<code>AutoResponder</code>可以通过配置对应的规则自动替换响应内容，在右侧面板中的<code>AutoResponder</code>选项卡中进行配置：</p>","categories":["后端"],"tags":["协议分析","http","fiddler"]},{"title":"git常用功能总结","url":"/2019/05/07/git-summary/","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>git 在本地有三个工作区域：</p><ol><li>工作区</li><li>暂存区</li><li>版本库</li></ol><p>它们之间的转化关系如下图：<br><img src=\"/2019/05/07/git-summary/2019-05-17-23-04-35.png\" alt></p><a id=\"more\"></a><h3 id=\"还原工作区已修改的文件\"><a href=\"#还原工作区已修改的文件\" class=\"headerlink\" title=\"还原工作区已修改的文件\"></a>还原工作区已修改的文件</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 还原指定文件</span></span><br><span class=\"line\">git checkout -- 文件名</span><br><span class=\"line\"><span class=\"comment\"># 还原所有文件</span></span><br><span class=\"line\">git checkout .</span><br><span class=\"line\"><span class=\"comment\"># 删除所有工作区没有add的文件</span></span><br><span class=\"line\">git clean -fd</span><br></pre></td></tr></table></figure><h3 id=\"暂存区-gt-工作区\"><a href=\"#暂存区-gt-工作区\" class=\"headerlink\" title=\"暂存区 -&gt; 工作区\"></a>暂存区 -&gt; 工作区</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#在工作区删除</span></span><br><span class=\"line\">git rm -f 文件名</span><br><span class=\"line\"><span class=\"comment\">#保留在工作区</span></span><br><span class=\"line\">git rm --cache 文件名</span><br></pre></td></tr></table></figure><h3 id=\"版本库-gt-暂存区\"><a href=\"#版本库-gt-暂存区\" class=\"headerlink\" title=\"版本库 -&gt; 暂存区\"></a>版本库 -&gt; 暂存区</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#通过git log查看提交记录，并记录下要回滚到的CommitId</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"comment\">#回滚到指定的commit，工作区和暂存区保留修改</span></span><br><span class=\"line\">git reset CommitId --soft</span><br></pre></td></tr></table></figure><h3 id=\"版本库-gt-工作区\"><a href=\"#版本库-gt-工作区\" class=\"headerlink\" title=\"版本库 -&gt; 工作区\"></a>版本库 -&gt; 工作区</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#通过git log查看提交记录，并记录下要回滚到的CommitId</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span></span><br><span class=\"line\"><span class=\"comment\">#回滚到指定的commit，工作区保留修改</span></span><br><span class=\"line\">git reset CommitId --mixed</span><br><span class=\"line\"><span class=\"comment\">#默认模式就是mixed</span></span><br><span class=\"line\">git reset CommitId</span><br><span class=\"line\"><span class=\"comment\">#回滚到指定的commit，工作区不保留修改</span></span><br><span class=\"line\">git reset --hard</span><br><span class=\"line\"><span class=\"comment\">#回滚到指定的commit，并且将回滚的内容当做一次commit</span></span><br><span class=\"line\">git revert CommitId</span><br></pre></td></tr></table></figure><h3 id=\"远程仓库回滚\"><a href=\"#远程仓库回滚\" class=\"headerlink\" title=\"远程仓库回滚\"></a>远程仓库回滚</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#将上面回滚的记录强制推到远程分支上即可</span></span><br><span class=\"line\">git push -f</span><br></pre></td></tr></table></figure><h3 id=\"储藏\"><a href=\"#储藏\" class=\"headerlink\" title=\"储藏\"></a>储藏</h3><p>有时间会有一种情况，当我们在写需求的时候代码还没写完，突然来了个紧急的 BUG 要修复，这个时候我们就可以把我们现在写的代码储藏起来，并且从开发分支上拉一个新的分支去修复 bug，当修完 bug 时再切回我们刚刚写需求的分支。</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#储藏</span></span><br><span class=\"line\">git stash</span><br><span class=\"line\"><span class=\"comment\">#还原</span></span><br><span class=\"line\">git stash pop</span><br></pre></td></tr></table></figure><h3 id=\"git-log显示优化\"><a href=\"#git-log显示优化\" class=\"headerlink\" title=\"git log显示优化\"></a>git log显示优化</h3><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#注册git logp命令</span></span><br><span class=\"line\">git config --global alias.logp <span class=\"string\">\"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --\"</span></span><br><span class=\"line\"><span class=\"comment\">#查看log</span></span><br><span class=\"line\">git logp</span><br></pre></td></tr></table></figure>","categories":["版本控制"],"tags":["git"]},{"title":"github镜像站","url":"/2020/02/11/github-mirror/","content":"<p><code>github release</code>一直下载不动，或者干脆直接下载失败，搜索一番发现 github 竟然还有镜像站点，下载速度还不错，地址：<del><a href=\"http://github-mirror.bugkiller.org\" target=\"_blank\" rel=\"noopener\">http://github-mirror.bugkiller.org</a></del>，新地址：<a href=\"https://github.com.cnpmjs.org\" target=\"_blank\" rel=\"noopener\">https://github.com.cnpmjs.org/</a></p>","categories":["后端"],"tags":["github"]},{"title":"Go语言flag接收slice和map类型参数","url":"/2019/09/03/go-flag-slice-map/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>go 自带的<code>flag</code>包可以很容易的实现一个命令行程序的参数解析，但是<code>flag</code>包默认只支持几个基本类型的参数解析，如果需要传递<code>slice</code>或者<code>map</code>类型时就要自定义了，这里记录一下。</p><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>通过<code>flag.Var()</code>方法传递一个<code>Value</code>接口，即可自定义命令行参数的解析，<code>flag.Value</code>接口：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Value interface &#123;</span><br><span class=\"line\">\tString() string</span><br><span class=\"line\">\tSet(string) error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a><p>接下来通过自定义类型来实现这个接口即可满足需求。</p><h2 id=\"slice-传递\"><a href=\"#slice-传递\" class=\"headerlink\" title=\"slice 传递\"></a>slice 传递</h2><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> sliceFlag []<span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *sliceFlag)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%v\"</span>, []<span class=\"keyword\">string</span>(*f))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *sliceFlag)</span> <span class=\"title\">Set</span><span class=\"params\">(value <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t*f = <span class=\"built_in\">append</span>(*f, value)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hostsFlag sliceFlag</span><br><span class=\"line\">    flag.Var(&amp;hostsFlag, <span class=\"string\">\"host\"</span>, <span class=\"string\">\"Application hosts,for example: -host=a.com -host=b.com\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是数组的扩容需要使用<code>*f = append(*f, value)</code>，来修改原本的数组</p><h2 id=\"map-传递\"><a href=\"#map-传递\" class=\"headerlink\" title=\"map 传递\"></a>map 传递</h2><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f mapFlag)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%v\"</span>, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>(f))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f mapFlag)</span> <span class=\"title\">Set</span><span class=\"params\">(value <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\tsplit := strings.SplitN(value, <span class=\"string\">\"=\"</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\tf[split[<span class=\"number\">0</span>]] = split[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hostsFlag sliceFlag</span><br><span class=\"line\">    flag.Var(&amp;hostsFlag, <span class=\"string\">\"env\"</span>, <span class=\"string\">\"env list,for example: -env key1=value1 -env key2=value2\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["后端"],"tags":["go"]},{"title":"Go语言中for range的\"坑\"","url":"/2019/07/01/go-for-range-trap/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Go 中的<code>for range</code>组合可以和方便的实现对一个数组或切片进行遍历，但是在某些情况下使用<code>for range</code>时很可能就会被<code>&quot;坑&quot;</code>，下面用一段代码来模拟下：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tarr1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tarr2 := <span class=\"built_in\">make</span>([]*<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(arr1))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> arr1 &#123;</span><br><span class=\"line\">\t\tarr2[i] = &amp;v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> arr2 &#123;</span><br><span class=\"line\">\t\tfmt.Println(*v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a><p>代码解析：</p><ol><li>创建一个<code>int slice</code>，变量名为<code>arr1</code>并初始化 1,2,3 作为切片的值。</li><li>创建一个<code>*int slice</code>，变量名为<code>arr2</code>。</li><li>通过<code>for range</code>遍历<code>arr1</code>，然后获取每一个元素的指针，赋值到对应<code>arr2</code>中。</li><li>逐行打印<code>arr2</code>中每个元素的值。</li></ol><p>从代码上看，打印出来的结果应该是</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure><p>然而真正的结果是</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">3</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure><h3 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h3><p>因为<code>for range</code>在遍历<code>值类型</code>时，其中的<code>v</code>变量是一个<code>值</code>的拷贝，当使用<code>&amp;</code>获取指针时，实际上是获取到<code>v</code>这个临时变量的指针，而<code>v</code>变量在<code>for range</code>中只会创建一次，之后循环中会被一直重复使用，所以在<code>arr2</code>赋值的时候其实都是<code>v</code>变量的指针，而<code>&amp;v</code>最终会指向<code>arr1</code>最后一个元素的值拷贝。</p><p>来看看下面这个代码，用<code>for i</code>来模拟<code>for range</code>，这样更易于理解:</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tarr1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tarr2 := <span class=\"built_in\">make</span>([]*<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(arr1))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> v <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">len</span>(arr1);i++ &#123;</span><br><span class=\"line\">\t\tv = arr1[i]</span><br><span class=\"line\">\t\tarr2[i] = &amp;v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> arr2 &#123;</span><br><span class=\"line\">\t\tfmt.Println(*v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol><li>传递原始指针</li></ol><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    arr2 := <span class=\"built_in\">make</span>([]*<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(arr1))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> arr1 &#123;</span><br><span class=\"line\">        arr2[i] = &amp;arr1[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> arr2 &#123;</span><br><span class=\"line\">        fmt.Println(*v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>使用临时变量</li></ol><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    arr2 := <span class=\"built_in\">make</span>([]*<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(arr1))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> arr1 &#123;</span><br><span class=\"line\">        t := v</span><br><span class=\"line\">        arr2[i] = &amp;t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> arr2 &#123;</span><br><span class=\"line\">        fmt.Println(*v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ol start=\"3\"><li>使用闭包</li></ol><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    arr1 := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">    arr2 := <span class=\"built_in\">make</span>([]*<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(arr1))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> arr1 &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(v <span class=\"keyword\">int</span>)</span></span>&#123;</span><br><span class=\"line\">             arr2[i] = &amp;v</span><br><span class=\"line\">        &#125;(v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> arr2 &#123;</span><br><span class=\"line\">        fmt.Println(*v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"官方提示\"><a href=\"#官方提示\" class=\"headerlink\" title=\"官方提示\"></a>官方提示</h2><p>由于这一问题过于普遍，Golang甚至将其写入了文档的『常见错误』部分：<a href=\"https://github.com/golang/go/wiki/CommonMistakes#using-reference-to-loop-iterator-variable\" target=\"_blank\" rel=\"noopener\">文档</a></p>","categories":["后端"],"tags":["go"]},{"title":"Go语言HTTP请求流式写入body","url":"/2020/06/01/go-http-request-body-stream-writer/","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>最近在开发一个功能时，需要通过 http 协议上报大量的日志内容，但是在 Go 标准库里的 http client 的 API 是这样的：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">http.NewRequest(method, url <span class=\"keyword\">string</span>, body io.Reader)</span><br></pre></td></tr></table></figure><p>body 是通过<code>io.Reader</code>接口来传递，并没有暴露一个<code>io.Writer</code>接口来提供写入的办法，先来看看正常情况下怎么写入一个<code>body</code>，示例：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">buf := bytes.NewBuffer([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"hello\"</span>))</span><br><span class=\"line\">http.Post(<span class=\"string\">\"localhost:8099/report\"</span>,<span class=\"string\">\"text/pain\"</span>,buf)</span><br></pre></td></tr></table></figure><p>需要先把要写入的数据放在<code>Buffer</code>中，放内存缓存着，但是我需要写入<code>大量</code>的数据，如果都放内存里肯定要 OOM 了，http client 并没有提供<code>流式写入</code>的方法，我这么大的数据量直接用<code>Buffer</code>肯定是不行的，最后在 google 了一番之后找到了解决办法。</p><a id=\"more\"></a><h3 id=\"使用-io-pipe\"><a href=\"#使用-io-pipe\" class=\"headerlink\" title=\"使用 io.pipe\"></a>使用 io.pipe</h3><p>调用<code>io.pipe()</code>方法会返回<code>Reader</code>和<code>Writer</code>接口实现对象，通过<code>Writer</code>写数据，<code>Reader</code>就可以读到，利用这个特性就可以实现流式的写入，开一个协程来写，然后把<code>Reader</code>传递到方法中，就可以实现 http client body 的流式写入了。</p><ul><li>代码示例：</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">pr, pw := io.Pipe()</span><br><span class=\"line\"><span class=\"comment\">// 开协程写入大量数据</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++ &#123;</span><br><span class=\"line\">        pw.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">\"line:%d\\r\\n\"</span>, i)))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pw.Close()</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"comment\">// 传递Reader</span></span><br><span class=\"line\">http.Post(<span class=\"string\">\"localhost:8099/report\"</span>,<span class=\"string\">\"text/pain\"</span>,pr)</span><br></pre></td></tr></table></figure><h3 id=\"源码阅读\"><a href=\"#源码阅读\" class=\"headerlink\" title=\"源码阅读\"></a>源码阅读</h3><h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>了解 go 中 http client 对于 body 的传输是如何处理的。</p><h4 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h4><p>在构建 Request 的时候，会断言 body 参数的类型，当类型为<code>*bytes.Buffer</code>、<code>*bytes.Reader</code>、<code>*strings.Reader</code>的时候，可以直接通过<code>Len()</code>方法取出长度，用于<code>Content-Length</code>请求头，相关代码<a href=\"https://github.com/golang/go/blob/6be4a5eb4898c7b5e7557dda061cc09ba310698b/src/net/http/request.go#L872-L914\" target=\"_blank\" rel=\"noopener\">net/http/request.go#L872-L914</a>：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> body != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> v := body.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> *bytes.Buffer:</span><br><span class=\"line\">        req.ContentLength = <span class=\"keyword\">int64</span>(v.Len())</span><br><span class=\"line\">        buf := v.Bytes()</span><br><span class=\"line\">        req.GetBody = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(io.ReadCloser, error)</span></span> &#123;</span><br><span class=\"line\">            r := bytes.NewReader(buf)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ioutil.NopCloser(r), <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> *bytes.Reader:</span><br><span class=\"line\">        req.ContentLength = <span class=\"keyword\">int64</span>(v.Len())</span><br><span class=\"line\">        snapshot := *v</span><br><span class=\"line\">        req.GetBody = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(io.ReadCloser, error)</span></span> &#123;</span><br><span class=\"line\">            r := snapshot</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ioutil.NopCloser(&amp;r), <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> *strings.Reader:</span><br><span class=\"line\">        req.ContentLength = <span class=\"keyword\">int64</span>(v.Len())</span><br><span class=\"line\">        snapshot := *v</span><br><span class=\"line\">        req.GetBody = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(io.ReadCloser, error)</span></span> &#123;</span><br><span class=\"line\">            r := snapshot</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ioutil.NopCloser(&amp;r), <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> req.GetBody != <span class=\"literal\">nil</span> &amp;&amp; req.ContentLength == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        req.Body = NoBody</span><br><span class=\"line\">        req.GetBody = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(io.ReadCloser, error)</span></span> &#123; <span class=\"keyword\">return</span> NoBody, <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在链接建立的时候，会通过<code>body</code>和上一步中得到的<code>ContentLength</code>来进行判断，如果<code>body!=nil</code>并且<code>ContentLength==0</code>时，可能就会启用<code>Chunked</code>编码进行传输，相关代码<a href=\"https://github.com/golang/go/blob/6be4a5eb4898c7b5e7557dda061cc09ba310698b/src/net/http/transfer.go#L82-L96\" target=\"_blank\" rel=\"noopener\">net/http/transfer.go#L82-L96</a>：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> *Request:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> rr.ContentLength != <span class=\"number\">0</span> &amp;&amp; rr.Body == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">\"http: Request.ContentLength=%d with nil Body\"</span>, rr.ContentLength)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    t.Method = valueOrDefault(rr.Method, <span class=\"string\">\"GET\"</span>)</span><br><span class=\"line\">    t.Close = rr.Close</span><br><span class=\"line\">    t.TransferEncoding = rr.TransferEncoding</span><br><span class=\"line\">    t.Header = rr.Header</span><br><span class=\"line\">    t.Trailer = rr.Trailer</span><br><span class=\"line\">    t.Body = rr.Body</span><br><span class=\"line\">    t.BodyCloser = rr.Body</span><br><span class=\"line\">    <span class=\"comment\">// 当body为非nil，并且ContentLength==0时，这里返回-1</span></span><br><span class=\"line\">    t.ContentLength = rr.outgoingLength()</span><br><span class=\"line\">    <span class=\"comment\">// TransferEncoding没有手动设置，并且请求方法为PUT、POST、PATCH时，会启用chunked编码传输</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> t.ContentLength &lt; <span class=\"number\">0</span> &amp;&amp; <span class=\"built_in\">len</span>(t.TransferEncoding) == <span class=\"number\">0</span> &amp;&amp; t.shouldSendChunkedRequestBody() &#123;</span><br><span class=\"line\">        t.TransferEncoding = []<span class=\"keyword\">string</span>&#123;<span class=\"string\">\"chunked\"</span>&#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><h4 id=\"验证-一\"><a href=\"#验证-一\" class=\"headerlink\" title=\"验证(一)\"></a>验证(一)</h4><p>按照对源码的理解，可以得知在使用<code>io.pipe()</code>方法进行流式传输时，会使用<code>chunked</code>编码进行传输，通过以下代码进行验证：</p><ul><li>服务端</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/report\"</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\thttp.ListenAndServe(<span class=\"string\">\":8099\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    pr, rw := io.Pipe()</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++ &#123;</span><br><span class=\"line\">            rw.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">\"line:%d\\r\\n\"</span>, i)))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rw.Close()</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    http.Post(<span class=\"string\">\"localhost:8099/report\"</span>,<span class=\"string\">\"text/pain\"</span>,buf)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>先运行服务端，然后运行客户端，并且使用<code>WireShake</code>进行抓包分析，结果如下：</p><p><img src=\"/2020/06/01/go-http-request-body-stream-writer/2020-06-02-14-26-42.png\" alt></p><p>可以看到和预想的结果一样。</p><h4 id=\"验证-二\"><a href=\"#验证-二\" class=\"headerlink\" title=\"验证(二)\"></a>验证(二)</h4><p>在数据量大的时候<code>chunked</code>编码会增加额外的开销，包括编解码和额外的报文开销，能不能不用<code>chunked</code>编码来进行<code>流式传输</code>呢？通过源码可以得知，当<code>ContentLength</code>不为 0 时，如果能预先计算出待传输的<code>body size</code>，是不是就能避免<code>chunked</code>编码呢？思路就到这，接着就是写代码验证：</p><ul><li>服务端</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/report\"</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\thttp.ListenAndServe(<span class=\"string\">\":8099\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">count := <span class=\"number\">100</span></span><br><span class=\"line\">line := []<span class=\"keyword\">byte</span>(<span class=\"string\">\"line\\r\\n\"</span>)</span><br><span class=\"line\">pr, rw := io.Pipe()</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; count; i++ &#123;</span><br><span class=\"line\">        rw.Write(line)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rw.Close()</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"><span class=\"comment\">// 构造request对象</span></span><br><span class=\"line\">request, err := http.NewRequest(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"http://localhost:8099/report\"</span>, pr)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatal(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 提前计算出ContentLength</span></span><br><span class=\"line\">request.ContentLength = <span class=\"keyword\">int64</span>(<span class=\"built_in\">len</span>(line) * count)</span><br><span class=\"line\"><span class=\"comment\">// 发起请求</span></span><br><span class=\"line\">http.DefaultClient.Do(request)</span><br></pre></td></tr></table></figure><p>抓包结果：<br><img src=\"/2020/06/01/go-http-request-body-stream-writer/2020-06-02-14-44-18.png\" alt></p><p>可以看到确实直接使用的<code>Content-Length</code>进行传输，没有进行<code>chunked</code>编码了。</p><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文的目的主要是记录 go 语言中<code>http client</code>如何进行流式的写入，并通过阅读源码了解<code>http client</code>内部对 body 的写入是如何进行处理的，通过两个验证可以得知，如果能提前计算出<code>ContentLength</code>并且对性能要求比较苛刻的情况下，可以通过手动设置<code>ContentLength</code>来优化性能。</p>","categories":["后端"],"tags":["go"]},{"title":"Go语言方法复用","url":"/2020/03/31/go-reuse-method/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>用过<code>OOP</code>的都知道，子类重写父类的方法可以优雅的实现代码的复用，例如：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">People</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">\"name:%s age:%d sex:%s\\n\"</span>, name, age, sex());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">sex</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Male</span> <span class=\"keyword\">extends</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Male</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(name, age);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"M\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Female</span> <span class=\"keyword\">extends</span> <span class=\"title\">People</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Female</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(name, age);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"F\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Male(<span class=\"string\">\"小明\"</span>,<span class=\"number\">20</span>).hello();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Female(<span class=\"string\">\"小红\"</span>,<span class=\"number\">18</span>).hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">name:小明 age:20 sex:M</span><br><span class=\"line\">name:小红 age:18 sex:F</span><br></pre></td></tr></table></figure><p>但是<code>go</code>不支持<code>OOP</code>，那么在<code>go</code>中要类似情况的应该怎么实现？</p><a id=\"more\"></a><h3 id=\"错误的示范\"><a href=\"#错误的示范\" class=\"headerlink\" title=\"错误的示范\"></a>错误的示范</h3><p>一开始我想通过<code>go</code>提供的组合模拟继承来实现，于是有了以下代码：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> People <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">\tage  <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">say</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"name:%s age:%d sex:%s\\n\"</span>, p.name, p.age, p.sex())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">sex</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"unknown\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Male <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPeople</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Male)</span> <span class=\"title\">sex</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"M\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Female <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tPeople</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Female)</span> <span class=\"title\">sex</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"F\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm := &amp;Male&#123;People&#123;name: <span class=\"string\">\"小明\"</span>, age: <span class=\"number\">20</span>&#125;&#125;</span><br><span class=\"line\">\tm.say()</span><br><span class=\"line\">\tf := &amp;Female&#123;People&#123;name: <span class=\"string\">\"小红\"</span>, age: <span class=\"number\">18</span>&#125;&#125;</span><br><span class=\"line\">\tf.say()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中分别<code>Male</code>和<code>Female</code>都重写了<code>sex()</code>方法，来进行方法重用，然而运行的结果却和预料的不一样，输出：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">name:小明 age:20 sex:unknown</span><br><span class=\"line\">name:小红 age:18 sex:unknown</span><br></pre></td></tr></table></figure><p>从输出结果可以看到，依旧是调用的<code>people结构体的sex方法</code>，因为<code>go</code>并不支持<code>OOP</code>，组合类型其实只是某种形式上的语法弹，并不会改变<code>&quot;父类&quot;</code>中调用的方法。</p><h3 id=\"通过接口实现\"><a href=\"#通过接口实现\" class=\"headerlink\" title=\"通过接口实现\"></a>通过接口实现</h3><p>抽象一个<code>Sex</code>接口出来，由<code>Male</code>和<code>Female</code>来具体实现，直接上代码：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Sex <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tsex() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> People <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname <span class=\"keyword\">string</span></span><br><span class=\"line\">\tage  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tSex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *People)</span> <span class=\"title\">say</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"name:%s age:%d sex:%s\\n\"</span>, p.name, p.age, p.sex())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Male <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Male)</span> <span class=\"title\">sex</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"M\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Male)</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"男生爱打游戏\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Female <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Female)</span> <span class=\"title\">sex</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">\"F\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *Female)</span> <span class=\"title\">sing</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">\"女生爱唱歌\"</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm := &amp;People&#123;name: <span class=\"string\">\"小明\"</span>, age: <span class=\"number\">20</span>, Sex: &amp;Male&#123;&#125;&#125;</span><br><span class=\"line\">\tm.say()</span><br><span class=\"line\">\tf := &amp;People&#123;name: <span class=\"string\">\"小红\"</span>, age: <span class=\"number\">18</span>, Sex: &amp;Female&#123;&#125;&#125;</span><br><span class=\"line\">\tf.say()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">name:小明 age:20 sex:M</span><br><span class=\"line\">name:小红 age:18 sex:F</span><br></pre></td></tr></table></figure><p>不过这样也引入了一个新的问题，<code>m</code>和<code>f</code>变量都是<code>People</code>类型，比如现在有个方法需要通过性别来做不同的处理，那么就要使用<code>类型断言</code>来实现了，例如：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handle</span><span class=\"params\">(people *People)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> sex := people.Sex.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> *Male:</span><br><span class=\"line\">\t\tsex.play()</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> *Female:</span><br><span class=\"line\">\t\tsex.sing()</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">\"error\"</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["后端"],"tags":["go"]},{"title":"Elasticsearch6.x学习笔记 - 安装","url":"/2018/08/06/hello-elasticsearch-install/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近心血来潮，准备学习下开源届首选的搜索引擎<code>Elasticsearch</code>，在了解相关概念之后就准备在虚拟机装上试一试了。</p><a id=\"more\"></a><h2 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h2><p>在<a href=\"https://www.elastic.co/downloads/elasticsearch\" target=\"_blank\" rel=\"noopener\">Elasticsearch 官网</a>下载，下载完后解压至任意目录。</p><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">./bin/elasticsearch</span><br><span class=\"line\">#后台运行</span><br><span class=\"line\">./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p>然而并没有就这么容易启动就成功，下面一一排查启动故障。</p><h2 id=\"排查启动故障\"><a href=\"#排查启动故障\" class=\"headerlink\" title=\"排查启动故障\"></a>排查启动故障</h2><ol><li><p>启动报 OOM 内存溢出<br><strong>原因</strong>：elasticsearch 默认的 jvm 堆内存大小为 1GB，而我虚拟机分配的内存也才 1GB，启动时系统分配不了这么大的堆内存所以直接内存溢出了。<br><strong>解决办法</strong>：把堆内存调小点，修改./config/jvm.options 文件，把堆内存设置为 512MB。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xms512m</span><br><span class=\"line\">-Xmx512m</span><br></pre></td></tr></table></figure></li><li><p>不能以 root 用户启动<br><strong>原因</strong>：elasticsearch 为了安全性默认不允许 root 用户来启动。<br><strong>解决办法</strong>：</p><ol><li>在启动参数中添加<code>-Des.insecure.allow.root=true</code>，但是我测试了根本没效果，原来是 elasticsearch5.x 版本把这个属性给去掉了，也就是说绝对禁止 root 用户运行了，这个是相关<a href=\"https://github.com/elastic/elasticsearch/pull/18694/files\" target=\"_blank\" rel=\"noopener\">PR</a>。</li><li>添加一个用户来运行<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#添加一个用户名为es</span><br><span class=\"line\">useradd es</span><br><span class=\"line\">#把elasticsearch目录的所属用户和组设置为es</span><br><span class=\"line\">chown -R es:es ./</span><br><span class=\"line\">#切换到es用户</span><br><span class=\"line\">su es</span><br><span class=\"line\">#运行</span><br><span class=\"line\">./bin/elasticsearch</span><br></pre></td></tr></table></figure></li></ol></li><li><p>max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]<br><strong>原因</strong>：elasticsearch 启动时检测到用户最大文件描述符限制低于 65536 而抛出的异常。<br><strong>解决办法</strong>：修改 es 用户最大文件描述符限制</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#切换到root用户</span><br><span class=\"line\">su root</span><br><span class=\"line\">#修改对应文件</span><br><span class=\"line\">vi /etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>在最后添加两行内容，设置 es 用户最大文件描述符限制为 65536</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">es soft nofile 65536</span><br><span class=\"line\">es hard nofile 65536</span><br></pre></td></tr></table></figure></li><li><p>max number of threads [3802] for user [es] is too low, increase to at least [4096]<br><strong>原因</strong>：elasticsearch 启动时检测到用户最大的线程数限制低于 4096 而抛出的异常。<br><strong>解决办法</strong>：修改 es 用户最大的线程数限</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#切换到root用户</span><br><span class=\"line\">su root</span><br><span class=\"line\">#修改对应文件</span><br><span class=\"line\">vi /etc/security/limits.d/20-nproc.conf</span><br></pre></td></tr></table></figure><p>可以看到 root 用户是无限制的，而<em>代表的其他用户限制是 4096。(</em>很奇怪既然是 4096 为什么上面提示说最大线程数是 3802 呢？*)，先不管原因了搜到了解决方案在下面加一行。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">*          hard    nproc     4096</span><br></pre></td></tr></table></figure></li><li><p>max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]<br><strong>原因</strong>：elasticsearch 启动时检测到系统最大虚拟内存低于 262144 而抛出的异常。<br><strong>解决办法</strong>：修改系统最大虚拟内存</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>修改或添加 vm.max_map_count 参数</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vm.max_map_count=262144</span><br></pre></td></tr></table></figure><p>刷新配置</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sysctl -p</span><br></pre></td></tr></table></figure></li></ol><h2 id=\"启动成功\"><a href=\"#启动成功\" class=\"headerlink\" title=\"启动成功\"></a>启动成功</h2><p>启动成功之后访问<code>http://127.0.0.1:9200</code>，就可以看到服务器相关信息了。<br><img src=\"/2018/08/06/hello-elasticsearch-install/2018-08-06-15-32-56.png\" alt><br>默认情况下是服务器是监听<code>127.0.0.1</code>，如果让别的网段访问到的话需要修改<code>./config/elasticsearch.yml</code>文件。<br></p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#配置所有网段可以访问</span><br><span class=\"line\">network.host: 0.0.0.0</span><br></pre></td></tr></table></figure><p></p>","categories":["后端"],"tags":["java","elasticsearch"]},{"title":"IDEA插件推荐之Maven-Helper","url":"/2020/07/13/idea-maven-helper-plugin/","content":"<h3 id=\"Maven-Helper-插件介绍\"><a href=\"#Maven-Helper-插件介绍\" class=\"headerlink\" title=\"Maven-Helper 插件介绍\"></a>Maven-Helper 插件介绍</h3><p>这个插件能可以通过 UI 界面的方式来查看 maven 项目的依赖关系，当然还有最重要的功能<code>解决依赖冲突</code>，使用起来非常的方便，效果图：<br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-01-29.png\" alt></p><p>在开发 JAVA 项目的时候，经常会由于 maven 依赖冲突导致项目启动失败，这个时候往往会懵逼，到底哪个依赖冲突了，需要排除哪个子依赖，有了这个插件之后就可以很快的定位到冲突的组件，并进行排除。</p><a id=\"more\"></a><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>首先进入 IDEA plugins 市场，搜索<code>Maven Helper</code>进行安装：<br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-08-12.png\" alt></p><p>这里需要注意的是国内网络连接 jetbrains 服务器会比较慢，可能需要梯子，通过右上角的设置按钮进行代理设置：<br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-08-56.png\" alt><br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-09-11.png\" alt></p><p>安装完成之后重启 IDEA，打开项目里的<code>pom.xml</code>文件，就可以看到左下角有一个<code>Dependency Analyzer</code>选项卡，点进去就可以看到界面了：<br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-10-20.png\" alt></p><h3 id=\"排除冲突\"><a href=\"#排除冲突\" class=\"headerlink\" title=\"排除冲突\"></a>排除冲突</h3><p>选中<code>Conflicts</code>插件就会列出有冲突的依赖，然后选择某个依赖就可以看到详细信息：<br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-13-41.png\" alt></p><p>可以看到这个例子，在此项目中有两个<code>hutool-all</code>版本，如果项目启动失败提示跟此依赖有关的话，就可以通过右键指定版本进行排除：<br><img src=\"/2020/07/13/idea-maven-helper-plugin/2020-07-20-12-15-25.png\" alt></p><p>点击<code>Exclude</code>之后，插件自动会在<code>pom.xml</code>文件中添加<code>&lt;exclusion&gt;</code>相关代码，进行子依赖的排除。</p>","categories":["IDE"],"tags":["maven","idea"]},{"title":"java反射使用getDeclaredMethods会获取到父类方法的解决办法","url":"/2019/07/03/java-reflect-getdeclaredmethods-issue/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近在使用<code>getDeclaredMethods</code>方法获取类中的方法时碰到一个奇怪的问题，先来看看<code>getDeclaredMethods</code>方法的注释：</p><blockquote><p>Returns an array containing Method objects reflecting all the declared methods of the class or interface represented by this Class object, including public, protected, default (package) access, and private methods, <strong>but excluding inherited methods</strong>.</p></blockquote><p>谷歌翻译:</p><blockquote><p>返回一个包含 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有声明方法，包括 public，protected，default（包）访问和私有方法，<strong>但不包括继承的方法</strong>。</p></blockquote><p>注意加粗的字体，可以看到 JDK 注释里明确的说明了<code>getDeclaredMethods</code>方法不会返回继承的方法，我要的功能就是取当前类上的方法(不包含父类的)，但是事情并没有这么简单，下面一起来看看是为什么。</p><a id=\"more\"></a><h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><h4 id=\"正常案例\"><a href=\"#正常案例\" class=\"headerlink\" title=\"正常案例\"></a>正常案例</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Method method : B<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getDeclaredMethods</span>()) </span>&#123;</span><br><span class=\"line\">            System.out.println(method.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>代码非常简单，就是一个子类(B)重写了父类(A)的<code>add(Object obj)</code>方法，然后通过<code>B.class.getDeclaredMethods()</code>来获取子类(B)上声明的所有方法，运行结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void Test$B.add(java.lang.Object)</span><br></pre></td></tr></table></figure><p>可以看到打印出了子类(B)的<code>add(Object obj)</code>方法，并没把父类(A)中的<code>add(Object obj)</code>方法也打印出来，符合预期的结果。</p><h4 id=\"非正常的案例\"><a href=\"#非正常的案例\" class=\"headerlink\" title=\"非正常的案例\"></a>非正常的案例</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span>&lt;<span class=\"title\">String</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(String obj)</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Method method : B<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getDeclaredMethods</span>()) </span>&#123;</span><br><span class=\"line\">            System.out.println(method.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>和之前稍有不同的是，在父类(A)上声明了一个<code>泛型&lt;T&gt;</code>，然后子类(B)实现了泛型并重写父类的方法，运行结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void Test$B.add(java.lang.String)</span><br><span class=\"line\">void Test$B.add(java.lang.Object)</span><br></pre></td></tr></table></figure><p>震惊！不是不返回继承的方法吗？那碰到这种情况该怎么忽略掉来自父类上的方法呢？</p><h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>使用<code>method.isBridge()</code>方法来判断是否为继承的方法，具体原因可以看<a href=\"http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html\" target=\"_blank\" rel=\"noopener\">这里</a>，改造后的代码：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : B<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getDeclaredMethods</span>()) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 判断是非继承的方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!method.isBridge())&#123;</span><br><span class=\"line\">            System.out.println(method.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://stackoverflow.com/questions/1961350/problem-in-the-getdeclaredmethods-java\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/1961350/problem-in-the-getdeclaredmethods-java</a><br><a href=\"http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html\" target=\"_blank\" rel=\"noopener\">http://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html</a></p>","categories":["后端"],"tags":["java","反射"]},{"title":"java8下HTTP代理身份验证设置","url":"/2019/06/11/java8-http-proxy-auth/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>由于公司内部应用要调用钉钉的 API，但是钉钉 API 有一个 <code>IP 白名单</code>限制，而公司的外网 IP 经常变动，每次变动都需要在钉钉的后台配置一个 IP，在开发环境调试非常的麻烦，于是就让运维在一台外网服务器上搭建了一个<code>HTTP代理服务</code>，通过代理服务器转发，只需要设置<code>代理服务器</code>的外网 IP 就可以避免之前的问题了。</p><a id=\"more\"></a><p>但是好景不长，用着用着发现<code>代理服务器</code>越来越卡，接口请求经常超时，后来运维通过日志发现<code>代理服务器</code>已经被别人扫描到并大量的在使用了(多半用于爬虫的 IP 池)，因为之前<code>代理服务器</code>没有开启<code>身份验证</code>，然后运维加上了<code>身份验证</code>之后问题就解决了。</p><p>这里主要是记录一下 JAVA 8 中使用 HTTP 代理并启用<code>身份验证</code>的方法，在网上搜了好多资料才搞定(<em>很多都是过时的办法不适用 JAVA 8，差点就准备自己去看 JDK 源码了</em>)。</p><h3 id=\"全局设置\"><a href=\"#全局设置\" class=\"headerlink\" title=\"全局设置\"></a>全局设置</h3><p>全局设置会影响所有由 JDK 中<code>HttpURLConnection</code>发起的请求，很多 HTTP 客户端类库都是封装的此类，所以在类库没有暴露 HTTP 代理设置的就可以基于此方案来设置(<em>比如我用的钉钉 SDK</em>)。</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启用http代理</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"http.proxySet\"</span>, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 发起http请求时使用的代理服务器配置</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"http.proxyHost\"</span>, <span class=\"string\">\"ip\"</span>);</span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"http.proxyPort\"</span>, <span class=\"string\">\"port\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 发起https请求时使用的代理服务器配置</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"https.proxyHost\"</span>, <span class=\"string\">\"ip\"</span>);</span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"https.proxyPort\"</span>, <span class=\"string\">\"port\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 这行代码是身份验证的关键配置，不然身份验证不起作用</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"jdk.http.auth.tunneling.disabledSchemes\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 身份验证</span></span><br><span class=\"line\">Authenticator.setDefault(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Authenticator() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> PasswordAuthentication <span class=\"title\">getPasswordAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PasswordAuthentication(</span><br><span class=\"line\">                        <span class=\"string\">\"user\"</span>, <span class=\"string\">\"password\"</span>.toCharArray());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造HTTP请求</span></span><br><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"https://www.baidu.com\"</span>);</span><br><span class=\"line\">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br></pre></td></tr></table></figure><h3 id=\"局部设置\"><a href=\"#局部设置\" class=\"headerlink\" title=\"局部设置\"></a>局部设置</h3><p>针对某次请求来进行代理设置。<br></p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这行代码是身份验证的关键配置，不然身份验证不起作用</span></span><br><span class=\"line\">System.setProperty(<span class=\"string\">\"jdk.http.auth.tunneling.disabledSchemes\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 身份验证</span></span><br><span class=\"line\">Authenticator.setDefault(</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Authenticator() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> PasswordAuthentication <span class=\"title\">getPasswordAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PasswordAuthentication(</span><br><span class=\"line\">                        <span class=\"string\">\"user\"</span>, <span class=\"string\">\"password\"</span>.toCharArray());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 设置代理服务器</span></span><br><span class=\"line\">Proxy proxy = <span class=\"keyword\">new</span> Proxy(Proxy.Type.HTTP, <span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"ip\"</span>, port));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造HTTP请求</span></span><br><span class=\"line\">URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"https://www.baidu.com\"</span>);</span><br><span class=\"line\">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(proxy);</span><br></pre></td></tr></table></figure><p></p>","categories":["后端"],"tags":["java","http","proxy"]},{"title":"从JVM中dump出动态代理生成的class","url":"/2018/07/25/jvm-dump-class/","content":"<p>由于动态代理生成的 class 是直接以二进制的方式加载进内存中的，并没有对应的.class 文件生成，所以如果想通过反编译工具查看动态代理生成的代码需要通过特殊的手段来处理。</p><a id=\"more\"></a><h3 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h3><p>设置运行环境变量,运行后会把 class 文件生成在 classpath 目录下</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//动态代理时生成class文件</span><br><span class=\"line\">System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</span><br></pre></td></tr></table></figure><p>缺点是只适用于 JDK 动态代理</p><h3 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h3><p>使用 ClassDump,可以 dump 出 JVM 中所有已加载的 class。ClassDump 位于$JAVA_HOME/lib/sa-jdi.jar 中(注：windows 版本 JDK 从 1.7 开始才有此工具),直接以命令行执行。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看PID</span><br><span class=\"line\">E:\\work\\Test\\bin&gt;jps</span><br><span class=\"line\"></span><br><span class=\"line\">#缺省输出该PID下所有已加载的class文件至./目录</span><br><span class=\"line\">E:\\work\\Test\\bin&gt;java -classpath &quot;.;./bin;%JAVA_HOME%/lib/sa-jdi.jar&quot; sun.jvm.hotspot.tools.jcore.ClassDump &lt;PID&gt;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//导入sa-jdi.jar包，实现ClassFilter接口，只输出匹配的class文件</span><br><span class=\"line\">public class MyFilter implements ClassFilter&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@Override</span><br><span class=\"line\">\tpublic boolean canInclude(InstanceKlass arg0) &#123;</span><br><span class=\"line\">\t\treturn arg0.getName().asString().startsWith(&quot;com/sun/proxy/$Proxy0&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看PID</span><br><span class=\"line\">E:\\work\\Test\\bin&gt;jps</span><br><span class=\"line\"></span><br><span class=\"line\">#使用ClassFilter输出匹配的class文件，并指定输出目录</span><br><span class=\"line\">E:\\work\\Test\\bin&gt;java -classpath &quot;.;./bin;%JAVA_HOME%/lib/sa-jdi.jar&quot; -Dsun.jvm.hotspot.tools.jcore.filter=proxy.MyFilter -Dsun.jvm.hotspot.tools.jcore.outputDir=e:/dump sun.jvm.hotspot.tools.jcore.ClassDump &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>此方案基于 JVM 层的 ClassDump 所以可以支持 javassist、cglib、asm 动态生成的 class。</p><h3 id=\"最后贴下-JDK-动态代理反编译出来的代码\"><a href=\"#最后贴下-JDK-动态代理反编译出来的代码\" class=\"headerlink\" title=\"最后贴下 JDK 动态代理反编译出来的代码\"></a>最后贴下 JDK 动态代理反编译出来的代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.sun.proxy;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.lang.reflect.InvocationHandler;</span><br><span class=\"line\">import java.lang.reflect.Method;</span><br><span class=\"line\">import java.lang.reflect.Proxy;</span><br><span class=\"line\">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class=\"line\">import proxy.Run;\t//目标代理类接口</span><br><span class=\"line\"></span><br><span class=\"line\">//继承了Proxy类，实现目标代理类接口</span><br><span class=\"line\">public final class $Proxy0</span><br><span class=\"line\">  extends Proxy</span><br><span class=\"line\">  implements Run</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  private static Method m1;</span><br><span class=\"line\">  private static Method m3;</span><br><span class=\"line\">  private static Method m0;</span><br><span class=\"line\">  private static Method m2;</span><br><span class=\"line\"></span><br><span class=\"line\">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    super(paramInvocationHandler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  static</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class=\"line\">      //获取目标代理类的方法</span><br><span class=\"line\">      m3 = Class.forName(&quot;proxy.Run&quot;).getMethod(&quot;run&quot;, new Class[0]);</span><br><span class=\"line\">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class=\"line\">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class=\"line\">      return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //方法重写</span><br><span class=\"line\">  public final String run()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t  //this.h就是InvocationHandler的实现类了，调用invoke方法，在实现类里面做拦截处理</span><br><span class=\"line\">      return (String)this.h.invoke(this, m3, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Error|RuntimeException localError)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw localError;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public final boolean equals(Object paramObject)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Error|RuntimeException localError)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw localError;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public final String toString()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      return (String)this.h.invoke(this, m2, null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Error|RuntimeException localError)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw localError;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  public final int hashCode()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Error|RuntimeException localError)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw localError;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    catch (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"http://rednaxelafx.iteye.com/blog/727938\" target=\"_blank\" rel=\"noopener\">http://rednaxelafx.iteye.com/blog/727938</a></p>","categories":["后端"],"tags":["java","jvm","动态代理"]},{"title":"k8s通过coredns配置CNAME","url":"/2020/06/28/k8s-coredns-cname/","content":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在一次升级阿里云 k8s 版本之后暴露出来一个问题，一般在 k8s 集群中都会使用<code>service域名</code>来进行服务之间访问，但是为了在本地开发时能访问到这些服务，又会通过<code>ingress</code>暴露在外网中，这样在开发的时候就可以直接使用的<code>ingress</code>暴露的外网域名进行访问。</p><p>按理说本地开发环境的时候使用<code>外网域名</code>，在部署到 k8s 的时候应该使用 k8s 内部的<code>service域名</code>就什么事都没有了，然而在没有强约束的情况下很多项目<code>调用集群内部服务的时候还是使用的外网域名</code>，然而这样可能会导致服务调用失败，没想到吧。对此我们咨询了阿里云，给我们的回答是：<br><img src=\"/2020/06/28/k8s-coredns-cname/2020-06-28-14-26-36.png\" alt></p><p>好吧，按着提示把<code>externalTrafficPolicy</code>选项修改为<code>Cluster</code>，确实问题解决了，但是这样一改又把<code>源IP</code>丢失了，在后端服务中获取的<code>IP</code>都变成了<code>Node IP</code>，这肯定也不行。</p><a id=\"more\"></a><p>所以目前只有一种解决方案，就是把所有项目中通过<code>外网域名</code>访问内部服务的域名全部修改成 k8s 内部的<code>service域名</code>。</p><p>对此有两种实施方案：</p><ol><li>把所有项目都与对应的开发一一对接，然后通过环境变量将<code>外网域名</code>设置为<code>service域名</code>。</li><li>通过配置<code>coredns</code>，实现将外网域名<code>CNAME</code>到<code>service域名</code>上。</li></ol><p>方案一对于项目少的情况比较好实施，由于我们集群的服务比较多，施成本会非常高，所以还是去调研了方案二。</p><h3 id=\"coredns-配置\"><a href=\"#coredns-配置\" class=\"headerlink\" title=\"coredns 配置\"></a>coredns 配置</h3><p>在 coredns 官网查阅资料之后，得知可以使用<a href=\"https://coredns.io/plugins/rewrite/\" target=\"_blank\" rel=\"noopener\">rewrite</a>插件来实现<code>CNAME</code>，测试如下：</p><ul><li>配置<code>www.baidu.com</code> CNAME 到<code>www.taobao.com</code></li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">.:53 &#123;</span><br><span class=\"line\">    rewrite name www.baidu.com www.taobao.com</span><br><span class=\"line\">    forward . 114.114.114.114</span><br><span class=\"line\">    reload</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>效果</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dig @localhost www.baidu.com</span><br><span class=\"line\"></span><br><span class=\"line\">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.11-Ubuntu &lt;&lt;&gt;&gt; @localhost www.baidu.com</span><br><span class=\"line\">; (1 server found)</span><br><span class=\"line\">;; global options: +cmd</span><br><span class=\"line\">;; Got answer:</span><br><span class=\"line\">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 45042</span><br><span class=\"line\">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class=\"line\"></span><br><span class=\"line\">;; OPT PSEUDOSECTION:</span><br><span class=\"line\">; EDNS: version: 0, flags:; udp: 4096</span><br><span class=\"line\">;; QUESTION SECTION:</span><br><span class=\"line\">;www.baidu.com.                 IN      A</span><br><span class=\"line\"></span><br><span class=\"line\">;; ANSWER SECTION:</span><br><span class=\"line\">www.baidu.com.          364     IN      CNAME   www.taobao.com.danuoyi.tbcache.com.</span><br><span class=\"line\">www.baidu.com.          33      IN      A       113.96.109.101</span><br><span class=\"line\">www.baidu.com.          33      IN      A       113.96.109.100</span><br><span class=\"line\"></span><br><span class=\"line\">;; Query time: 39 msec</span><br><span class=\"line\">;; SERVER: 127.0.0.1#53(127.0.0.1)</span><br><span class=\"line\">;; WHEN: Sun Jun 28 14:47:34 CST 2020</span><br><span class=\"line\">;; MSG SIZE  rcvd: 161</span><br></pre></td></tr></table></figure><p>可以看到已经成功实现了。</p><h3 id=\"实施\"><a href=\"#实施\" class=\"headerlink\" title=\"实施\"></a>实施</h3><p>接着就是配置 k8s 集群中的<code>coredns</code>来实现目的了，<code>coredns</code>通过配置项<code>coredns</code>中 key 为<code>Corefile</code>的配置来挂载成<code>Corefile</code>，所以只需要修改该配置项即可。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.:53 &#123;</span><br><span class=\"line\">    cache 30</span><br><span class=\"line\">    errors</span><br><span class=\"line\">    health</span><br><span class=\"line\">    kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class=\"line\">        pods insecure</span><br><span class=\"line\">        fallthrough in-addr.arpa ip6.arpa</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rewrite name saas.test.xxx.cn backend-api.saas-test.svc.cluster.local</span><br><span class=\"line\">    loadbalance</span><br><span class=\"line\">    loop</span><br><span class=\"line\">    prometheus :9153</span><br><span class=\"line\">    forward . /etc/resolv.conf</span><br><span class=\"line\">    reload</span><br><span class=\"line\">    ready</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>注意第 9 行，<code>saas.test.xxx.cn</code>是一个外网域名，对应的 service 域名是<code>backend-api.saas-test.svc.cluster.local</code>，修改好之后等待一分钟左右，<code>coredns</code>的 reload 插件会自动进行热加载，然后进入 pod 中测试看看是否生效。</p><p><img src=\"/2020/06/28/k8s-coredns-cname/2020-06-28-14-58-49.png\" alt></p><p>可以看到<code>backend-api.saas-test.svc.cluster.local</code>解析出来的 ip 是<code>10.21.7.203</code>，<code>saas.test.xxx.cn</code>解析出来的 ip 也是<code>10.21.7.203</code>，这样的话在集群里通过外网域名请求其实也和直接访问 service 域名一致了。</p><p>接下来只需通过命令<code>kubectl get ingress --all-namespaces</code>把所有 ingress 暴露的外网域名和对应的 service 进行关联，并生成对应的配置加入<code>Corefile</code>中即可。</p>","categories":["DevOps"],"tags":["k8s","coredns"]},{"title":"Kubernetes之优雅停止pod","url":"/2019/07/11/k8s-graceful-shutdown/","content":"<p>每个<code>pod</code>代表一个集群中节点，在 k8s 做<code>rolling-update</code>的时候默认会向旧的<code>pod</code>发生一个<code>SIGTERM</code>信号，如果应用没有对<code>SIGTERM</code>信号做处理的话，会立即强制退出程序，这样的话会导致有些请求还没处理完，前端应用请求错误。</p><h3 id=\"滚动升级步骤\"><a href=\"#滚动升级步骤\" class=\"headerlink\" title=\"滚动升级步骤\"></a>滚动升级步骤</h3><p>先来回顾下 k8s 的滚动升级步骤：</p><ol><li>启动一个新的 pod</li><li>等待新的 pod 进入 Ready 状态</li><li>创建 Endpoint，将新的 pod 纳入负载均衡</li><li>移除与老 pod 相关的 Endpoint，并且将老 pod 状态设置为 Terminating，此时将不会有新的请求到达老 pod</li><li>给老 pod 发送 SIGTERM 信号，并且等待 terminationGracePeriodSeconds 这么长的时间。(默认为 30 秒)</li><li>超过 terminationGracePeriodSeconds 等待时间直接强制 kill 进程并关闭旧的 pod</li></ol><p>这里要注意，<code>SIGTERM信号如果进程没有处理的话也其实也就会导致进程被强杀</code>，如果处理了但是超过<code>terminationGracePeriodSeconds</code>配置的时间也一样会被强杀，所以这个时间可以根据具体的情况去设置。</p><a id=\"more\"></a><h3 id=\"SpringBoot-处理-SIGTERM-信号\"><a href=\"#SpringBoot-处理-SIGTERM-信号\" class=\"headerlink\" title=\"SpringBoot 处理 SIGTERM 信号\"></a>SpringBoot 处理 SIGTERM 信号</h3><p>在<code>SpringBoot</code>中处理 SIGTERM 信号非常简单，只需要一个<code>@PreDestroy</code>注解就可以监听到：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(Application<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">args</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"shutdown\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"通过容器生命周期-hook-来优雅停止\"><a href=\"#通过容器生命周期-hook-来优雅停止\" class=\"headerlink\" title=\"通过容器生命周期 hook 来优雅停止\"></a>通过容器生命周期 hook 来优雅停止</h3><p>在 pod 中容器将停止前，会执行<code>PreStop hook</code>，hook 可以执行一个<code>HTTP GET</code>请求或者<code>exec</code>命令，并且它们执行是阻塞的，可以利用这个特性来做优雅停止。</p><ul><li><p>调用<code>HTTP GET</code></p><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"lifecycle\": &#123;</span><br><span class=\"line\">    \"preStop\": &#123;</span><br><span class=\"line\">    \"httpGet\": &#123;</span><br><span class=\"line\">            \"path\": \"/shutdown\",</span><br><span class=\"line\">            \"port\": 3000,</span><br><span class=\"line\">            \"scheme\": \"HTTP\"</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用<code>exec</code></p><figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">\"lifecycle\": &#123;</span><br><span class=\"line\">    \"preStop\": &#123;</span><br><span class=\"line\">        \"exec\": &#123;</span><br><span class=\"line\">            \"command\": [\"/bin/sh\", \"-c\", \"sleep 30\"]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样的好处是可以在 k8s 层面来解决优雅停机的问题，而不需要应用程序对<code>SIGTERM</code>信号做处理。</p><h3 id=\"关于-PreStop-和-terminationGracePeriodSeconds\"><a href=\"#关于-PreStop-和-terminationGracePeriodSeconds\" class=\"headerlink\" title=\"关于 PreStop 和 terminationGracePeriodSeconds\"></a>关于 PreStop 和 terminationGracePeriodSeconds</h3><ol><li>如果有<code>PreStop hook</code>会执行<code>PreStop hook</code>。</li><li><code>PreStop hook</code>执行完成后会向 pod 发送<code>SIGTERM</code>信号。</li><li>如果在<code>terminationGracePeriodSeconds</code>时间限制内，<code>PreStop hook</code>没有执行完的话，一样会直接发送<code>SIGTERM</code>信号，并且时间延长 2 秒。</li></ol><p>即在有<code>PreStop hook</code>的情况下，也是在<code>terminationGracePeriodSeconds</code>时间限制内，在超过这个时间点之后，还会给出 2 秒进程处理<code>SIGTERM</code>信号的时间，最后直接强杀。</p><p>以上情况已经过 k8s 上验证过，参考：<a href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods\" target=\"_blank\" rel=\"noopener\">https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods</a></p>","categories":["DevOps"],"tags":["DevOps","k8s"]},{"title":"k8s正确的更新姿势","url":"/2019/09/16/k8s-update-operate/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>公司的 CI/CD 平台研发要告一个段落了，在此记录一下如何使用 k8s 的客户端工具 kubectl 来进行更新操作的。</p><h2 id=\"更新-Deployment\"><a href=\"#更新-Deployment\" class=\"headerlink\" title=\"更新 Deployment\"></a>更新 Deployment</h2><p>要知道 kubectl 是不支持 update 操作的，假设有如下<code>Deployment.yaml</code>需要进行部署：</p><a id=\"more\"></a><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">extensions/v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">test</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hello</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">hello</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">hello</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">hello</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> <span class=\"string\">Always</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">LOGGING_LEVEL</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> <span class=\"string\">\"INFO\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">test</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">hello</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">hello</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span></span><br><span class=\"line\">      <span class=\"attr\">port:</span> <span class=\"number\">80</span></span><br><span class=\"line\">      <span class=\"attr\">targetPort:</span> <span class=\"number\">80</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">ClusterIP</span></span><br></pre></td></tr></table></figure><p>只需要执行<code>kubectl apply -f Deployment.yaml</code>即可，可以理解为 createOrUpdate 操作。</p><h2 id=\"更新-Secret\"><a href=\"#更新-Secret\" class=\"headerlink\" title=\"更新 Secret\"></a>更新 Secret</h2><p>因为测试环境和预备环境的 HTTPS 证书是使用的<code>letsencrypt</code>的免费证书<br>，每过一段时间都需要续签一次生成新的证书相关文件，所以每次生成完都需要更新 k8s 中对应的 secret 信息。</p><p>执行以下命令：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">kubectl create secret tls hello \\</span><br><span class=\"line\">  --namespace test \\</span><br><span class=\"line\">  --key ./privkey.pem \\</span><br><span class=\"line\">  --cert ./fullchain.pem \\</span><br><span class=\"line\">  --dry-run \\</span><br><span class=\"line\">  -o yaml \\</span><br><span class=\"line\">  | \\</span><br><span class=\"line\">  kubectl apply -f -</span><br></pre></td></tr></table></figure><p>主要是<code>--dry-run</code>配合<code>-o yaml</code>生成对应的 yaml 文件，然后再使用<code>kubectl apply -f -</code>进行更新。</p><ul><li>–dry-run<br>表示不会发生实际的操作，也就是不会对 k8s 产生影响</li><li>kubectl apply -f -<br>表示拿到上一个管道的输入进行执行</li></ul>","categories":["DevOps"],"tags":["DevOps","k8s"]},{"title":"linux下的全局代理工具proxychain","url":"/2020/07/06/linux-global-proxy-tool-proxychain/","content":"<h2 id=\"proxychain-介绍\"><a href=\"#proxychain-介绍\" class=\"headerlink\" title=\"proxychain 介绍\"></a>proxychain 介绍</h2><blockquote><p>本文介绍的是<a href=\"https://github.com/rofl0r/proxychains-ng\" target=\"_blank\" rel=\"noopener\">proxychains-ng</a>项目</p></blockquote><p>在 linux 上运行一些命令的时候，经常访问到国外的网站，速度非常的慢，例如用<code>git</code>、<code>wget</code>等等，这个时候就可以通过<code>proxychain</code>工具来使用代理进行网络访问，使用教程如下：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">proxychains4 git <span class=\"built_in\">clone</span> git@github.com:rofl0r/proxychains-ng.git</span><br></pre></td></tr></table></figure><p>在所有要运行的命令行之前加上<code>proxychains4</code>就可以通过代理进行网络访问了。</p><a id=\"more\"></a><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h3><p>直接通过 apt 包管理工具就可以安装</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y proxychains4</span><br></pre></td></tr></table></figure><h3 id=\"源码构建\"><a href=\"#源码构建\" class=\"headerlink\" title=\"源码构建\"></a>源码构建</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:rofl0r/proxychains-ng.git</span><br><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br><span class=\"line\">sudo make install-config</span><br></pre></td></tr></table></figure><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>安装完之后可以找到<code>/etc/proxychains.conf</code>文件进行修改，一般请求下翻到最后一段修改代理服务器配置即可。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ProxyList]</span><br><span class=\"line\"># add proxy here ...</span><br><span class=\"line\"># meanwile</span><br><span class=\"line\"># defaults set to &quot;tor&quot;</span><br><span class=\"line\">socks5  192.168.56.1 1080</span><br></pre></td></tr></table></figure><p>这里我设置的 socks5 代理，还支持<code>http</code>、<code>socks4</code>协议的代理，示例：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#        Examples:</span><br><span class=\"line\">#</span><br><span class=\"line\">#               socks5  192.168.67.78   1080    lamer   secret</span><br><span class=\"line\">#               http    192.168.89.3    8080    justu   hidden</span><br><span class=\"line\">#               socks4  192.168.1.49    1080</span><br><span class=\"line\">#               http    192.168.39.93   8080</span><br></pre></td></tr></table></figure><p>当然以上内容在<code>/etc/proxychains.conf</code>中都可以看到。</p><h2 id=\"设置别名\"><a href=\"#设置别名\" class=\"headerlink\" title=\"设置别名\"></a>设置别名</h2><p><code>proxychains4</code>这个命令比较长不太好记，我通过<code>alias</code>给它设置了一个别名<code>pc</code>，修改<code>~/.profile</code>：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> pc=proxychains4</span><br></pre></td></tr></table></figure><p>刷新 profile</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.profile</span><br></pre></td></tr></table></figure><p>测试</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pc curl -I https://www.google.com</span><br><span class=\"line\">[proxychains] config file found: /etc/proxychains.conf</span><br><span class=\"line\">[proxychains] preloading /usr/lib/libproxychains4.so</span><br><span class=\"line\">[proxychains] DLL init: proxychains-ng 4.14-git-8-gb8fa2a7</span><br><span class=\"line\">[proxychains] Strict chain  ...  192.168.56.1:1080  ...  www.google.com:443  ...  OK</span><br><span class=\"line\">HTTP/2 200</span><br></pre></td></tr></table></figure><p>可以看到已经能够成功访问<code>google</code>了。</p>","categories":["linux"],"tags":["proxy"]},{"title":"maven下载指定依赖jar包","url":"/2019/07/25/maven-download-jar/","content":"<h2 id=\"命令格式\"><a href=\"#命令格式\" class=\"headerlink\" title=\"命令格式\"></a>命令格式</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn dependency:get -Dartifact=groupId:artifactId:version:jar:sources</span><br></pre></td></tr></table></figure><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul><li><p>下载jar包</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn dependency:get -Dartifact=junit:junit:4.12:jar</span><br></pre></td></tr></table></figure></li><li><p>下载源码</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn dependency:get -Dartifact=junit:junit:4.12:jar:sources</span><br></pre></td></tr></table></figure></li></ul>","categories":["后端"],"tags":["maven"]},{"title":"minikube安装","url":"/2019/11/15/minikube-install/","content":"<h2 id=\"minikube-介绍\"><a href=\"#minikube-介绍\" class=\"headerlink\" title=\"minikube 介绍\"></a>minikube 介绍</h2><p>minikube 是 k8s 官方维护的一个单机版的 k8s，通过 minikube 可以很方便的在本地机器上安装一套 k8s 环境用于日常的学习与开发。</p><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>环境: 虚拟机中的<code>centos:7</code>操作系统，其它情况可以参考<a href=\"https://minikube.sigs.k8s.io/docs/start/\" target=\"_blank\" rel=\"noopener\">官方文档</a>，主要步骤都是类似的。</p><a id=\"more\"></a><h3 id=\"kubectl-安装\"><a href=\"#kubectl-安装\" class=\"headerlink\" title=\"kubectl 安装\"></a>kubectl 安装</h3><p>首先需要先安装 kubectl，用于后续访问 minikube 的 k8s 集群。</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">配置源</span></span><br><span class=\"line\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class=\"line\">[kubernetes]</span><br><span class=\"line\">name=Kubernetes</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">使用阿里镜像</span></span><br><span class=\"line\">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">repo_gpgcheck=1</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">使用阿里镜像</span></span><br><span class=\"line\">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class=\"line\">EOF</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">安装kubectl</span></span><br><span class=\"line\">yum install -y kubectl</span><br></pre></td></tr></table></figure><h3 id=\"docker-配置国内镜像\"><a href=\"#docker-配置国内镜像\" class=\"headerlink\" title=\"docker 配置国内镜像\"></a>docker 配置国内镜像</h3><p>修改<code>daemon.json</code>文件，不存在可以创建一个</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>加入以下内容：</p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"registry-mirrors\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"https://dockerhub.azk8s.cn\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"https://reg-mirror.qiniu.com\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl daemon-reload</span><br><span class=\"line\">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id=\"minikube-安装\"><a href=\"#minikube-安装\" class=\"headerlink\" title=\"minikube 安装\"></a>minikube 安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \\</span><br><span class=\"line\">  &amp;&amp; chmod +x minikube</span><br></pre></td></tr></table></figure><p>由于墙的原因，可以去<a href=\"https://github.com/kubernetes/minikube/releases\" target=\"_blank\" rel=\"noopener\"><code>Github Releases</code></a>页面下载：<br><img src=\"/2019/11/15/minikube-install/2019-11-15-17-32-45.png\" alt></p><p>下载完之后直接通过命令行启动:</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">minikube start --vm-driver=none \\</span><br><span class=\"line\"> --image-mirror-country=cn \\</span><br><span class=\"line\"> --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure><blockquote><p>注：–vm-driver=none，是因为本身系统就是在虚拟机中运行的，所以不需要指定虚拟驱动，其它两个选项可以避免国内网络原因导致下载镜像失败。</p></blockquote><p>成功执行之后就可以用<code>kubectl</code>进行访问了。</p>","categories":["DevOps"],"tags":["k8s"]},{"title":"通过docker-compose快速搭建mongodb副本集","url":"/2020/03/10/mongodb-replica-set/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>mongoDB 提供的副本集是将数据同步至多个节点，提供了数据冗余备份和节点故障的情况下可以自动转移的高可用特性，架构图如下：<br><img src=\"/2020/03/10/mongodb-replica-set/2020-03-11-09-53-26.png\" alt></p><p>有时候需要要在本地搭建一套 mongoDB 副本集环境来做测试，如果用虚拟机的话还是比较麻烦的，这里记录下如何用 docker-compose 快速搭建 mongoDB 副本集。</p><a id=\"more\"></a><h2 id=\"构建镜像\"><a href=\"#构建镜像\" class=\"headerlink\" title=\"构建镜像\"></a>构建镜像</h2><ol><li>准备秘钥用于节点之间的认证</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl rand -base64 756 &gt; auth.key</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>编写 Dockerfile</li></ol><p>调整 mongo 官方提供的镜像，像里面添加秘钥文件</p><figure class=\"highlight docker\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> mongo:<span class=\"number\">3.4</span>.<span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"comment\">#将秘钥文件复制到镜像中</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> auth.key /app/auth.key</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> chown -R mongodb:mongodb /app/auth.key</span></span><br><span class=\"line\"><span class=\"comment\">#设置秘钥文件权限，这一步非常关键</span></span><br><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> chmod 600 /app/auth.key</span></span><br></pre></td></tr></table></figure><ol start=\"3\"><li>构建镜像</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker build -t mongo-replset .</span><br></pre></td></tr></table></figure><ol start=\"4\"><li>编写 docker-compose</li></ol><p>开启三个容器，组成一主两从的副本集集群，另外再开启一个容器监听和初始化副本集，这里我的实现方式并不优雅，就是一直重试直到前面三个 mongod 进程启动完成(官方有个<a href=\"https://docs.docker.com/compose/startup-order/\" target=\"_blank\" rel=\"noopener\">解决方案</a>来检测依赖服务的启动，不过有点麻烦这里就略过了)，启动完成之后执行副本集初始化命令：<code>mongo mongodb://root:123@mongo-1:27011/admin --eval &#39;rs.initiate({ _id: &quot;rs&quot;, members: [{_id:1,host:&quot;mongo-1:27011&quot;},{_id:2,host:&quot;mongo-2:27012&quot;},{_id:3,host:&quot;mongo-3:27013&quot;}]})&#39;</code></p><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">\"3.1\"</span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">mongo-1:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mongo-replset</span></span><br><span class=\"line\">    <span class=\"attr\">hostname:</span> <span class=\"string\">mongo-1</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">27011</span><span class=\"string\">:27011</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"attr\">MONGO_INITDB_ROOT_USERNAME:</span> <span class=\"string\">root</span></span><br><span class=\"line\">      <span class=\"attr\">MONGO_INITDB_ROOT_PASSWORD:</span> <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--port</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"27011\"</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--replSet</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">rs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--keyFile</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/auth.key</span></span><br><span class=\"line\">  <span class=\"attr\">mongo-2:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mongo-replset</span></span><br><span class=\"line\">    <span class=\"attr\">hostname:</span> <span class=\"string\">mongo-2</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">27012</span><span class=\"string\">:27012</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--port</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"27012\"</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--replSet</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">rs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--keyFile</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/auth.key</span></span><br><span class=\"line\">  <span class=\"attr\">mongo-3:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mongo-replset</span></span><br><span class=\"line\">    <span class=\"attr\">hostname:</span> <span class=\"string\">mongo-3</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">always</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"number\">27013</span><span class=\"string\">:27013</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--port</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"27013\"</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--replSet</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">rs</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--keyFile</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/app/auth.key</span></span><br><span class=\"line\">  <span class=\"attr\">mongo-init:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">mongo:3.4.10</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo-1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo-2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo-3</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">on-failure:5</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongo</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">mongodb://root:123@mongo-1:27011/admin</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">--eval</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">'rs.initiate(&#123; _id: \"rs\", members: [&#123;_id:1,host:\"mongo-1:27011\"&#125;,&#123;_id:2,host:\"mongo-2:27012\"&#125;,&#123;_id:3,host:\"mongo-3:27013\"&#125;]&#125;)'</span></span><br></pre></td></tr></table></figure><ol start=\"5\"><li>运行</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br><span class=\"line\">Creating mongo-replica_mongo-1_1 ... done</span><br><span class=\"line\">Creating mongo-replica_mongo-3_1 ... done</span><br><span class=\"line\">Creating mongo-replica_mongo-2_1 ... done</span><br><span class=\"line\">Creating mongo-replica_mongo-init_1 ... done</span><br></pre></td></tr></table></figure><ol start=\"6\"><li>查看副本集状态</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker-compose exec mongo-1 mongo mongodb://root:123@mongo-1:27011/admin --eval &apos;rs.status()&apos;</span><br><span class=\"line\">MongoDB shell version v3.4.10</span><br><span class=\"line\">connecting to: mongodb://root:123@mongo-1:27011/admin</span><br><span class=\"line\">MongoDB server version: 3.4.10</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        &quot;set&quot; : &quot;rs&quot;,</span><br><span class=\"line\">        &quot;date&quot; : ISODate(&quot;2020-03-10T07:01:59.764Z&quot;),</span><br><span class=\"line\">        &quot;myState&quot; : 1,</span><br><span class=\"line\">        &quot;term&quot; : NumberLong(1),</span><br><span class=\"line\">        &quot;heartbeatIntervalMillis&quot; : NumberLong(2000),</span><br><span class=\"line\">        &quot;optimes&quot; : &#123;</span><br><span class=\"line\">                &quot;lastCommittedOpTime&quot; : &#123;</span><br><span class=\"line\">                        &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                        &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;appliedOpTime&quot; : &#123;</span><br><span class=\"line\">                        &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                        &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;durableOpTime&quot; : &#123;</span><br><span class=\"line\">                        &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                        &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;members&quot; : [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        &quot;_id&quot; : 1,</span><br><span class=\"line\">                        &quot;name&quot; : &quot;mongo-1:27011&quot;,</span><br><span class=\"line\">                        &quot;health&quot; : 1,</span><br><span class=\"line\">                        &quot;state&quot; : 1,</span><br><span class=\"line\">                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,</span><br><span class=\"line\">                        &quot;uptime&quot; : 263,</span><br><span class=\"line\">                        &quot;optime&quot; : &#123;</span><br><span class=\"line\">                                &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                                &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        &quot;optimeDate&quot; : ISODate(&quot;2020-03-10T07:01:50Z&quot;),</span><br><span class=\"line\">                        &quot;electionTime&quot; : Timestamp(1583823469, 1),</span><br><span class=\"line\">                        &quot;electionDate&quot; : ISODate(&quot;2020-03-10T06:57:49Z&quot;),</span><br><span class=\"line\">                        &quot;configVersion&quot; : 1,</span><br><span class=\"line\">                        &quot;self&quot; : true</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        &quot;_id&quot; : 2,</span><br><span class=\"line\">                        &quot;name&quot; : &quot;mongo-2:27012&quot;,</span><br><span class=\"line\">                        &quot;health&quot; : 1,</span><br><span class=\"line\">                        &quot;state&quot; : 2,</span><br><span class=\"line\">                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class=\"line\">                        &quot;uptime&quot; : 261,</span><br><span class=\"line\">                        &quot;optime&quot; : &#123;</span><br><span class=\"line\">                                &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                                &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        &quot;optimeDurable&quot; : &#123;</span><br><span class=\"line\">                                &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                                &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        &quot;optimeDate&quot; : ISODate(&quot;2020-03-10T07:01:50Z&quot;),</span><br><span class=\"line\">                        &quot;optimeDurableDate&quot; : ISODate(&quot;2020-03-10T07:01:50Z&quot;),</span><br><span class=\"line\">                        &quot;lastHeartbeat&quot; : ISODate(&quot;2020-03-10T07:01:59.120Z&quot;),</span><br><span class=\"line\">                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2020-03-10T07:01:58.109Z&quot;),</span><br><span class=\"line\">                        &quot;pingMs&quot; : NumberLong(0),</span><br><span class=\"line\">                        &quot;syncingTo&quot; : &quot;mongo-1:27011&quot;,</span><br><span class=\"line\">                        &quot;configVersion&quot; : 1</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        &quot;_id&quot; : 3,</span><br><span class=\"line\">                        &quot;name&quot; : &quot;mongo-3:27013&quot;,</span><br><span class=\"line\">                        &quot;health&quot; : 1,</span><br><span class=\"line\">                        &quot;state&quot; : 2,</span><br><span class=\"line\">                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class=\"line\">                        &quot;uptime&quot; : 261,</span><br><span class=\"line\">                        &quot;optime&quot; : &#123;</span><br><span class=\"line\">                                &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                                &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        &quot;optimeDurable&quot; : &#123;</span><br><span class=\"line\">                                &quot;ts&quot; : Timestamp(1583823710, 1),</span><br><span class=\"line\">                                &quot;t&quot; : NumberLong(1)</span><br><span class=\"line\">                        &#125;,</span><br><span class=\"line\">                        &quot;optimeDate&quot; : ISODate(&quot;2020-03-10T07:01:50Z&quot;),</span><br><span class=\"line\">                        &quot;optimeDurableDate&quot; : ISODate(&quot;2020-03-10T07:01:50Z&quot;),</span><br><span class=\"line\">                        &quot;lastHeartbeat&quot; : ISODate(&quot;2020-03-10T07:01:59.120Z&quot;),</span><br><span class=\"line\">                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2020-03-10T07:01:58.103Z&quot;),</span><br><span class=\"line\">                        &quot;pingMs&quot; : NumberLong(0),</span><br><span class=\"line\">                        &quot;syncingTo&quot; : &quot;mongo-1:27011&quot;,</span><br><span class=\"line\">                        &quot;configVersion&quot; : 1</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;ok&quot; : 1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>使用 docker-compose 搭建的 mongodb 副本集就完成了，以后可以基于此快速搭建一套 mongodb 副本集环境进行测试。</p>","categories":["后端"],"tags":["docker","mongo","docker-compose"]},{"title":"Proxyee Down 3.0 正式版发布","url":"/2018/09/05/proxyee-down-3-0-guide/","content":"<p>在经历了近半年的时间之后，Proxyee Down 终于迎来了 3.0 版本,新版本改动非常的大同时进步也非常的大，来看看 3.0 版本的新特性吧。</p><h2 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h2><ol><li>UI 界面完全重构。</li><li>使用全新的<a href=\"https://github.com/proxyee-down-org/pdown-core\" target=\"_blank\" rel=\"noopener\">下载核心</a>，稳定性和下载速度全面提升，现在下载完的连接会去支持没下载完的连接，而不是和老版本一样下载完了就停止了。</li><li>去除老版本自带的百度云下载插件，新增扩展模块，在扩展商城里可以下载各种各样的扩展而不是仅限于百度云下载插件，支持第三方开发扩展(<a href=\"https://github.com/proxyee-down-org/proxyee-down-extension\" target=\"_blank\" rel=\"noopener\">参与开发</a>)。</li><li>加入限速功能，包括单任务限速和全局限速。</li><li>加入同时下载任务数设置功能。</li><li>启动速度大幅度提高</li><li>加入国际化支持(欢迎提交 PR)</li><li>文件夹选择器使用操作系统原生选择器，支持局域网共享文件夹、移动硬盘、U 盘。</li><li>移除老版本自带的百度云解压工具(之后会单独开发一款解压工具从下载器里独立出来)</li><li>mac 系统打包成原生 app 应用，而不是像之前一样用批处理文件启动。</li></ol><a id=\"more\"></a><h2 id=\"软件下载\"><a href=\"#软件下载\" class=\"headerlink\" title=\"软件下载\"></a>软件下载</h2><ul><li><a href=\"https://imhx-my.sharepoint.com/:f:/g/personal/pd_imhx_onmicrosoft_com/EnPrybHS3rVFuy_HdcP7RLoBwhb0k5ayJdIzwjU0hCM9-A?e=he0oIz\" target=\"_blank\" rel=\"noopener\">OneDrive 下载</a>(推荐)</li><li><a href=\"http://pdown.org/releases.html\" target=\"_blank\" rel=\"noopener\">官网下载</a>：<br>官网带宽比较低，建议用 OneDrive 下载</li></ul><h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><ul><li><strong>windows</strong>:<br>下载好 windows 版本的压缩包之后，解压至任意目录，会得到一个文件夹，执行文件夹里面的<code>Proxyee Down.exe</code>文件即可。<br>(<em>注：1.如果启动闪退，把 APP 复制到别的目录就可以正常运行。2.mac 系统切换代理和安装证书需要管理员权限，所以在启动时会提示输入密码</em>)<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-13-49-38.png\" alt></li><li><strong>mac</strong>:<br>下载好 mac 版本的压缩包之后，解压至任意目录，会得到一个<code>Proxyee Down</code>App，双击运行即可。<br>(<em>注：mac 系统切换代理和安装证书需要管理员权限，所以在启动时会提示输入密码</em>)<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-13-51-38.png\" alt></li><li><p><strong>linux</strong>:<br>linux 系统目前没有打原生包，要自行下载 jar 包运行，需安装 JRE 或 JDK(<em>要求版本不低于 1.8</em>)，下载完成后在命令行中运行：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -jar proxyee-down-main.jar</span><br></pre></td></tr></table></figure><p>(<em>注：如果使用 openjdk 的话需要安装 openjfx</em>)</p></li></ul><h2 id=\"任务模块\"><a href=\"#任务模块\" class=\"headerlink\" title=\"任务模块\"></a>任务模块</h2><p>用于管理下载任务，可以在此页面创建、查看、删除、暂停、恢复下载任务。</p><ul><li><strong>进阶</strong><ul><li><a href=\"https://github.com/proxyee-down-org/proxyee-down/blob/v2.5/.guide/common/create/read.md\" target=\"_blank\" rel=\"noopener\">自定义下载请求</a></li><li><a href=\"https://github.com/proxyee-down-org/proxyee-down/blob/v2.5/.guide/common/refresh/read.md\" target=\"_blank\" rel=\"noopener\">刷新任务下载链接</a></li></ul></li></ul><h2 id=\"扩展模块\"><a href=\"#扩展模块\" class=\"headerlink\" title=\"扩展模块\"></a>扩展模块</h2><p>在开启扩展模块时一定要手动安装一个由 Proxyee Down 随机生成的一个 CA 证书用于<code>HTTPS MITM</code>的支持。</p><ul><li><p><strong>安装证书</strong></p><p>进入扩展页面，如果软件检测到没有安装 Proxyee Down CA 证书时，会有对应的安装提示，接受的话点击安装按照系统指引即可安装完毕。<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-14-08-36.png\" alt=\"安装证书\"></p></li><li><p><strong>扩展商店</strong></p><p>安装完证书后会进入扩展商店页面，目前扩展商店只有一款百度云下载扩展，以后会陆续开发更多的扩展(<em>例如：各大网站的视频下载扩展、其他网盘的下载扩展等等</em>)。<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-14-12-21.png\" alt=\"扩展商城\"></p></li><li><p><strong>扩展安装</strong></p><p>在操作栏找到安装按钮，点击安装即可安装扩展。<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-14-26-44.png\" alt></p></li><li><p><strong>全局代理</strong></p><p>全局代理默认是不开启的，开启 Proxyee Down 会根据启用的扩展进行对应的系统代理设置，可能会与相同机制的软件发生冲突(<em>例如：SS、SSR</em>)。<br>如果不使用全局代理，可以点击<code>复制PAC链接</code>，配合<a href=\"https://www.switchyomega.com/\" target=\"_blank\" rel=\"noopener\">SwitchyOmega 插件</a>来使用。</p></li><li><p><strong>其他相关</strong></p><ul><li><p><strong>SwitchyOmega 设置教程</strong></p><ol><li>新建情景模式，选择 PAC 情景模式类型。<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-14-25-34.png\" alt></li><li>把复制的 PAC 链接粘贴进来并点击立即更新情景模式然后保存。<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-14-30-30.png\" alt></li><li>切换情景模式进行下载<br><img src=\"/2018/09/05/proxyee-down-3-0-guide/2018-09-05-14-32-00.png\" alt></li></ol></li><li><p><strong>参与扩展开发</strong><br>详见<a href=\"https://github.com/proxyee-down-org/proxyee-down-extension\" target=\"_blank\" rel=\"noopener\">proxyee-down-extension</a></p></li><li><p><strong>扩展实现原理</strong><br>扩展功能是由 MITM(中间人攻击)技术实现的，使用<a href=\"https://github.com/monkeyWie/proxyee\" target=\"_blank\" rel=\"noopener\">proxyee</a>框架拦截和修改<code>HTTP</code>、<code>HTTPS</code>的请求和响应报文，从而实现对应的扩展脚本注入。</p></li></ul></li></ul><h2 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h2><p>谢谢一直以来大家对本软件的支持和认可，相信在你们的反馈和支持下本软件会做的越来越好！</p>","categories":["杂谈"],"tags":["proxyee-down"]},{"title":"发布jar包到maven中央仓库","url":"/2018/07/23/publish-jar-to-maven/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>我们知道在 maven 中引入第三方 jar 包是非常简单的，只需要使用 groupId+artifactId+version 就能从 maven 仓库中下载下来对应的 jar 包。</p><blockquote><p>例如：引入 fastjson 的 jar 包</p></blockquote><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;1.2.46&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>那如果想要发布自己的 jar 包到 maven 仓库应该如何操作呢。</p><a id=\"more\"></a><h2 id=\"创建-issue\"><a href=\"#创建-issue\" class=\"headerlink\" title=\"创建 issue\"></a>创建 issue</h2><p>要发布 jar 包到 maven 仓库首先需要人工审核，在审核过了的话才可以进行后续发布 jar 包的操作。首先需要在<a href=\"https://issues.sonatype.org/secure/Dashboard.jspa\" target=\"_blank\" rel=\"noopener\">https://issues.sonatype.org/secure/Dashboard.jspa</a>上注册一个账号，登录之后点击<strong>Create</strong>,在弹出来的界面中填写响应的信息</p><blockquote><p><img src=\"/2018/07/23/publish-jar-to-maven/1532326564463.png\" alt=\"Create issue\"></p><ul><li>Project 选择 Community Support，Issue type 选择 New Project。</li><li>注意 Group Id，如果有对应域名的话则使用域名对应的 Group Id(例如 netty 项目的域名是 netty.io，则 Group Id 为 io.netty)，没有的域名的话最好就填<strong>com.github.xxx</strong>，因为在 issue 里会有人问你是否拥有 Group Id 对应的域名，没有的话是审核不过的，而托管在 github 上的话就可以直接使用 github 的域名来完成审核。</li></ul></blockquote><h2 id=\"issue-审核\"><a href=\"#issue-审核\" class=\"headerlink\" title=\"issue 审核\"></a>issue 审核</h2><p>创建成功后等 1-2 个小时左右就会有工作人员评论 issue，问你是否持有域名。</p><blockquote><p><img src=\"/2018/07/23/publish-jar-to-maven/1532332576577.png\" alt></p></blockquote><p>如果是用<strong>com.github.xxx</strong>的 Group Id，就回复要使用<strong>com.github.xxx</strong>作为你的域名，否则有域名就回复有就好,接着等待工作人员确认(我等了一天)，确认成功之后 issue 的状态就会变成<code>RESOLVED</code>，这个时候就有资格上传 jar 包到 maven 仓库了。</p><h2 id=\"gpg-管理密钥\"><a href=\"#gpg-管理密钥\" class=\"headerlink\" title=\"gpg 管理密钥\"></a>gpg 管理密钥</h2><p>在上传 jar 包之前，先要生成 gpg 工具生成 RSA 密钥对，并把公钥上传到公共密钥服务器，这样在发布 jar 包的时候能校验用户的身份。</p><ol><li>下载 gpg 工具，下载地址：<a href=\"https://www.gnupg.org/download/index.html\" target=\"_blank\" rel=\"noopener\">https://www.gnupg.org/download/index.html</a>，下载对应操作系统的版本然后进行安装。</li><li>验证安装和上传生成的公钥</li></ol><ul><li><p>验证 gpg 是否安装成功</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --version</span><br></pre></td></tr></table></figure></li><li><p>生成 RAS 密钥对</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --gen-key</span><br></pre></td></tr></table></figure><p>接着需要填写名字和邮箱等等基本信息，这些都不是重点，最主要的是有个<code>Passphase</code>的选项在填完之后记下来，到时候发布 jar 包的时候要用到。</p></li><li><p>查看生成的密钥，并上传至密钥服务器<br>需要上传到服务器的就是 pub 里的公钥串<code>FC27E7C61FC5D176DD7F67198C6EFA8E944CD6BA</code>。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --list-keys</span><br></pre></td></tr></table></figure><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">pub   rsa2048 2018-07-19 [SC] [expires: 2020-07-18]</span><br><span class=\"line\">      FC27E7C61FC5D176DD7F67198C6EFA8E944CD6BA</span><br><span class=\"line\">uid           [ultimate] liwei &lt;liwei2633@163.com&gt;</span><br><span class=\"line\">sub   rsa2048 2018-07-19 [E] [expires: 2020-07-18]</span><br></pre></td></tr></table></figure><p>上传公钥至密钥服务器，国内我测试了的服务器基本就这个<code>hkp://keyserver.ubuntu.com:11371</code>能用。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --keyserver hkp://keyserver.ubuntu.com:11371 --send-keys FC27E7C61FC5D176DD7F67198C6EFA8E944CD6BA</span><br></pre></td></tr></table></figure><p>上传完后验证是否成功</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg --keyserver hkp://keyserver.ubuntu.com:11371 --receive-keys FC27E7C61FC5D176DD7F67198C6EFA8E944CD6BA</span><br></pre></td></tr></table></figure><p>验证成功</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">gpg: Total number processed: 1</span><br><span class=\"line\">gpg:              unchanged: 1</span><br></pre></td></tr></table></figure></li></ul><h2 id=\"maven-配置\"><a href=\"#maven-配置\" class=\"headerlink\" title=\"maven 配置\"></a>maven 配置</h2><ol><li>修改项目中的<code>pom.xml</code>文件，添加部署相关配置，这里引用贴下我的配置，只需要替换下相应的内容就好。</li></ol><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>pdown-core<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>HTTP high speed downloader<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://github.com/proxyee-down-org/pdown-core<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">licenses</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">license</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>The MIT License (MIT)<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://opensource.org/licenses/mit-license.php<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">license</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">licenses</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">developers</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">developer</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>monkeyWie<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">email</span>&gt;</span>liwei2633@163.com<span class=\"tag\">&lt;/<span class=\"name\">email</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">developer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">developers</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">scm</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">connection</span>&gt;</span>scm:git:https://github.com/proxyee-down-org/pdown-core.git<span class=\"tag\">&lt;/<span class=\"name\">connection</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">developerConnection</span>&gt;</span>scm:git:https://github.com/proxyee-down-org/pdown-core.git<span class=\"tag\">&lt;/<span class=\"name\">developerConnection</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://github.com/proxyee-down-org/pdown-core<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">scm</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>release<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--Compiler--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Source --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar-no-fork<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- Javadoc --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-javadoc-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- GPG mvn clean deploy -P release -Dgpg.passphrase=YourPassphase--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-gpg-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>sign-artifacts<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>verify<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>sign<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>releases<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://oss.sonatype.org/service/local/staging/deploy/maven2/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>snapshots<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start=\"2\"><li>把之前创建 issue 时注册的账号配置到 maven 的配置文件里，找到 maven 安装目录下<code>conf/setting.xml</code>文件，在<code>&lt;servers&gt;</code>标签里添加。</li></ol><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>releases<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>snapshots<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把用户名和密码填好即可。</p><h2 id=\"部署-jar-包\"><a href=\"#部署-jar-包\" class=\"headerlink\" title=\"部署 jar 包\"></a>部署 jar 包</h2><ol><li>使用下面的命令行，会需要输入之前用 gpg 生成密钥时输入的 Passphase，也有可能会弹窗出来提示输入 Passphase。<br>(<em>我这加了-Dgpg.passphrase=YourPassphase 选项并没有生效，还是会弹窗出来提示输入 Passphase</em>)</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn clean deploy -P release -Dgpg.passphrase=YourPassphase</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>如果部署成功的话使用创建 issue 的帐号登录这个网址<a href=\"https://oss.sonatype.org/\" target=\"_blank\" rel=\"noopener\">https://oss.sonatype.org/</a>，然后看图操作。<br><img src=\"/2018/07/23/publish-jar-to-maven/1532339455164.png\" alt></li><li>close 完了系统会验证 jar 包，点击刷新可以看到最新的进度，当全部验证通过的时候，状态会变成<code>closed</code>,然后再选中文件<code>Release</code>就发布完成了。然后等个几个小时就可以在中央仓库搜索到自己发布的 jar 包了。<br><img src=\"/2018/07/23/publish-jar-to-maven/1532339866124.png\" alt></li></ol>","categories":["后端"],"tags":["java","maven","deploy"]},{"title":"IDEA搭建scala开发环境","url":"/2020/04/14/setup-scala-on-idea/","content":"<h3 id=\"环境信息\"><a href=\"#环境信息\" class=\"headerlink\" title=\"环境信息\"></a>环境信息</h3><ul><li>windows 10</li><li>IDEA 2019.3</li></ul><p>不用下载<code>scala</code>和<code>sbt</code>，直接使用 IDEA 插件中自带的就行。</p><a id=\"more\"></a><h3 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h3><ol><li>IDEA 安装<code>scala</code>插件<br><img src=\"/2020/04/14/setup-scala-on-idea/2020-04-14-15-53-21.png\" alt><br>国内网络环境安装可能比较慢，如果失败的话可以通过<code>设置代理</code>或者<a href=\"https://plugins.jetbrains.com/plugin/1347-scala/versions\" target=\"_blank\" rel=\"noopener\">离线下载</a>的方式安装。</li><li><p>设置<code>sbt</code>环境<br>这一步是因为国内访问 sbt 仓库太慢，需要配置国内加速镜像。</p><p>在<code>~/.sbt</code>目录下创建<code>repositories</code>文件，内容如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[repositories]</span><br><span class=\"line\">local</span><br><span class=\"line\">nexus-aliyun:https://maven.aliyun.com/nexus/content/groups/public</span><br><span class=\"line\">huaweicloud-maven: https://repo.huaweicloud.com/repository/maven/</span><br><span class=\"line\">maven-central: https://repo1.maven.org/maven2/</span><br><span class=\"line\">sbt-plugin-repo: https://repo.scala-sbt.org/scalasbt/sbt-plugin-releases, [organization]/[module]/(scala_[scalaVersion]/)(sbt_[sbtVersion]/)[revision]/[type]s/[artifact](-[classifier]).[ext]</span><br></pre></td></tr></table></figure><p>在 IDEA 设置中搜索<code>sbt</code>，然后修改<code>VM parameters</code>，填入以下内容：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Dsbt.override.build.repos=true</span><br><span class=\"line\">-Dsbt.repository.config=$&#123;用户目录&#125;\\.sbt\\repositories</span><br></pre></td></tr></table></figure><p><img src=\"/2020/04/14/setup-scala-on-idea/2020-04-14-16-05-25.png\" alt></p><p>设置完毕就可以畅快使用<code>sbt</code>了。</p></li><li><p>创建项目<br>IDEA 创建项目时选择<code>scala</code>+<code>sbt</code><br><img src=\"/2020/04/14/setup-scala-on-idea/2020-04-14-16-08-26.png\" alt></p><p>点击<code>Next</code>到下一步，选择对应的<code>sbt</code>和<code>scala</code>版本<br><img src=\"/2020/04/14/setup-scala-on-idea/2020-04-14-16-20-25.png\" alt></p><p>然后一直等到<code>sync finished</code>就可以了<br><img src=\"/2020/04/14/setup-scala-on-idea/2020-04-14-16-21-33.png\" alt></p></li></ol>","categories":["后端"],"tags":["scala","sbt","IDEA"]},{"title":"spark应用调试","url":"/2020/04/17/spark-application-debug/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>平常开发 spark 应用的时候，为了快速验证程序是否正确一般都会设置<code>master</code>为<code>local</code>模式来运行，但是如果想用集群环境来运行的话，就需要打一个 jar 包用<code>spark-submit</code>进行任务提交，但是在开发过程中频繁打 jar 包提交也是一件麻烦事，查阅相关资料之后发现其实可以在本地运行代码的时候指定集群环境来运行，达到快速调试的目的。</p><a id=\"more\"></a><h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>每次运行之前还是需要打一个 jar 包，如果有引入 spark 之外的依赖，需要把依赖也打进去，否则会报<code>ClassNotFound</code>.</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sbt package</span><br></pre></td></tr></table></figure><h2 id=\"spark-standalone-集群\"><a href=\"#spark-standalone-集群\" class=\"headerlink\" title=\"spark standalone 集群\"></a>spark standalone 集群</h2><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>()</span><br><span class=\"line\">      .setAppName(<span class=\"string\">\"test\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//指定spark master地址</span></span><br><span class=\"line\">      .setMaster(<span class=\"string\">\"spark://master:7077\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//指定本地jar包路径</span></span><br><span class=\"line\">      .setJars(<span class=\"type\">List</span>(<span class=\"string\">\"file:///E:/code/study/scala/spark-demo/target/scala-2.11/spark-demo_2.11-0.1.jar\"</span>))</span><br><span class=\"line\">      <span class=\"comment\">//指定本机IP为driver</span></span><br><span class=\"line\">      .setIfMissing(<span class=\"string\">\"spark.driver.host\"</span>, <span class=\"string\">\"192.168.102.142\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">val</span> spark = <span class=\"type\">SparkSession</span>.builder()</span><br><span class=\"line\">    .config(conf)</span><br><span class=\"line\">    .getOrCreate()</span><br></pre></td></tr></table></figure><p>这样在直接运行代码就可以直接运行在指定的 spark 集群环境上了。</p><h2 id=\"spark-on-yarn-集群\"><a href=\"#spark-on-yarn-集群\" class=\"headerlink\" title=\"spark on yarn 集群\"></a>spark on yarn 集群</h2><p>这种集群方式稍微有点麻烦，需要先手动把 spark 中的 jar 包上传到 hdfs 中，然后指定 yarn 运行环境的 spark jars 路径。</p><ol><li><p>上传 jar 包至 hdfs<br>把集群中<code>${SPARK_HOME}/jars</code>目录下的所有文件上传到 hdfs 中</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hadoop fs -put ./jars/* /user/spark/share/lib/2.4.5/</span><br></pre></td></tr></table></figure><p><code>注：如果是使用的cdh安装的spark集群，不能使用cdh中的spark目录下的jar包，因为cdh和apache官方提供的jar包不一致，而开发的时候引入的依赖一般都是apache提供的jar包，这样运行的时候会报错，需要自行从apache官网下载对应的spark发行包然后进行上传，总而言之待上传的spark环境需要和本地开发环境保持一致即可。</code></p></li><li><p>编写代码</p></li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">val conf = new SparkConf()</span><br><span class=\"line\">      .setAppName(&quot;test&quot;)</span><br><span class=\"line\">      //设置为yarn模式提交</span><br><span class=\"line\">      .setMaster(&quot;yarn&quot;)</span><br><span class=\"line\">      //设置yarn域名(必需，不然job状态一直ACCEPTED)</span><br><span class=\"line\">      .set(&quot;spark.hadoop.yarn.resourcemanager.hostname&quot;, &quot;master&quot;)</span><br><span class=\"line\">      //设置yarn提交地址</span><br><span class=\"line\">      .set(&quot;spark.hadoop.yarn.resourcemanager.address&quot;, &quot;master:8032&quot;)</span><br><span class=\"line\">      //设置stagingDir，用于存放任务运行时的临时文件</span><br><span class=\"line\">      .set(&quot;spark.yarn.stagingDir&quot;, &quot;hdfs://master:8020/user/root/spark/test&quot;)</span><br><span class=\"line\">      //设置yarn jars，填入上一步上传的hdfs地址</span><br><span class=\"line\">      .set(&quot;spark.yarn.jars&quot;, &quot;hdfs://master:8020/user/spark/share/lib/2.4.5/*.jar&quot;)</span><br><span class=\"line\">      //设置本地jar包地址</span><br><span class=\"line\">      .setJars(List(&quot;file:///E:/code/study/scala/spark-demo/target/scala-2.11/spark-demo_2.11-0.1.jar&quot;))</span><br><span class=\"line\">      //指定本机IP为driver</span><br><span class=\"line\">      .setIfMissing(&quot;spark.driver.host&quot;, &quot;192.168.102.142&quot;)</span><br><span class=\"line\">val spark = SparkSession.builder()</span><br><span class=\"line\">    .config(conf)</span><br><span class=\"line\">    .getOrCreate()</span><br></pre></td></tr></table></figure><h2 id=\"关于-setJars\"><a href=\"#关于-setJars\" class=\"headerlink\" title=\"关于 setJars\"></a>关于 setJars</h2><p>前面说了每次运行之前都需要重新构建一次 jar 包，但其实也不一定，这个 jar 包的作用是为了能将参与 spark 运算的<code>匿名函数</code>的反序列化。</p><p>所以在没有修改<code>运算逻辑</code>的时候，可以不需要重新构建 jar 包，举个例子来证明：</p><ol><li>第一次代码如下：</li></ol><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">spark.sparkContext</span><br><span class=\"line\">      .parallelize(<span class=\"type\">List</span>(<span class=\"string\">\"hello word\"</span>, <span class=\"string\">\"test word\"</span>, <span class=\"string\">\"hello haha\"</span>, <span class=\"string\">\"ok\"</span>))</span><br><span class=\"line\">      .flatMap(_.split(<span class=\"string\">\" \"</span>))</span><br><span class=\"line\">      .map((_, <span class=\"number\">1</span>))</span><br><span class=\"line\">      .take(<span class=\"number\">10</span>)</span><br><span class=\"line\">      .foreach(kv =&gt; println(kv._1 + <span class=\"string\">\":\"</span> + kv._2))</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>构建 jar 包</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sbt package</span><br></pre></td></tr></table></figure><ol start=\"3\"><li>运行代码</li></ol><p>输出结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">test:1</span><br><span class=\"line\">ok:1</span><br><span class=\"line\">haha:1</span><br><span class=\"line\">hello:2</span><br><span class=\"line\">word:2</span><br></pre></td></tr></table></figure><ol start=\"4\"><li>修改代码，把数据改一改</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">spark.sparkContext</span><br><span class=\"line\">      .parallelize(List(&quot;hello scala&quot;, &quot;test scala&quot;, &quot;hello haha&quot;, &quot;ok&quot;))</span><br><span class=\"line\">      .flatMap(_.split(&quot; &quot;))</span><br><span class=\"line\">      .map((_, 1))</span><br><span class=\"line\">      .countByKey()</span><br><span class=\"line\">      .take(10)</span><br><span class=\"line\">      .foreach(kv =&gt; println(kv._1 + &quot;:&quot; + kv._2))</span><br></pre></td></tr></table></figure><ol start=\"5\"><li>不重新构建 jar 包，直接运行</li></ol><p>结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">test:1</span><br><span class=\"line\">scala:2</span><br><span class=\"line\">ok:1</span><br><span class=\"line\">haha:1</span><br><span class=\"line\">hello:2</span><br></pre></td></tr></table></figure><p>可以发现没有重新构建 jar 包，结果也边了，说明是运行的刚刚修改的代码。</p><ol start=\"6\"><li>修改算子运行</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">spark.sparkContext</span><br><span class=\"line\">      .parallelize(List(&quot;hello scala&quot;, &quot;test scala&quot;, &quot;hello haha&quot;, &quot;ok&quot;))</span><br><span class=\"line\">      .flatMap(_.split(&quot; &quot;))</span><br><span class=\"line\">      .map((_, 2)) //注意这里从1改成了2</span><br><span class=\"line\">      .countByKey()</span><br><span class=\"line\">      .take(10)</span><br><span class=\"line\">      .foreach(kv =&gt; println(kv._1 + &quot;:&quot; + kv._2))</span><br></pre></td></tr></table></figure><p>不重新构建 jar 包，直接运行，结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">test:1</span><br><span class=\"line\">scala:2</span><br><span class=\"line\">ok:1</span><br><span class=\"line\">haha:1</span><br><span class=\"line\">hello:2</span><br></pre></td></tr></table></figure><p>计算结果和之前的一样，没有发生变化，说明在计算的时候，节点是以 jar 中编译好的 class 进行计算。</p><ol start=\"7\"><li>继续测试</li></ol><p>修改代码如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">spark.sparkContext</span><br><span class=\"line\">      .parallelize(List(&quot;hello scala&quot;, &quot;test scala&quot;, &quot;hello haha&quot;, &quot;ok&quot;))</span><br><span class=\"line\">      .flatMap(_.split(&quot; &quot;))</span><br><span class=\"line\">      .map((_, 2))</span><br><span class=\"line\">      .countByKey()</span><br><span class=\"line\">      .take(10)</span><br><span class=\"line\">      .foreach(kv =&gt; println(kv._1 + &quot;=&quot; + kv._2)) //注意这里将:换成了=</span><br></pre></td></tr></table></figure><p>直接运行，结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">test=1</span><br><span class=\"line\">scala=2</span><br><span class=\"line\">ok=1</span><br><span class=\"line\">haha=1</span><br><span class=\"line\">hello=2</span><br></pre></td></tr></table></figure><p>可以看到结果发生变化了，同样是匿名函数的实现修改，为什么这里又可以直接生效呢，接着往下。</p><h2 id=\"setJars-原理\"><a href=\"#setJars-原理\" class=\"headerlink\" title=\"setJars 原理\"></a>setJars 原理</h2><p>通过上面的示例，可以指定在这个例子中 spark 从 jar 包里主要拿到下面两个<code>匿名函数</code>反序列化之后的类</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.flatMap(_.split(&quot; &quot;))</span><br><span class=\"line\">.map((_, 1))</span><br></pre></td></tr></table></figure><p>把 jar 包打开看一看，里面有三个内部类，分别对应代码中的三个<code>匿名函数</code><br><img src=\"/2020/04/17/spark-application-debug/2020-04-17-17-29-04.png\" alt></p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//main$1.class</span><br><span class=\"line\">.flatMap(_.split(&quot; &quot;))</span><br><span class=\"line\">//main$2.class</span><br><span class=\"line\">.map((_, 1))</span><br><span class=\"line\">//main$3.class</span><br><span class=\"line\">.foreach(kv =&gt; println(kv._1 + &quot;:&quot; + kv._2))</span><br></pre></td></tr></table></figure><p>在将 rdd 分发到各个计算节点时，都是通过 jar 包中的 class 来<code>反序列化</code>出对应的<code>匿名函数</code>，所以在没有重新构建 jar 包的情况下修改代码不会生效，但是由于<code>.foreach(kv =&gt; println(kv._1 + &quot;:&quot; + kv._2))</code>在<code>take()</code>方法之后调用，take 这个方法是将计算结果取回到<code>driver</code>中，是使用本地运行时编译的 class，所以这里代码修改的话不需要重新构建 jar 也能及时生效。</p><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>本来只是想要通过代码直接提交任务至 spark 集群环境，却意外研究了<code>setJars</code>相关的知识，让我对 spark 计算过程有了更深刻的了解，甚是美哉。</p><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://stackoverflow.com/a/52164371/8129004\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/a/52164371/8129004</a></p>","categories":["大数据"],"tags":["spark"]},{"title":"设计一种无状态的验证码","url":"/2020/03/26/stateless-captcha/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>通常验证码都是通过<code>session</code>来实现，在服务端生成一个随机字符串作为验证码，将该字符串存到<code>session</code>中，然后将验证码图片渲染到前端，前端提交之后通过<code>session</code>中存放的正确验证码进行对比从而验证输入的正确性。</p><p>上面是一个典型的验证码实现的流程，但是这种方案存在非常多的弊端，例如：</p><ol><li>分布式应用：大家知道<code>session</code>是有状态的，当服务器存在多个时，需要去处理<code>session</code>丢失的问题。</li><li>跨域问题：现在前后端分离大行其道，<code>cookie</code>跨域问题会导致<code>session id</code>无法正确传递，需要去处理<code>cookie</code>跨域的问题。</li><li>开销问题：维护<code>session</code>需要消耗一定服务器的资源。</li></ol><a id=\"more\"></a><h2 id=\"无状态验证码\"><a href=\"#无状态验证码\" class=\"headerlink\" title=\"无状态验证码\"></a>无状态验证码</h2><p>为了解决上面的问题，我想了一个解决方案，核心思想是将<code>真实的验证码字符串</code>存储在前端，当然是经过<code>加密</code>的字符串，流程图如下：</p><p><img src=\"/2020/03/26/stateless-captcha/2020-03-26-11-49-02.png\" alt></p><ol><li>首先前端通过接口获取一个<code>token</code></li><li>服务端生成<code>随机字符串</code>并通过<code>AES</code>加密，<code>AES KEY</code>放在服务器保证加密解密是安全的</li><li>客户端通过<code>token</code>访问一个验证码图片</li><li>服务器通过<code>AES</code>解密拿到之前生成的<code>随机字符串</code>，然后将字符串渲染成图片返回</li></ol><p>至此前端已经得到了一个<code>token</code>和一个<code>验证码图片</code>，后续的流程图如下：<br><img src=\"/2020/03/26/stateless-captcha/2020-03-26-11-54-43.png\" alt></p><ol><li>前端发起登录请求，将<code>token</code>和用户输入的<code>验证码</code>一起发送到后端。</li><li>服务器通过<code>AES</code>解密拿到之前生成的<code>随机字符串</code>，再和用户输入的<code>验证码</code>做对比校验</li></ol><p>这样就实现了一个无状态的验证码。</p><h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><p>上面的验证码存在<code>重放攻击</code>的风险，即记录一次正确的<code>token</code>和<code>输入的验证码</code>，这样就可以一直使用，以此绕过验证码校验。对此可以在<code>token</code>中加入<code>过期时间</code>属性，这样<code>token</code>中其实包含了加密后的<code>正确验证码</code>和<code>过期时间</code>，在经过服务器时，首先通过时间检验，这样就可以大大的避免<code>重放攻击</code>的风险。</p><h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>这里后端主要是用<code>springboot</code>+<code>hutool</code>来实现，<code>hutool</code>用于验证码图片的渲染。</p><ul><li>后端</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ApiOperation</span>(value = <span class=\"string\">\"获取验证码token\"</span>, httpMethod = <span class=\"string\">\"GET\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"captcha\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;String&gt; <span class=\"title\">getCaptcha</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机生成4位字符串</span></span><br><span class=\"line\">    String code = RandomUtil.randomString(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 封装字符串和过期时间</span></span><br><span class=\"line\">    CaptchaDTO dto = <span class=\"keyword\">new</span> CaptchaDTO();</span><br><span class=\"line\">    dto.setCode(code);</span><br><span class=\"line\">    <span class=\"comment\">// 过期时间为一分钟</span></span><br><span class=\"line\">    dto.setExp(System.currentTimeMillis() + TimeUnit.MINUTES.toMillis(<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// CAPTCHA_AES_KEY为AES加密中用到的key，存储在服务器中</span></span><br><span class=\"line\">    <span class=\"comment\">// 将dto对象转化成json字符串，再通过aes加密</span></span><br><span class=\"line\">    <span class=\"comment\">// token=aes(key,JSON.toString(dto))</span></span><br><span class=\"line\">    String token = SecureUtil.aes(Base64.getDecoder().decode(CAPTCHA_AES_KEY)).encryptBase64(JSON.toJSONString(dto));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result&lt;&gt;(token);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ApiOperation</span>(value = <span class=\"string\">\"渲染验证码\"</span>, httpMethod = <span class=\"string\">\"GET\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"captcha/&#123;token&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showCaptcha</span><span class=\"params\">(@PathVariable String token, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//解码token</span></span><br><span class=\"line\">    CaptchaDTO dto = decodeCaptcha(token);</span><br><span class=\"line\">    LineCaptcha lineCaptcha = CaptchaUtil.createLineCaptcha(<span class=\"number\">100</span>, <span class=\"number\">40</span>, <span class=\"number\">4</span>, <span class=\"number\">50</span>);</span><br><span class=\"line\">    <span class=\"comment\">//渲染验证码</span></span><br><span class=\"line\">    lineCaptcha.createImage(dto.getCode());</span><br><span class=\"line\">    response.setContentType(<span class=\"string\">\"image/png\"</span>);</span><br><span class=\"line\">    lineCaptcha.write(response.getOutputStream());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ApiOperation</span>(value = <span class=\"string\">\"登录\"</span>, httpMethod = <span class=\"string\">\"POST\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@PostMapping</span>(<span class=\"string\">\"login\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;UserDTO&gt; <span class=\"title\">login</span><span class=\"params\">(@RequestBody LoginVO loginVO)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    CaptchaDTO dto;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//解码token</span></span><br><span class=\"line\">        dto = decodeCaptcha(loginVO.getToken());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BizException(<span class=\"string\">\"验证码数据异常\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 校验时间和验证码输入</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (System.currentTimeMillis() &gt; dto.getExp()</span><br><span class=\"line\">            || StrUtil.isBlank(loginVO.getCode())</span><br><span class=\"line\">            || !dto.getCode().equalsIgnoreCase(loginVO.getCode())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BizException(<span class=\"string\">\"验证码校验不通过\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 处理登录逻辑</span></span><br><span class=\"line\">    UserDTO user = userService.login(loginVO);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Result&lt;&gt;(user);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> CaptchaDTO <span class=\"title\">decodeCaptcha</span><span class=\"params\">(String token)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 解码token，注意要做一次url decode，因为前端通过url传递时需要做url encode</span></span><br><span class=\"line\">    String jsonStr = SecureUtil.aes(Base64.getDecoder().decode(CAPTCHA_AES_KEY)).decryptStrFromBase64(URLDecoder.decode(token, <span class=\"string\">\"UTF-8\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> JSON.parseObject(jsonStr, CaptchaDTO<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>前端</li></ul><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"Login\"</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      loginForm: &#123; <span class=\"attr\">username</span>: <span class=\"string\">\"\"</span>, <span class=\"attr\">password</span>: <span class=\"string\">\"\"</span>, <span class=\"attr\">token</span>: <span class=\"string\">\"\"</span>, <span class=\"attr\">code</span>: <span class=\"string\">\"\"</span> &#125;,</span><br><span class=\"line\">      captchaUrl: <span class=\"string\">\"\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getCaptcha();</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"comment\">//加载验证码</span></span><br><span class=\"line\">    <span class=\"keyword\">async</span> getCaptcha() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取验证码token</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.loginForm.token = <span class=\"built_in\">encodeURIComponent</span>(<span class=\"keyword\">await</span> getCaptcha());</span><br><span class=\"line\">      <span class=\"comment\">//这里其实对token做了两次encodeURIComponent，因为img标签的get请求浏览器默认会做一次decode，不做两次encode会请求失败</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.captchaUrl = <span class=\"string\">`<span class=\"subst\">$&#123;api&#125;</span>/manager/users/captcha/<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">        <span class=\"keyword\">this</span>.loginForm.token</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\">      )&#125;</span>`</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">async</span> login() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> login(<span class=\"keyword\">this</span>.loginForm);</span><br><span class=\"line\">      <span class=\"comment\">//登录后处理...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>虽然在 <code>token</code> 中加入了一分钟的过期时间，但是在这一分钟内其实够干很多事了，比如注册的业务使用这种验证码方式，一分钟内可以模拟大量的请求来进行注册，所以无状态验证码方案并不适合所有的业务场景，还是需要根据业务情况来进行实施。</p>","categories":["后端"],"tags":["http","无状态","验证码"]},{"title":"聊聊HTTP协议的keep-alive","url":"/2020/01/13/talk-http-keep-alive/","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>HTTP 协议里的<code>keep-alive</code>机制和长连接协议的<code>keep-alive</code>机制有所不同，HTTP 中的作用是为了复用 TCP 连接，而长连接中大多数作用是为了保活，例如 TCP 通过 keep-alive 心跳包来检测对方是否存活。</p><p>在<code>HTTP/1.1</code>版本中<code>keep-alive</code>默认是开启的，通过复用 TCP 连接，可以有效的降低 TCP 连接创建的开销，大多数浏览器只允许同时对同一个域名建立 6 个 TCP 连接。</p><a id=\"more\"></a><h2 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h2><p>在<code>HTTP/1.0</code>版本中是没有<code>keep-alive</code>机制的，意味着每次 HTTP 请求都会创建一个新的 TCP 连接，在响应完成后关闭当前 TCP 连接，为了验证我使用<code>wireshark</code>来监听网卡上的 HTTP 报文。</p><ol><li>通过<code>curl</code>指定 HTTP/1.0 版本</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl --http1.0 http://www.baidu.com</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>报文截图</li></ol><p><img src=\"/2020/01/13/talk-http-keep-alive/2020-01-15-14-16-26.png\" alt></p><p>可以看到在服务器发送完响应之后就主动发送了<code>FIN包</code>来关闭连接，验证了之前的内容。</p><h2 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h2><p>在<code>HTTP/1.0</code>时代，由于 TCP 连接创建成本很高，很多服务器和浏览器使用了了一套非标准的<code>keep-alive</code>机制，用于复用 TCP 连接，当然最后<code>HTTP/1.1</code>将这套东西纳入到了标准中，这个标准就是<code>Connection</code>头，用于客户端和服务端协商是否要复用 TCP 连接，在 HTTP/1.1 版本中默认值就是<code>keep-alive</code>，即保持连接。</p><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>客户端或服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。</p><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Connection</span>: close</span><br></pre></td></tr></table></figure><p>同样的为了验证以上内容，需要抓个包来看看。</p><ol><li>通过<code>curl</code>连续访问同一地址</li></ol><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl http://www.baidu.com http://www.baidu.com</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>报文截图</li></ol><p><img src=\"/2020/01/13/talk-http-keep-alive/2020-01-15-14-44-03.png\" alt></p><p>通过报文可以看到在建立了 TCP 连接之后，发生了两次 HTTP 请求之后由客户端发送<code>FIN</code>包关闭连接，说明这两次 HTTP 请求是在同一个 TCP 连接上进行的。</p><h3 id=\"一些细节\"><a href=\"#一些细节\" class=\"headerlink\" title=\"一些细节\"></a>一些细节</h3><p>在<code>HTTP/1.0</code>版本中，服务器不用返回<code>Content-Length</code>响应头来标识响应体的报文长度，因为每次请求之后都会主动断开 TCP 连接，所以客户端在接收到<code>EOF</code>(报文结束标识:-1)时，就说明响应已经全部接收完了。</p><p>而在<code>HTTP/1.1</code>版本中，由于 TCP 连接的复用，服务器必须得通过<code>Content-Length</code>来告诉客户端响应体报文应该读到哪里，不过<code>Content-Length</code>需要提前知道响应体的报文长度，对应一些很耗时的动态操作来说(例如：<a href=\"https://monkeywie.github.io/2019/08/08/server-push-and-websocket/#more\">HTTP 服务器推送</a>)，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。</p><p>对于这种情况 HTTP 协议提出了另一种<code>Chunked</code>编码来用于 HTTP 报文的传输，有一点数据就发送一点数据，直到数据发送完成，示例：</p><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">5</span></span><br><span class=\"line\"><span class=\"attribute\">hello</span></span><br><span class=\"line\"><span class=\"attribute\">4</span></span><br><span class=\"line\"><span class=\"attribute\">word</span></span><br><span class=\"line\"><span class=\"attribute\">0</span></span><br></pre></td></tr></table></figure><p>报文格式为：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;length&gt;\\r\\n</span><br><span class=\"line\">&lt;data&gt;\\r\\n</span><br><span class=\"line\">&lt;length&gt;\\r\\n</span><br><span class=\"line\">&lt;data&gt;\\r\\n</span><br><span class=\"line\">0\\r\\n</span><br></pre></td></tr></table></figure><p>即<code>数据块长度(16进制)</code>+<code>\\r\\n</code>+<code>数据块</code>+<code>\\r\\n</code>以此循环，直到<code>数据块长度=0</code>+<code>\\r\\n</code>结束</p><h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>虽然<code>keep-alive</code>是复用了 TCP 连接，但是由于<code>HTTP1/1</code>协议是不支持<code>并行</code>的，如果同一个 TCP 连接上需要完成多个 HTTP 请求，那么后一个就会被前一个 HTTP 请求阻塞着，如果前一个请求响应的特别慢，那么后面的请求就会等待的越久，在许多<code>HTTP客户端</code>中为了避免这个问题，都会允许启用多个 TCP 连接来处理，当然在应用层也可以通过合并请求的方式来减少请求数(例如：多个小图片合成一个大图)，为了解决这些问题又衍生出了<code>HTTP/2</code>版本，这里就不做过多描述了。</p><h2 id=\"衍生\"><a href=\"#衍生\" class=\"headerlink\" title=\"衍生\"></a>衍生</h2><p>我顺带测试了下<code>java</code>和<code>go</code>的 http client，发现其实它们也都实现了<code>keep-alive</code>，<br>，之前从代码的上来看，一直以为是请求完之后会直接关闭 TCP 连接，要设置一个连接池之类的东西去实现，没想到底层全部实现好了。</p><h3 id=\"java-测试\"><a href=\"#java-测试\" class=\"headerlink\" title=\"java 测试\"></a>java 测试</h3><ul><li><p>测试代码<br>使用<code>URL</code>库发起三个 HTTP 请求，并抓包分析。</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">        URL url = <span class=\"keyword\">new</span> URL(<span class=\"string\">\"http://www.baidu.com\"</span>);</span><br><span class=\"line\">        URLConnection urlConnection = url.openConnection();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream inputStream = urlConnection.getInputStream()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">8192</span>];</span><br><span class=\"line\">            <span class=\"comment\">// 空读</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (inputStream.read(temp) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li><li><p>报文截图<br>通过第一列的连线可以观察到是同一个 TCP 连接<br><img src=\"/2020/01/13/talk-http-keep-alive/2020-01-16-15-30-33.png\" alt></p></li></ul><h3 id=\"go-测试\"><a href=\"#go-测试\" class=\"headerlink\" title=\"go 测试\"></a>go 测试</h3><ul><li><p>测试代码<br>使用<code>http</code>标准库来测试，发起三个 HTTP 请求并抓包分析。</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++ &#123;</span><br><span class=\"line\">    resp, err := http.Get(<span class=\"string\">\"http://www.baidu.com\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 空读</span></span><br><span class=\"line\">    io.Copy(ioutil.Discard, resp.Body)</span><br><span class=\"line\">    resp.Body.Close()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li><li><p>报文截图<br>结果也是一样，复用了一个 TCP 连接<br><img src=\"/2020/01/13/talk-http-keep-alive/2020-01-16-15-38-01.png\" alt></p></li></ul>","categories":["后端"],"tags":["http"]},{"title":"给博客的next主题升个级","url":"/2020/08/07/upgrade-hexo-next/","content":"<h2 id=\"为什么升级\"><a href=\"#为什么升级\" class=\"headerlink\" title=\"为什么升级\"></a>为什么升级</h2><p>最近突然想把博客的评论系统换掉，因为之前用的<code>valine</code>评论插件，起初是觉得方便并且可以支持匿名评论，但是在评论之后没有通知，很多评论都是过了很久之后我才知道，所以想换一个能有通知的评论系统，起初的选型是：<code>Gitment</code>和<code>Gitalk</code>，但是发现一个更好的<code>utterances</code>，查了一下 next 高版本已经可以支持<code>utterances</code>了，这样升级 next 就直接接入了。</p><a id=\"more\"></a><h2 id=\"为什么选择-utterances\"><a href=\"#为什么选择-utterances\" class=\"headerlink\" title=\"为什么选择 utterances\"></a>为什么选择 utterances</h2><p><code>utterances</code>这款评论组件和<code>Gitalk</code>、<code>Gitment</code>一样都是基于 Github 的 issues 实现的，但是与之不同的是，<code>Gitalk</code>、<code>Gitment</code>是通过<code>OAuth Apps</code>实现的，在使用时会申请评论者对所有公共仓库的读写权限：</p><p><img src=\"/2020/08/07/upgrade-hexo-next/2020-08-07-10-52-30.png\" alt></p><p>就相当于只要评论者在确认授权之后，就可以使用评论者的 github 账号来对公共仓库做任何的事情，这风险是非常高点。</p><p>平常我想评论别人博客的时候，在授权时看到上面图片的提示，就会直接放弃评论了，因为无法确定别人网站里会不会偷偷摸摸的做一些坏事，例如：</p><p><img src=\"/2020/08/07/upgrade-hexo-next/2020-08-07-11-28-16.png\" alt=\"来自：https://www.v2ex.com/t/534800\"></p><p>而<code>utterances</code>是通过<code>Github Apps</code>实现的，权限粒度划分的很细，可以单独对某个仓库进行授权，并且只对<code>issues模块授权</code>：</p><p><img src=\"/2020/08/07/upgrade-hexo-next/2020-08-07-11-56-41.png\" alt></p><p>这样的话安全性就有保障。</p><h2 id=\"升级步骤\"><a href=\"#升级步骤\" class=\"headerlink\" title=\"升级步骤\"></a>升级步骤</h2><ol><li>删除<code>./themes/next</code>目录</li><li><p>下载最新版本的<code>next</code>主题，这里我使用的<code>v7.8.0</code>版本：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> --depth 1 --branch v7.8.0 git@github.com:theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure></li><li><p>删除<code>.git</code>目录：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm -rf themes/next/.git</span><br></pre></td></tr></table></figure></li><li><p>修改<code>themes/next/_config.yml</code>文件，如果之前有配置或定制一些功能的话需要按照新版本的规范重新设置一次</p></li></ol><h2 id=\"utterances-安装\"><a href=\"#utterances-安装\" class=\"headerlink\" title=\"utterances 安装\"></a>utterances 安装</h2><ol><li><p>安装<code>next-utterances</code>插件</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install github:theme-next/hexo-next-utteranc</span><br></pre></td></tr></table></figure><blockquote><p>注：插件还未发布到 npm 仓库，所以指定从 github 中拉取</p></blockquote></li><li><p>安装<code>next-util</code></p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install next-util --registry=https://registry.npmjs.org</span><br></pre></td></tr></table></figure><blockquote><p>注：一定要使用 npm 官方源进行安装，使用淘宝源下载不到，详见：<a href=\"https://github.com/cnpm/npm.taobao.org/issues/63\" target=\"_blank\" rel=\"noopener\">https://github.com/cnpm/npm.taobao.org/issues/63</a></p></blockquote></li><li><p>在 GitHub 上安装<code>utterances</code></p><ol><li>访问：<a href=\"https://github.com/apps/utterances\" target=\"_blank\" rel=\"noopener\">https://github.com/apps/utterances</a>进行安装<br><img src=\"/2020/08/07/upgrade-hexo-next/2020-08-07-16-29-09.png\" alt></li><li>授权时只选择存放评论的仓库<br><img src=\"/2020/08/07/upgrade-hexo-next/2020-08-07-16-33-36.png\" alt></li><li><p>修改<code>themes/next/_config.yml</code>，添加以下配置：</p><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">utteranc:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">monkeyWie/monkeywie.github.io</span></span><br><span class=\"line\">  <span class=\"attr\">pathname:</span> <span class=\"string\">pathname</span></span><br><span class=\"line\">  <span class=\"comment\"># theme: github-light,github-dark,github-dark-orange</span></span><br><span class=\"line\">  <span class=\"attr\">theme:</span> <span class=\"string\">github-light</span></span><br><span class=\"line\">  <span class=\"attr\">cdn:</span> <span class=\"string\">https://utteranc.es/client.js</span></span><br></pre></td></tr></table></figure><blockquote><p>注：只需要修改<code>repo</code>即可</p></blockquote></li></ol></li></ol><p>这样就升级完成了，重新部署博客就可以看到评论组件了。<br><img src=\"/2020/08/07/upgrade-hexo-next/2020-08-07-16-57-07.png\" alt></p><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>最后谈一谈这个组件的缺点：</p><ol><li>由于<code>utteranc.es</code>网站是国外的，国内访问的时候评论组件加载速度比较慢</li><li>如果这个网站关闭走人，那么评论组件就失效了，不过所有评论都存在 GitHub 上，所以数据是不会丢失的</li><li>目前该评论组件只支持英文，并且不支持国际化，但是由于内容也不多，所以可以忽略</li></ol>","categories":["杂谈"],"tags":["hexo"]},{"title":"用vscode + markdown制作简易幻灯片(PPT)","url":"/2019/11/27/vscode-markdown-ppt/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在公司里经常做技术分享，如果用 PPT 来做的话非常耗费时间，所以一般都是直接用 markdwon 写，但是 markdwon 有个缺点是不能像 PPT 那样翻页展示，于是就 google 了一番看看能不能把 markdown 做成像 PPT 那样的效果，果然已经有这样的技术了，下面就记录下具体步骤。</p><a id=\"more\"></a><h2 id=\"vscode-安装插件\"><a href=\"#vscode-安装插件\" class=\"headerlink\" title=\"vscode 安装插件\"></a>vscode 安装插件</h2><p>首先在 vscode 中安装<code>Markdown Preview Enhanced</code>插件，这个插件可以在 vscode 中实时预览 markdown 生成的页面。</p><p><img src=\"/2019/11/27/vscode-markdown-ppt/2019-11-27-12-19-35.gif\" alt></p><p>并且还附带了其它非常多的功能，比如目前所需的<code>幻灯片</code>功能，相关文档在这：<a href=\"https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/presentation\" target=\"_blank\" rel=\"noopener\">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/presentation</a></p><h2 id=\"语法介绍\"><a href=\"#语法介绍\" class=\"headerlink\" title=\"语法介绍\"></a>语法介绍</h2><p>在 markdown 中只需要使用<code>&lt;!-- slide --&gt;</code>代码来标记内容为幻灯片，例如：</p><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!-- slide --&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 第一页</span></span><br><span class=\"line\"></span><br><span class=\"line\">内容一</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>测试 1111111111111</span><br><span class=\"line\"><span class=\"bullet\">2. </span>测试 2222222222222</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!-- slide --&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 第二页</span></span><br><span class=\"line\"></span><br><span class=\"line\">内容二</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>测试 1111111111111</span><br><span class=\"line\"><span class=\"bullet\">- </span>测试 2222222222222</span><br></pre></td></tr></table></figure><p>效果预览：</p><p><img src=\"/2019/11/27/vscode-markdown-ppt/2019-11-27-13-43-10.gif\" alt></p><h2 id=\"样式调整\"><a href=\"#样式调整\" class=\"headerlink\" title=\"样式调整\"></a>样式调整</h2><p>默认内容的 div 大小为：<code>width:960px;height:700px</code>，在全屏预览的时候效果不好，可以通过<code>front-matter</code>语法来设置对应的分辨率：</p><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">presentation:</span><br><span class=\"line\">  width: 1920</span><br><span class=\"line\">  height: 1080</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!-- slide --&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 第一页</span></span><br><span class=\"line\"></span><br><span class=\"line\">内容一</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>测试 1111111111111</span><br><span class=\"line\"><span class=\"bullet\">2. </span>测试 2222222222222</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!-- slide --&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 第二页</span></span><br><span class=\"line\"></span><br><span class=\"line\">内容二</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>测试 1111111111111</span><br><span class=\"line\"><span class=\"bullet\">- </span>测试 2222222222222</span><br></pre></td></tr></table></figure><p>效果预览：<br><img src=\"/2019/11/27/vscode-markdown-ppt/2019-11-27-14-00-25.gif\" alt></p><p>默认内容是居中的，通过自定义<code>css style</code>可以把内容调整为左对齐和滚动条支持：</p><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">presentation:</span><br><span class=\"line\">  width: 1920</span><br><span class=\"line\">  height: 1080</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span></span></span><br><span class=\"line\">  .reveal .slides &#123;</span><br><span class=\"line\"><span class=\"code\">      margin: auto 20px;</span></span><br><span class=\"line\"><span class=\"code\">      text-align: initial;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  section.slide&#123;</span><br><span class=\"line\"><span class=\"code\">    height: 100%;</span></span><br><span class=\"line\"><span class=\"code\">    overflow-y: auto !important</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!-- slide --&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 第一页</span></span><br><span class=\"line\"></span><br><span class=\"line\">内容一</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1. </span>测试 1111111111111</span><br><span class=\"line\"><span class=\"bullet\">2. </span>测试 2222222222222</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"comment\">&lt;!-- slide --&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 第二页</span></span><br><span class=\"line\"></span><br><span class=\"line\">内容二</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">- </span>测试 1111111111111</span><br><span class=\"line\"><span class=\"bullet\">- </span>测试 2222222222222</span><br></pre></td></tr></table></figure><p>效果预览：<br><img src=\"/2019/11/27/vscode-markdown-ppt/2019-11-27-14-02-38.gif\" alt></p><h2 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h2><p>最后通过<code>Markdown Preview Enhanced</code>插件的浏览器预览功能，通过浏览器打开，并进入全屏(F11)即可得到与 PPT 一致的体验了。</p><blockquote><p>Tips:在浏览器中可以使用<kbd>←</kbd><kbd>→</kbd>来控制 PPT 的翻页，按<kbd>ESC</kbd>可以预览所有页面的缩略图。</p></blockquote><p>效果演示：<br><img src=\"/2019/11/27/vscode-markdown-ppt/2019-11-27-14-11-29.gif\" alt></p>","categories":["杂谈"],"tags":["vscode","markdown"]},{"title":"如何优雅的使用VS Code+ESLint+Prettier写Vue程序","url":"/2018/08/03/vscode-vue-eslint-prettier/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本人是 JAVA 为主，开发工具用的 IDEA，之前写 Vue 前端的时候也是直接用的 IDEA+Vue 插件来开发的，一般也是写着玩，不是正式项目，所以也从来没用过<code>ESLint</code>和<code>Prettier</code>，然后最近要参与一个前端项目，用 IDEA 导入项目后打开，出于强迫症使用熟悉的<kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>L</kbd>格式了下代码，发现代码格式完全对不上啊，调研了下之后，义无反顾的转投<code>VS Code</code>写前端了。</p><a id=\"more\"></a><h2 id=\"安装-vs-code-和插件\"><a href=\"#安装-vs-code-和插件\" class=\"headerlink\" title=\"安装 vs code 和插件\"></a>安装 vs code 和插件</h2><p>首先在<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">VS Code 官网</a>下载安装包，安装好之后启动，然后按<kbd>ctrl</kbd>+<kbd>shift</kbd>+<kbd>X</kbd>打开插件安装界面，搜索以下插件并安装好。</p><ol><li>Vetur</li><li>ESLint</li><li>Prettier - Code formatter</li></ol><p>安装完之后最好是重启下<code>VS Code</code>避免插件不生效的问题。</p><h2 id=\"插件配置\"><a href=\"#插件配置\" class=\"headerlink\" title=\"插件配置\"></a>插件配置</h2><p>按<kbd>ctrl</kbd>+<kbd>,</kbd>打开设置界面，在窗口右边有两个 tab 页面：</p><ul><li>USER SETTINGS<br>全局配置，也就是说在这里配置的话其他项目也会使用到这个配置。</li><li>WORKSPACE SETTINGS<br>项目配置，会在当前项目的根路径里创建一个<code>.vscode/settings.json</code>文件，然后配置只在当前项目生效。</li></ul><p>我这里是把插件的配置写在了<code>WORKSPACE SETTINGS</code>里，配置如下：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//.vue文件template格式化支持，并使用js-beautify-html插件</span></span><br><span class=\"line\">  <span class=\"string\">\"vetur.format.defaultFormatter.html\"</span>: <span class=\"string\">\"js-beautify-html\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//js-beautify-html格式化配置，属性强制换行</span></span><br><span class=\"line\">  <span class=\"comment\">//文档：https://github.com/beautify-web/js-beautify#css--html</span></span><br><span class=\"line\">  <span class=\"string\">\"vetur.format.defaultFormatterOptions\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"js-beautify-html\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"wrap_attributes\"</span>: <span class=\"string\">\"force\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//根据文件后缀名定义vue文件类型</span></span><br><span class=\"line\">  <span class=\"string\">\"files.associations\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"*.vue\"</span>: <span class=\"string\">\"vue\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//保存时eslint自动修复错误</span></span><br><span class=\"line\">  <span class=\"string\">\"eslint.validate\"</span>: [</span><br><span class=\"line\">    <span class=\"string\">\"javascript\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"javascriptreact\"</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"language\"</span>: <span class=\"string\">\"vue\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"autoFix\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"eslint.autoFixOnSave\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"ESLint-和-Prettier-的冲突修复\"><a href=\"#ESLint-和-Prettier-的冲突修复\" class=\"headerlink\" title=\"ESLint 和 Prettier 的冲突修复\"></a>ESLint 和 Prettier 的冲突修复</h2><p>在用<code>Prettier</code>格式化的时候，可以能会和<code>ESLint</code>定义的校验规则冲突，比如<code>Prettier</code>字符串默认是用双引号而<code>ESLint</code>定义的是单引号的话这样格式化之后就不符合<code>ESLint</code>规则了。所以要解决冲突就需要在<code>Prettier</code>的规则配置里也配置上和<code>ESLint</code>一样的规则，这里贴下<code>ESLint</code>和<code>Prettier</code>的配置文件。</p><ul><li>.eslintrc.js<br>配置<code>ESLint</code><a href=\"http://eslint.cn/docs/rules/\" target=\"_blank\" rel=\"noopener\">选项</a>，使用单引号、结尾不能有分号。</li></ul><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  root: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  env: &#123;</span><br><span class=\"line\">    node: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  extends: [<span class=\"string\">\"plugin:vue/essential\"</span>, <span class=\"string\">\"eslint:recommended\"</span>],</span><br><span class=\"line\">  rules: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"no-console\"</span>: process.env.NODE_ENV === <span class=\"string\">\"production\"</span> ? <span class=\"string\">\"error\"</span> : <span class=\"string\">\"off\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"no-debugger\"</span>: process.env.NODE_ENV === <span class=\"string\">\"production\"</span> ? <span class=\"string\">\"error\"</span> : <span class=\"string\">\"off\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"no-alert\"</span>: process.env.NODE_ENV === <span class=\"string\">\"production\"</span> ? <span class=\"string\">\"error\"</span> : <span class=\"string\">\"off\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//强制使用单引号</span></span><br><span class=\"line\">    quotes: [<span class=\"string\">\"error\"</span>, <span class=\"string\">\"single\"</span>],</span><br><span class=\"line\">    <span class=\"comment\">//强制不使用分号结尾</span></span><br><span class=\"line\">    semi: [<span class=\"string\">\"error\"</span>, <span class=\"string\">\"never\"</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  parserOptions: &#123;</span><br><span class=\"line\">    parser: <span class=\"string\">\"babel-eslint\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><ul><li>.prettierrc<br>配置<code>Prettier</code><a href=\"https://prettier.io/docs/en/options.html\" target=\"_blank\" rel=\"noopener\">选项</a>，使用单引号、结尾不能有分号。</li></ul><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"eslintIntegration\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">//使用单引号</span></span><br><span class=\"line\">  <span class=\"string\">\"singleQuote\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"comment\">//结尾不加分号</span></span><br><span class=\"line\">  <span class=\"string\">\"semi\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样把<code>ESLint</code>和<code>Prettier</code>冲突的规则配置一致,格式化之后就不会冲突了。</p><h2 id=\"效果预览\"><a href=\"#效果预览\" class=\"headerlink\" title=\"效果预览\"></a>效果预览</h2><p><img src=\"/2018/08/03/vscode-vue-eslint-prettier/template-format.gif\" alt=\"格式化template\"><br><img src=\"/2018/08/03/vscode-vue-eslint-prettier/js-format.gif\" alt=\"格式化js\"></p>","categories":["前端"],"tags":["vscode","js","vue"]},{"title":"win10彻底关闭windows defender","url":"/2020/03/31/win10-disabled-windows-defender/","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近把 win10 版本升级到了<code>1909</code>,然后发现在有个<code>Windows Defender Antivirus Server</code>的服务会占用大量的 cpu 和内存，网上找了好多办法都关不掉它，现在终于找了个靠谱的办法在这里记录下。</p><a id=\"more\"></a><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol><li><p>打开注册表，找到<code>HKEY_LOCAL_MACHINE/SOFTWARE/Policies/Microsoft/Windows Defender</code></p></li><li><p>右边窗口新建一个名为<code>DisableAntiSpyware</code>类型为<code>DWORD(32 位)值</code>的键，并将值设为<code>1</code>保存。</p></li></ol><p><img src=\"/2020/03/31/win10-disabled-windows-defender/2020-04-01-09-08-58.png\" alt></p><ol start=\"3\"><li><p>左边窗口选中<code>Windows Defender</code>项，再其里面新建一个名为<code>Real-Time Protection</code>的<code>项</code>。</p></li><li><p>在刚刚创建的<code>Real-Time Protection</code>项中新建一个名为<code>DisableScanOnRealtimeEnable</code>类型为<code>DWORD(32 位)值</code>的键，并将值设为<code>1</code>保存。</p></li></ol><p><img src=\"/2020/03/31/win10-disabled-windows-defender/2020-04-01-09-13-01.png\" alt></p><ol start=\"5\"><li><p>最重要的一步，禁用<code>Windows Defender</code>启动，找到<code>\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\SecurityHealthService</code></p></li><li><p>将右边窗口的<code>Start</code>键值由<code>2</code>改为<code>4</code>，如果后续要重新启用再改回来即可。</p></li></ol><p><img src=\"/2020/03/31/win10-disabled-windows-defender/2020-04-01-09-16-23.png\" alt></p>","categories":["windows"],"tags":["win10"]},{"title":"win10右键菜单在当前目录下打开CMD","url":"/2019/07/08/win10-open-cmd/","content":"<p>win10 右键菜单只能打开 Powershell，然而不知道是 Powershell 难用还是我不会用，各种莫名其妙的问题，这个时候想想还是<code>cmd</code>真香，所以在网上找了个办法把 <code>cmd</code> 加到右键菜单里已方便使用。</p><h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>新建一个文档，赋值粘贴以下代码，并且将文档保存为.reg 格式的文件。</p><a id=\"more\"></a><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;在此处打开CMD窗口&quot;</span><br><span class=\"line\">&quot;Icon&quot;=&quot;cmd.exe&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\background\\shell\\cmd_here\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;\\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;在此处打开CMD窗口&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Folder\\shell\\cmdPrompt\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;\\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe\\&quot; \\&quot;cd %1\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;在此处打开CMD窗口&quot;</span><br><span class=\"line\">&quot;Icon&quot;=&quot;cmd.exe&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\Directory\\shell\\cmd_here\\command]</span><br><span class=\"line\"></span><br><span class=\"line\">@=&quot;\\&quot;C:\\\\Windows\\\\System32\\\\cmd.exe\\&quot;&quot;</span><br></pre></td></tr></table></figure><p>双击运行即可</p><h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"/2019/07/08/win10-open-cmd/2019-07-08-11-27-25.png\" alt></p>","categories":["windows"],"tags":["win10","shell"]},{"title":"我云了，原来wireshark可以抓HTTPS明文包","url":"/2020/08/07/wireshark-capture-https/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>以前在使用<code>wireshark</code>做协议分析的时候，一直以为它只能抓 HTTP 的报文，所以在抓 HTTPS 包的时候一直是用的<code>Fildder</code>，然而有一天我突然想抓一下<code>HTTP2</code>的报文看一看，<code>Fildder</code>就不行了，于是在一番 google 之后发现<code>wireshark</code>是可以支持的，只不过需要在特定的条件下才可以。</p><a id=\"more\"></a><h2 id=\"Fildder-存在的问题\"><a href=\"#Fildder-存在的问题\" class=\"headerlink\" title=\"Fildder 存在的问题\"></a>Fildder 存在的问题</h2><p><code>Fildder</code>目前还不支持<code>HTTP2</code>协议，无法看到真正的<code>HTTP2</code>报文，这里有些人可能会有疑问，说我明明就用<code>Fildder</code>抓到了<code>HTTP2</code>协议的报文啊，那是因为<code>Fiddler</code>中间人攻击服务器通过协商把协议降级成了<code>HTTP1</code>协议，所以实际上看到的还是的<code>HTTP1</code>的报文，通过下面两个图片可以直观的感受到：</p><ul><li>不通过代理，直接访问支持 HTTP2 的服务</li></ul><p><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-10-10-24.png\" alt></p><ul><li>通过代理访问，进行抓包</li></ul><p><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-10-11-37.png\" alt></p><p>可以看到在通过代理抓包的时候，协议变成了<code>http/1.1</code>。</p><h2 id=\"使用-wireshark-抓取\"><a href=\"#使用-wireshark-抓取\" class=\"headerlink\" title=\"使用 wireshark 抓取\"></a>使用 wireshark 抓取</h2><p>现在市面上的主流浏览器实现的 HTTP2 都是基于<code>TLS</code>的，也就是说要分析<code>HTTP2</code>报文得先过了<code>TLS</code>这一关，不然只能分析一堆加密的乱码。</p><p><code>wireshark</code>支持两种方式来解密<code>SSL/TLS</code>报文：</p><ol><li>通过网站的私钥</li><li>通过浏览器的将 TLS 对称加密秘保存在外部文件中，以供 wireshark 加解密</li></ol><p>下面我来一一进行演示</p><h3 id=\"1-通过网站的私钥\"><a href=\"#1-通过网站的私钥\" class=\"headerlink\" title=\"1. 通过网站的私钥\"></a>1. 通过网站的私钥</h3><p>如果你想抓取的网站是你自己的，那么可以利用这种方式，因为这需要使用网站生成证书使用的私钥进行解密，就是那个 nginx 上<code>ssl_certificate_key</code>配置对应的私钥文件，把它添加到 wireshark 配置中：</p><p><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-10-41-14.png\" alt></p><p>然后通过<code>wireshark</code>就可以看到明文了：</p><p><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-11-10-00.png\" alt></p><p>通过上图可以看到，我通过<code>curl</code>访问的 https 协议的 URL，在配置了该服务器对应的私钥后可以抓取到对应的 HTTP 明文。</p><p>不过缺点也非常明显，只能分析自己持有私钥的网站，如果别人的网站就分析不了了，所幸的是还有第二种方案来支持。</p><h3 id=\"2-通过浏览器的-SSL-日志功能\"><a href=\"#2-通过浏览器的-SSL-日志功能\" class=\"headerlink\" title=\"2. 通过浏览器的 SSL 日志功能\"></a>2. 通过浏览器的 SSL 日志功能</h3><p>目前该方案只支持<code>Chrome</code>和<code>Firefox</code>浏览器，通过设置<code>SSLKEYLOGFILE</code>环境变量，可以指定浏览器在访问<code>SSL/TLS</code>网站时将对应的密钥保存到本地文件中，有了这个日志文件之后<code>wireshake</code>就可以将报文进行解密了。</p><ol><li><p>首先设置<code>SSLKEYLOGFILE</code>环境变量：<br><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-11-19-37.png\" alt></p><blockquote><p>注：这是在 windows 系统上进行操作的，其它操作系统同理</p></blockquote></li><li><p>配置<code>wireshake</code>，首选项-&gt;Protocls-&gt;TLS：<br><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-11-23-31.png\" alt></p><p>将第一步中指定的文件路径配置好</p></li><li><p>重启浏览器，进行抓包：<br><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-11-30-55.png\" alt></p><p>同样的可以抓取到 HTTP 明文。</p><blockquote><p>注：不抓包时记得把环境变量删掉，以避免性能浪费和安全性问题</p></blockquote></li></ol><p>方案二的优点非常明显，可以抓取任意网站的<code>SSL/TLS</code>加密的报文，唯一的缺点就是只能是浏览器支持的情况才行，而方案一可以针对任何 HTTP 客户端进行抓包。</p><h2 id=\"通过-wireshake-抓取-HTTP2-报文\"><a href=\"#通过-wireshake-抓取-HTTP2-报文\" class=\"headerlink\" title=\"通过 wireshake 抓取 HTTP2 报文\"></a>通过 wireshake 抓取 HTTP2 报文</h2><p>上面都是针对<code>TLS+HTTP1</code>进行的抓包，市面上主流的浏览器的<code>HTTP2</code>都是基于<code>TLS</code>实现的，所以也是一样的，把<code>TLS</code>这层解密了自然看到的就是最原始的明文。</p><p>这里以分析<code>https://www.qq.com</code>为例，为什么不是经典<code>htts://www.baidu.com</code>，因为百度首页至今还是<code>HTTP/1.1</code>协议。</p><ol><li>使用上面的第二种方案配置好<code>wiresharke</code></li><li>通过<code>http2</code>关键字做过滤</li><li>浏览器访问<code>https://www.qq.com</code></li><li><p>查看<code>HTTP2</code>报文：<br><img src=\"/2020/08/07/wireshark-capture-https/2020-08-10-11-47-00.png\" alt></p><p>这样就抓取到了<code>HTTP2</code>报文了，HTTP2 协议非常复杂，我也还在学习阶段，这里就不多说啥了。</p></li></ol><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>wireshake 真的是一款非常强大的网络分析工具，在<code>HTTPS</code>和<code>HTTP2</code>日渐成为主流的时候，可以用它来帮助我们加深对这些协议的理解，以便迎接新的机遇与挑战。</p><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul><li><a href=\"https://imququ.com/post/http2-traffic-in-wireshark.html\" target=\"_blank\" rel=\"noopener\">使用 Wireshark 调试 HTTP/2 流量</a></li></ul>","categories":["后端"],"tags":["https","协议分析","http","wireshark"]},{"title":"CDH6.2离线安装","url":"/2020/04/14/cdh6-2-install/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在公司搭建了一个 CDH 测试环境集群，从官网得知 CDH 在 6.3.3 版本开始不再提供免费版本了，于是选择了 6.2.x 版本进行安装，这里记录一下正确的<code>离线安装</code>步骤，避免下次安装时又踩坑。</p><a id=\"more\"></a><h2 id=\"CM-和-CDH-简介\"><a href=\"#CM-和-CDH-简介\" class=\"headerlink\" title=\"CM 和 CDH 简介\"></a>CM 和 CDH 简介</h2><p>在安装之前先要理清一下 CM(Cloudera Manager)和 CDH(Cloudera Distribution Hadoop)的区别。</p><ul><li>CDH<br>CDH 是由 Cloudera 公司发行的一套 hadoop 软件包，里面包含了<code>hadoop、hdfs、yarn、hive、spark</code>等等一系列<code>稳定的</code>、<code>版本兼容的</code>大数据套件。</li><li>CM<br>CM 也是 Cloudera 公司开发的一套用于管理和监控 CDH 集群的软件，只要通过 CM 提供的 web 管理页面操作就可以轻松的管理和监控 CDH 集群环境。<br>当然也可以手动使用 CDH 来搭建集群，在服务器数量较少的情况下还可以接受，但是试想下如果集群有上百台或上千台机器，每个机器都手动安装，这是人做的事吗？</li></ul><h2 id=\"安装前准备\"><a href=\"#安装前准备\" class=\"headerlink\" title=\"安装前准备\"></a>安装前准备</h2><h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><p>准备好 N 台服务器，我这里用了 3 台机器，分别如下：</p><table><thead><tr><th>IP</th><th>CPU</th><th>内存</th><th>硬盘</th><th>系统</th></tr></thead><tbody><tr><td>192.168.200.135</td><td>4 核</td><td>16G</td><td>50G</td><td>CentOS7</td></tr><tr><td>192.168.200.136</td><td>4 核</td><td>16G</td><td>50G</td><td>CentOS7</td></tr><tr><td>192.168.200.137</td><td>4 核</td><td>16G</td><td>50G</td><td>CentOS7</td></tr></tbody></table><p><code>注</code>：所有机器的 root 用户登录密码要保持一致</p><h3 id=\"域名设置\"><a href=\"#域名设置\" class=\"headerlink\" title=\"域名设置\"></a>域名设置</h3><p>为三台机器设置好对应的域名，并在<code>hosts</code>中做好对应的 IP 解析。</p><table><thead><tr><th>IP</th><th>域名</th></tr></thead><tbody><tr><td>192.168.200.135</td><td>master.cdh</td></tr><tr><td>192.168.200.136</td><td>node1.cdh</td></tr><tr><td>192.168.200.137</td><td>node2.cdh</td></tr></tbody></table><p>修改所有机器的<code>/etc/hosts</code>文件，在后面加入以下内容：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">192.168.200.135 master.cdh</span><br><span class=\"line\">192.168.200.136 node1.cdh</span><br><span class=\"line\">192.168.200.137 node2.cdh</span><br></pre></td></tr></table></figure><p>分别设置机器的主机名，执行以下命令</p><ul><li><p>192.168.200.135</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname master.cdh</span><br></pre></td></tr></table></figure></li><li><p>192.168.200.136</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname node1.cdh</span><br></pre></td></tr></table></figure></li><li><p>192.168.200.137</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hostnamectl set-hostname node2.cdh</span><br></pre></td></tr></table></figure></li></ul><h3 id=\"关闭防火墙和-SELinux\"><a href=\"#关闭防火墙和-SELinux\" class=\"headerlink\" title=\"关闭防火墙和 SELinux\"></a>关闭防火墙和 SELinux</h3><p>关闭所有机器的防火墙和 SELinux，执行以下命令：</p><ul><li><p>关闭防火墙</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl stop firewalld</span><br><span class=\"line\">systemctl disable firewalld</span><br></pre></td></tr></table></figure></li><li><p>关闭 SELinux<br>编辑<code>/etc/selinux/config</code>文件，将<code>SELINUX=enforcing</code>修改为<code>SELINUX=permissive</code>。<br>执行命令<code>setenforce 0</code>临时生效，或者重启机器永久生效。</p></li></ul><h3 id=\"搭建本地-yum-源\"><a href=\"#搭建本地-yum-源\" class=\"headerlink\" title=\"搭建本地 yum 源\"></a>搭建本地 yum 源</h3><p>在<code>master</code>节点上搭建本地源用于离线安装<code>CM</code></p><ul><li><p>使用<code>httpd</code>作为本地源服务</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y httpd</span><br><span class=\"line\">systemctl start httpd</span><br></pre></td></tr></table></figure></li><li><p>下载 CM 离线包</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://archive.cloudera.com/cm6/6.2.1/repo-as-tarball/cm6.2.1-redhat7.tar.gz</span><br></pre></td></tr></table></figure><p>下载慢的话可以用<code>ProxeeDown</code>或者<code>IDM</code>这类高并发下载器进行下载，再复制到<code>master</code>节点。<br>还是下载不动的话只能挂梯子下了。</p></li><li><p>解压到对应目录</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /var/www/html/cloudera-repos/cm6</span><br><span class=\"line\">tar xvfz cm6.2.1-redhat7.tar.gz -C /var/www/html/cloudera-repos/cm6 --strip-components=1</span><br></pre></td></tr></table></figure></li><li><p>验证<br>浏览器访问<code>http://master.cdh/cloudera-repos/cm6</code>，安装成功的话可以看到下图：<br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-12-14-29.png\" alt></p></li><li><p>源配置<br>只需要在<code>master.cdh</code>节点上配置即可</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch vi /etc/yum.repos.d/cloudera-repo.repo</span><br></pre></td></tr></table></figure><p>在文件中写入以下内容：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[cloudera-repo]</span><br><span class=\"line\">name=cloudera-repo</span><br><span class=\"line\">baseurl=http://master.cdh/cloudera-repos/cm6</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=0</span><br></pre></td></tr></table></figure></li></ul><h3 id=\"安装-JDK\"><a href=\"#安装-JDK\" class=\"headerlink\" title=\"安装 JDK\"></a>安装 JDK</h3><p>在<code>所有机器</code>上安装好 jdk，这里我安装的是<code>openjdk1.8</code></p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure><h3 id=\"安装-CM\"><a href=\"#安装-CM\" class=\"headerlink\" title=\"安装 CM\"></a>安装 CM</h3><p>在<code>master</code>节点安装 CM</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y cloudera-manager-daemons cloudera-manager-agent cloudera-manager-server</span><br></pre></td></tr></table></figure><p>之前配置好了本地 yum 源，现在通过 yum 安装 CM 会非常的快，直接使用本地的包</p><p><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-14-48.png\" alt></p><h3 id=\"安装-MariaDB\"><a href=\"#安装-MariaDB\" class=\"headerlink\" title=\"安装 MariaDB\"></a>安装 MariaDB</h3><p>在<code>master</code>节点上安装一个数据库，这里我安装的是<code>MariaDB</code></p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install -y mariadb-server</span><br></pre></td></tr></table></figure><p>修改数据库配置文件<code>/etc/my.cnf</code>，使用官方提供的配置进行替换：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">datadir=/var/lib/mysql</span><br><span class=\"line\">socket=/var/lib/mysql/mysql.sock</span><br><span class=\"line\">transaction-isolation = READ-COMMITTED</span><br><span class=\"line\"># Disabling symbolic-links is recommended to prevent assorted security risks;</span><br><span class=\"line\"># to do so, uncomment this line:</span><br><span class=\"line\">symbolic-links = 0</span><br><span class=\"line\"># Settings user and group are ignored when systemd is used.</span><br><span class=\"line\"># If you need to run mysqld under a different user or group,</span><br><span class=\"line\"># customize your systemd unit file for mariadb according to the</span><br><span class=\"line\"># instructions in http://fedoraproject.org/wiki/Systemd</span><br><span class=\"line\"></span><br><span class=\"line\">key_buffer = 16M</span><br><span class=\"line\">key_buffer_size = 32M</span><br><span class=\"line\">max_allowed_packet = 32M</span><br><span class=\"line\">thread_stack = 256K</span><br><span class=\"line\">thread_cache_size = 64</span><br><span class=\"line\">query_cache_limit = 8M</span><br><span class=\"line\">query_cache_size = 64M</span><br><span class=\"line\">query_cache_type = 1</span><br><span class=\"line\"></span><br><span class=\"line\">max_connections = 550</span><br><span class=\"line\">#expire_logs_days = 10</span><br><span class=\"line\">#max_binlog_size = 100M</span><br><span class=\"line\"></span><br><span class=\"line\">#log_bin should be on a disk with enough free space.</span><br><span class=\"line\">#Replace &apos;/var/lib/mysql/mysql_binary_log&apos; with an appropriate path for your</span><br><span class=\"line\">#system and chown the specified folder to the mysql user.</span><br><span class=\"line\">log_bin=/var/lib/mysql/mysql_binary_log</span><br><span class=\"line\"></span><br><span class=\"line\">#In later versions of MariaDB, if you enable the binary log and do not set</span><br><span class=\"line\">#a server_id, MariaDB will not start. The server_id must be unique within</span><br><span class=\"line\">#the replicating group.</span><br><span class=\"line\">server_id=1</span><br><span class=\"line\"></span><br><span class=\"line\">binlog_format = mixed</span><br><span class=\"line\"></span><br><span class=\"line\">read_buffer_size = 2M</span><br><span class=\"line\">read_rnd_buffer_size = 16M</span><br><span class=\"line\">sort_buffer_size = 8M</span><br><span class=\"line\">join_buffer_size = 8M</span><br><span class=\"line\"></span><br><span class=\"line\"># InnoDB settings</span><br><span class=\"line\">innodb_file_per_table = 1</span><br><span class=\"line\">innodb_flush_log_at_trx_commit  = 2</span><br><span class=\"line\">innodb_log_buffer_size = 64M</span><br><span class=\"line\">innodb_buffer_pool_size = 4G</span><br><span class=\"line\">innodb_thread_concurrency = 8</span><br><span class=\"line\">innodb_flush_method = O_DIRECT</span><br><span class=\"line\">innodb_log_file_size = 512M</span><br><span class=\"line\"></span><br><span class=\"line\">[mysqld_safe]</span><br><span class=\"line\">log-error=/var/log/mariadb/mariadb.log</span><br><span class=\"line\">pid-file=/var/run/mariadb/mariadb.pid</span><br><span class=\"line\"></span><br><span class=\"line\">#</span><br><span class=\"line\"># include all files from the config directory</span><br><span class=\"line\">#</span><br><span class=\"line\">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure><p>启动数据库</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start mariadb</span><br><span class=\"line\">systemctl enable mariadb</span><br></pre></td></tr></table></figure><p>初始化数据库</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/bin/mysql_secure_installatio</span><br></pre></td></tr></table></figure><p>初始化<code>root</code>用户密码和其它一些选项</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">Enter current password for root (enter for none):</span><br><span class=\"line\">OK, successfully used password, moving on...</span><br><span class=\"line\">[...]</span><br><span class=\"line\">Set root password? [Y/n] Y</span><br><span class=\"line\">New password:</span><br><span class=\"line\">Re-enter new password:</span><br><span class=\"line\">[...]</span><br><span class=\"line\">Remove anonymous users? [Y/n] Y</span><br><span class=\"line\">[...]</span><br><span class=\"line\">Disallow root login remotely? [Y/n] N</span><br><span class=\"line\">[...]</span><br><span class=\"line\">Remove test database and access to it [Y/n] Y</span><br><span class=\"line\">[...]</span><br><span class=\"line\">Reload privilege tables now? [Y/n] Y</span><br><span class=\"line\">[...]</span><br><span class=\"line\">All done!  If you&apos;ve completed all of the above steps, your MariaDB</span><br><span class=\"line\">installation should now be secure.</span><br><span class=\"line\"></span><br><span class=\"line\">Thanks for using MariaDB!</span><br></pre></td></tr></table></figure><h3 id=\"下载-jdbc-驱动\"><a href=\"#下载-jdbc-驱动\" class=\"headerlink\" title=\"下载 jdbc 驱动\"></a>下载 jdbc 驱动</h3><p>在<code>master</code>节点上下载，因为 Maria 兼容 MySql ，所以直接下载 mysql 的 jdbc 驱动就行</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.46.tar.gz</span><br><span class=\"line\">mkdir -p /usr/share/java/</span><br><span class=\"line\">cp mysql-connector-java-5.1.46/mysql-connector-java-5.1.46-bin.jar /usr/share/java/mysql-connector-java.jar</span><br></pre></td></tr></table></figure><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><p>登录 DB 并创建对应的数据库和用户，用于后续 CM 程序使用</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql -u root -p</span><br></pre></td></tr></table></figure><p>执行语句</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE scm DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON scm.* TO &apos;scm&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE amon DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON amon.* TO &apos;amon&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE rman DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON rman.* TO &apos;rman&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE hue DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON hue.* TO &apos;hue&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE metastore DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON metastore.* TO &apos;hive&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE sentry DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON sentry.* TO &apos;sentry&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE nav DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON nav.* TO &apos;nav&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE navms DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON navms.* TO &apos;navms&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br><span class=\"line\">CREATE DATABASE oozie DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</span><br><span class=\"line\">GRANT ALL ON oozie.* TO &apos;oozie&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br></pre></td></tr></table></figure><p>确认是否创建成功</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MariaDB [(none)]&gt; SHOW DATABASES;</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| Database           |</span><br><span class=\"line\">+--------------------+</span><br><span class=\"line\">| information_schema |</span><br><span class=\"line\">| amon               |</span><br><span class=\"line\">| hue                |</span><br><span class=\"line\">| metastore          |</span><br><span class=\"line\">| mysql              |</span><br><span class=\"line\">| nav                |</span><br><span class=\"line\">| navms              |</span><br><span class=\"line\">| oozie              |</span><br><span class=\"line\">| performance_schema |</span><br><span class=\"line\">| rman               |</span><br><span class=\"line\">| scm                |</span><br><span class=\"line\">| sentry             |</span><br><span class=\"line\">+--------------------+</span><br></pre></td></tr></table></figure><h3 id=\"设置-CM-数据库\"><a href=\"#设置-CM-数据库\" class=\"headerlink\" title=\"设置 CM 数据库\"></a>设置 CM 数据库</h3><p>官方提供了一个脚本用于初始化 CM 相关的数据，执行如下命令：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/opt/cloudera/cm/schema/scm_prepare_database.sh mysql scm scm</span><br></pre></td></tr></table></figure><p>执行完成</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/opt/cloudera/cm/schema/scm_prepare_database.sh mysql scm scm</span><br><span class=\"line\">Enter SCM password:</span><br><span class=\"line\">JAVA_HOME=/usr/lib/jvm/java-openjdk</span><br><span class=\"line\">Verifying that we can write to /etc/cloudera-scm-server</span><br><span class=\"line\">Creating SCM configuration file in /etc/cloudera-scm-server</span><br><span class=\"line\">Executing:  /usr/lib/jvm/java-openjdk/bin/java -cp /usr/share/java/mysql-connector-java.jar:/usr/share/java/oracle-connector-java.jar:/usr/share/java/postgresql-connector-java.jar:/opt/cloudera/cm/schema/../lib/* com.cloudera.enterprise.dbutil.DbCommandExecutor /etc/cloudera-scm-server/db.properties com.cloudera.cmf.db.</span><br><span class=\"line\">[                          main] DbCommandExecutor              INFO  Successfully connected to database.</span><br><span class=\"line\">All done, your SCM database is configured correctly!</span><br></pre></td></tr></table></figure><h3 id=\"下载-CDH-离线包\"><a href=\"#下载-CDH-离线包\" class=\"headerlink\" title=\"下载 CDH 离线包\"></a>下载 CDH 离线包</h3><p>这里要注意的是，根据不同的操作系统需要下载对应的包，浏览器访问<a href=\"https://archive.cloudera.com/cdh6/6.2.1/parcels\" target=\"_blank\" rel=\"noopener\">https://archive.cloudera.com/cdh6/6.2.1/parcels</a>可以看到所有包，由于我这里用的是<code>CentOS7</code>，所以选择下载<code>CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel</code>。<br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-13-36-55.png\" alt></p><ul><li>下载</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://archive.cloudera.com/cdh6/6.2.1/parcels/CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel</span><br></pre></td></tr></table></figure><p>下载慢的话参考上一步的解决办法，下载完成后将文件复制到<code>/opt/cloudera/parcel-repo</code>目录</p><ul><li>复制到<code>/opt/cloudera/parcel-repo</code>目录</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /opt/cloudera/parcel-repo</span><br><span class=\"line\">mv CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel /opt/cloudera/parcel-repo/</span><br></pre></td></tr></table></figure><ul><li>生成<code>sha1</code>签名文件</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sha1sum CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel | awk &apos;&#123; print $1 &#125;&apos; &gt; CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel.sha</span><br></pre></td></tr></table></figure><ul><li>修改目录所属用户</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chown -R cloudera-scm:cloudera-scm /opt/cloudera/parcel-repo/*</span><br></pre></td></tr></table></figure><ul><li>目录最终如下</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls -l /opt/cloudera/parcel-repo/</span><br><span class=\"line\">-rw-r--r--. 1 cloudera-scm cloudera-scm 2093332003 4月   9 10:19 CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel</span><br><span class=\"line\">-rw-r--r--. 1 cloudera-scm cloudera-scm         41 4月  16 16:26 CDH-6.2.1-1.cdh6.2.1.p0.1425774-el7.parcel.sha</span><br></pre></td></tr></table></figure><h3 id=\"启动-CM-服务\"><a href=\"#启动-CM-服务\" class=\"headerlink\" title=\"启动 CM 服务\"></a>启动 CM 服务</h3><p>在<code>master</code>节点上运行以下命令：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start cloudera-scm-server</span><br></pre></td></tr></table></figure><p>观察日志输出，当看到<code>Started Jetty server.</code>时表示服务已经启动成功了</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">tail -f /var/log/cloudera-scm-server/cloudera-scm-server.log</span><br></pre></td></tr></table></figure><p><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-27-25.png\" alt></p><h3 id=\"访问-CM-控制台\"><a href=\"#访问-CM-控制台\" class=\"headerlink\" title=\"访问 CM 控制台\"></a>访问 CM 控制台</h3><p>浏览器访问<code>http://master.cdh:7180</code>，账号密码统一为<code>admin</code>。</p><p><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-29-38.png\" alt></p><h2 id=\"开始安装\"><a href=\"#开始安装\" class=\"headerlink\" title=\"开始安装\"></a>开始安装</h2><p><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-31-10.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-31-54.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-32-11.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-32-37.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-32-53.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-33-48.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-35-26.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-36-16.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-17-38-29.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-08-35.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-13-41.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-14-16.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-14-47.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-15-46.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-16-31.png\" alt><br><img src=\"/2020/04/14/cdh6-2-install/2020-04-16-18-21-10.png\" alt></p><p>然后等到安装完成就行了，最终结果如下：</p><p><img src=\"/2020/04/14/cdh6-2-install/2020-04-17-09-06-21.png\" alt></p>","categories":["大数据"],"tags":["cdh"]},{"title":"自定义SpringMVC中的RequestMappingHandlerMapping","url":"/2020/06/22/custom-springmvc-requestmappinghandlermapping/","content":"<h2 id=\"RequestMappingHandlerMapping-介绍\"><a href=\"#RequestMappingHandlerMapping-介绍\" class=\"headerlink\" title=\"RequestMappingHandlerMapping 介绍\"></a>RequestMappingHandlerMapping 介绍</h2><p><code>RequestMappingHandlerMapping</code>是<code>SpringMVC</code>中的一个重要组件，作用是扫描<code>@Controller</code>、<code>@RequestMapping</code>注解修饰的类，然后生成<code>请求</code>与<code>方法</code>的对应关系，当有一个 HTTP 请求进入 SpringMVC 时，就会通过请求找到对应的方法进行执行。</p><p>可以简单的想象一下，在<code>RequestMappingHandlerMapping</code>会维护一个<code>Map&lt;String,Handle&gt;</code>，key 存放的是<code>URI</code>，value 存放的是对应处理的<code>handle</code>，例如：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.put(&quot;GET /user&quot;,UserController#get)</span><br><span class=\"line\">map.put(&quot;POST /user&quot;,UserController#create)</span><br></pre></td></tr></table></figure><p>这样通过解析请求就可以很快的找到对应的方法去执行，当然 SpringMVC 的实现肯定不会像上面一样这么简单，不过思路是差不多的。</p><a id=\"more\"></a><h3 id=\"加载流程\"><a href=\"#加载流程\" class=\"headerlink\" title=\"加载流程\"></a>加载流程</h3><ul><li>流程图</li></ul><p><img src=\"/2020/06/22/custom-springmvc-requestmappinghandlermapping/2020-06-22-16-57-20.png\" alt=\"IDEA SequenceDiagram插件生成\"></p><ol><li><code>RequestMappingHandlerMapping</code>实现了<code>InitializingBean</code>接口，在应用启动时会触发<code>afterPropertiesSet</code>方法。</li><li><p>在<code>initHandlerMethods</code>方法中，会遍历所有候选的 Bean，并通过<code>processCandidateBean</code>方法进行处理。</p><ul><li>AbstractHandlerMethodMapping.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerMethods</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//遍历所有候选的Bean name</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理Bean name</span></span><br><span class=\"line\">            processCandidateBean(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>processCandidateBean</code>方法中，会通过<code>isHandler</code>判断<code>Bean</code>是否为<code>@Controller</code>、<code>@RequestMapping</code>注解修饰的类，是的话调用<code>detectHandlerMethods</code>来检查类中的<code>Handler method</code></p></li><li><p><code>detectHandlerMethods</code>中会遍历类中所有方法，通过<code>getMappingForMethod</code>方法筛选出<code>@RequestMapping</code>注解修饰的方法，然后解析成<code>method</code>-&gt;<code>mapping</code>的 Map 结构存起来，再遍历使用<code>registerHandlerMethod</code>方法注册到 SpringMVC 中</p><ul><li>AbstractHandlerMethodMapping.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">detectHandlerMethods</span><span class=\"params\">(Object handler)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; handlerType = (handler <span class=\"keyword\">instanceof</span> String ?</span><br><span class=\"line\">            obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlerType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class=\"line\">        <span class=\"comment\">//查询Class中的方法</span></span><br><span class=\"line\">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class=\"line\">                (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过匿名内部类的方式来进行method的过滤，没有通过@RequestMapping修饰的方法会返回null</span></span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> getMappingForMethod(method, userType);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Invalid mapping on handler class [\"</span> +</span><br><span class=\"line\">                                userType.getName() + <span class=\"string\">\"]: \"</span> + method, ex);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class=\"line\">            logger.trace(formatMappings(userType, methods));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历methods进行注册</span></span><br><span class=\"line\">        methods.forEach((method, mapping) -&gt; &#123;</span><br><span class=\"line\">            Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class=\"line\">            registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ol start=\"5\"><li>通过<code>registerHandlerMethod</code>将对应的关系存放到<code>mappingRegistry</code>对象中，里面有很多的 Map 用于存储映射关系</li></ol><ul><li>AbstractHandlerMethodMapping.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//封装HandlerMethod，实际上就是bean name+method，在拦截器中就是暴露的这个对象</span></span><br><span class=\"line\">HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class=\"line\">validateMethodMapping(handlerMethod, mapping);</span><br><span class=\"line\"><span class=\"comment\">//将mapping对象和handlerMethod关系存放至mappingLookup</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String url : directUrls) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//将非通配符形式的路径与mapping对象关系存放至urlLookup</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.urlLookup.add(url, mapping);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String name = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (getNamingStrategy() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class=\"line\">    addMappingName(name, handlerMethod);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (corsConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.registry.put(mapping, <span class=\"keyword\">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br></pre></td></tr></table></figure><p>通过源码可以得知，目前有这两个<code>mappingLookup</code>和<code>urlLookup</code>对象存放了请求映射关系，在请求到来的时候就会通过这两个<code>Map</code>去寻找要执行的方法。</p></li></ol><h3 id=\"请求流程\"><a href=\"#请求流程\" class=\"headerlink\" title=\"请求流程\"></a>请求流程</h3><p>先上一张 springMVC 流程图：<br><img src=\"/2020/06/22/custom-springmvc-requestmappinghandlermapping/2020-06-23-14-11-20.png\" alt></p><p>入口由<code>DispatcherServlet</code>统一接管，然后通过上一步生成好的<code>HandlerMapping</code>映射关系来查找请求对应的处理方法。</p><ul><li>DispatcherServlet.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寻找当前请求的处理方法</span></span><br><span class=\"line\">mappedHandler = getHandler(processedRequest);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mappedHandler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    noHandlerFound(processedRequest, response);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getHandler</code>方法中就是对应的逻辑了，代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> HandlerExecutionChain <span class=\"title\">getHandler</span><span class=\"params\">(HttpServletRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerMappings != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//遍历handlerMappings,只要能根据请求匹配到一个handler就返回</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (HandlerMapping mapping : <span class=\"keyword\">this</span>.handlerMappings) &#123;</span><br><span class=\"line\">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handler != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> handler;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里值得一提的是<code>handlerMappings</code>是一组<code>HandlerMapping</code>接口的实现，<code>SpringMVC</code>默认提供的是<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code>，如果有需要我们也可以自定义一个<code>HandlerMapping</code>实现来处理请求。</p><p>接着一路跟踪源码，直到<code>AbstractHandlerMethodMapping#lookupHandlerMethod(String lookupPath, HttpServletRequest request)</code>方法，就可以看到具体的实现了。</p><ul><li>AbstractHandlerMethodMapping.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先直接使用URI进行匹配，适用于没使用通配符修饰的接口路径，对应urlLookup</span></span><br><span class=\"line\">List&lt;T&gt; directPathMatches = <span class=\"keyword\">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (directPathMatches != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//路径匹配到之后，还要根据method、header、consume、produce等等条件继续进行匹配</span></span><br><span class=\"line\">    addMatchingMappings(directPathMatches, matches, request);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (matches.isEmpty()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果没匹配到，再通过通配符的方式去匹配，对应mappingLookup</span></span><br><span class=\"line\">    addMatchingMappings(<span class=\"keyword\">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>至此与 RequestMappingHandlerMapping 有关的请求流程就已经介绍完了，最后再附上一张类图：</p><p><img src=\"/2020/06/22/custom-springmvc-requestmappinghandlermapping/2020-06-23-15-38-35.png\" alt></p><p>大部分的实现逻辑都在父类<code>AbstractHandlerMethodMapping</code>中。</p><h2 id=\"自定义-RequestMappingHandlerMapping\"><a href=\"#自定义-RequestMappingHandlerMapping\" class=\"headerlink\" title=\"自定义 RequestMappingHandlerMapping\"></a>自定义 RequestMappingHandlerMapping</h2><p>终于步入主题了，在了解<code>RequestMappingHandlerMapping</code>的大概的原理之后，就很清楚的如何来魔改<code>RequestMappingHandlerMapping</code>。</p><h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>项目中有一个<code>BaseController</code>基础类，当有新的需求开发时只需要继承该类就会拥有对应的<code>CRUD</code>接口，例如：</p><ul><li>BaseController.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseController</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">insert</span><span class=\"params\">(@Validated @RequestBody T vo)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PutMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">update</span><span class=\"params\">(@PathVariable @NotNull String id, @RequestBody @Validated T vo)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DeleteMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">delete</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">get</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>AppController.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/app\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppController</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseController</span>&lt;<span class=\"title\">App</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>AppController</code>就拥有了基本的<code>CRUD</code>接口功能，但是在某些情况的时候我需要屏蔽掉某个接口，可以通过重写方法来实现：</p><ul><li>AppController.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/app\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppController</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseController</span>&lt;<span class=\"title\">App</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//屏蔽get接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">get</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样实现其实也没啥问题，不过会占用一个路由，如果想重写这个接口，并且返回不同的响应体，就实现不了了，例如：</p><ul><li>重写父类方法编译不通过，因为泛型不兼容<code>Result&lt;App&gt;!=Result&lt;AppDetailDTO&gt;</code></li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回特殊的AppDetailDTO</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;AppDetailDTO&gt; <span class=\"title\">get</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>屏蔽父类接口，并声明一个新的方法来实现</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//屏蔽get接口</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">get</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明一个新方法来实现</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"/detail/&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;AppDetailDTO&gt; <span class=\"title\">getDetail</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过重新定义一个新的<code>路由</code>来实现，虽然说可以达到目的，但是感觉不够优雅，<code>/{id}</code>路由白白就浪费了，这个时候就只能通过自定义<code>RequestMappingHandlerMapping</code>来实现了。</p><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>通过上面的分析可以得知，在应用启动时<code>RequestMappingHandlerMapping</code>会去扫描所有的<code>handle</code>进行关系映射，可不可以实现一个注解，在扫描某个方法时，如果有该注解修饰的时候就跳过。</p><p>根据源码可以得知<code>getMappingForMethod</code>，是扫描<code>method</code>的处理入口，方法签名如下：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> RequestMappingInfo <span class=\"title\">getMappingForMethod</span><span class=\"params\">(Method method, Class&lt;?&gt; handlerType)</span></span></span><br></pre></td></tr></table></figure><p>这个方法可以拿到<code>Method</code>，只有重写该方法并且判断<code>Method</code>上有自定义的注解修饰直接返回 null 就可以达到取消路由注册的目的了。</p><h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>定义一个<code>@Disable</code>注解，用于标识方法不进行路由注册：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.METHOD)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Disable &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>WebMvcRegistrations</code>接口来自定义<code>RequestMappingHandlerMapping</code>类，并重写<code>getMappingForMethod</code>方法：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnWebApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebAutoConfiguration</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcRegistrations</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RequestMappingHandlerMapping <span class=\"title\">getRequestMappingHandlerMapping</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RequestMappingHandlerMapping() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> RequestMappingInfo <span class=\"title\">getMappingForMethod</span><span class=\"params\">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果方法上有@Disable注解，直接返回null</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (AnnotationUtils.findAnnotation(method, Disable<span class=\"class\">.<span class=\"keyword\">class</span>) !</span>= <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//否则还是按照以前的逻辑进行处理</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.getMappingForMethod(method, handlerType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这样之前的需求就可以解决了：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//屏蔽get接口</span></span><br><span class=\"line\"><span class=\"meta\">@Disable</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;T&gt; <span class=\"title\">get</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明一个新方法来实现，并且路由不变</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">\"&#123;id&#125;\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result&lt;AppDetailDTO&gt; <span class=\"title\">getDetail</span><span class=\"params\">(@PathVariable @NotNull String id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>父类的方法用<code>@Disable</code>注解修饰了，SpringMVC 并不会加载这个路由，在项目重启的时候就不会报错提示有两个相同的路由存在。</p><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>不要为了看源码而看源码，而是带着问题去看框架的源码才是有意义的。</p>","categories":["后端"],"tags":["java","spring"]},{"title":"使用免费的HTTPS证书","url":"/2019/08/14/free-ssl-cert/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>众所周知 HTTPS 是保证 HTTP 通讯安全的协议，网站启用 HTTPS 可以避免很多安全性的问题， 而且 Chrome 浏览器 从 68 版本开始直接将 HTTP 网站标记为不安全了。</p><p>所以把网站升级成 HTTPS 自然是大势所趋，不过启用 HTTPS 有个最重要的问题是 HTTPS 证书<code>要花钱</code>！如果每年额外花钱去购买 HTTPS 证书，那也是一笔很大的开销。那么有没有免费的<code>HTTPS</code>证书可以用呢，查了下资料有个叫<a href=\"https://letsencrypt.org\" target=\"_blank\" rel=\"noopener\"><code>Let’s Encrypt</code></a>的项目就提供了免费签发 HTTPS 证书的服务，这里记录下如何使用<code>Let’s Encrypt</code>来签发证书。</p><a id=\"more\"></a><h2 id=\"certbot-介绍\"><a href=\"#certbot-介绍\" class=\"headerlink\" title=\"certbot 介绍\"></a>certbot 介绍</h2><p><code>certbot</code>是用于从 Let’s Encrypt 获取证书的命令行工具，代码开源在<a href=\"https://github.com/certbot/certbot/\" target=\"_blank\" rel=\"noopener\">github</a>上。</p><p>使用<code>certbot</code>命令行工具可以轻松的实现<code>HTTPS证书</code>签发，在签发证书之前，需要证明签发的域名是属于你控制的，目前<code>certbot</code>有两种验证方式：</p><ol><li><p>HTTP<br>HTTP 方式就是<code>certbot</code>会生成一个特定的文件名和文件内容，要求放在你对应域名下对应路径(<code>/.well-known/acme-challenge/</code>)下，然后<code>certbot</code>再通过 HTTP 请求访问到此文件，并且文件内容与生成时候的一致。<br><br></p><p>例如：<code>certbot</code>生成文件名<code>check</code>和内容<code>!@#$%^</code>，你需要申请的域名为<code>baidu.com</code>，则<code>certbot</code>访问<code>http://baidu.com/.well-known/acme-challenge/check</code>来校验是否与生成的内容一致。</p></li><li><p>DNS<br>DNS 则是<code>certbot</code>生成一段特定的文本，要求在你对应域名中配置一条对应子域名(<code>_acme-challenge</code>)的<code>TXT</code>类型解析记录。<br><br></p><p>例如：<code>certbot</code>生成内容<code>!@#$%^</code>，你需要申请的域名为<code>baidu.com</code>，则需要添加一条<code>_acme-challenge.baidu.com</code>的<code>TXT</code>类型解析记录，值为之前生成的内容。</p></li></ol><p>在域名验证通过之后，<code>certbot</code>就可以签发<code>HTTPS</code>证书了，注意在此验证步骤基础上，<code>certbot</code>提供了很多开箱即用的自动验证方案，但是都不符合我的需求，原因是我需要支持<code>通配符</code>域名的证书，但是这种证书只支持<code>DNS</code>验证方式，而官方提供的<code>DNS</code>插件中并没有支持我用的<code>阿里云DNS</code>，所以只能自己去实现 阿里云的 DNS 自动校验。</p><h2 id=\"使用-certbot-签发-HTTPS-证书\"><a href=\"#使用-certbot-签发-HTTPS-证书\" class=\"headerlink\" title=\"使用 certbot 签发 HTTPS 证书\"></a>使用 certbot 签发 HTTPS 证书</h2><p>通过<a href=\"https://certbot.eff.org\" target=\"_blank\" rel=\"noopener\">官网教程</a>可以选择对应操作系统，并获取安装步骤：</p><p><img src=\"/2019/08/14/free-ssl-cert/2019-08-14-15-47-58.png\" alt></p><p>这里我选择的<code>Debian 9</code>，根据官网的提示进行安装：</p><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install certbot -t stretch-backports</span><br></pre></td></tr></table></figure><p><code>注：如果install失败可以先执行下 apt-get update</code></p><p>开始签发证书</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certbot certonly --cert-name pdown.org -d *.pdown.org,*.proxyee-down.com --manual --register-unsafely-without-email  --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure><p>这里签发了一个支持<code>*.pdown.org</code>和<code>*.proxyee-down.com</code>通配符域名的证书，注意如果是通配符域名证书需要指定<code>--server https://acme-v02.api.letsencrypt.org/directory</code></p><p>示例：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Saving debug log to /var/log/letsencrypt/letsencrypt.log</span><br><span class=\"line\">Plugins selected: Authenticator manual, Installer None</span><br><span class=\"line\">Registering without email!</span><br><span class=\"line\"></span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Please read the Terms of Service at</span><br><span class=\"line\">https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must</span><br><span class=\"line\">agree in order to register with the ACME server at</span><br><span class=\"line\">https://acme-v02.api.letsencrypt.org/directory</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">(A)gree/(C)ancel: A</span><br><span class=\"line\">Obtaining a new certificate</span><br><span class=\"line\">Performing the following challenges:</span><br><span class=\"line\">dns-01 challenge for pdown.org</span><br><span class=\"line\">dns-01 challenge for proxyee-down.com</span><br><span class=\"line\"></span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">NOTE: The IP of this machine will be publicly logged as having requested this</span><br><span class=\"line\">certificate. If you&apos;re running certbot in manual mode on a machine that is not</span><br><span class=\"line\">your server, please ensure you&apos;re okay with that.</span><br><span class=\"line\"></span><br><span class=\"line\">Are you OK with your IP being logged?</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">(Y)es/(N)o: Y</span><br><span class=\"line\"></span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Please deploy a DNS TXT record under the name</span><br><span class=\"line\">_acme-challenge.pdown.org with the following value:</span><br><span class=\"line\"></span><br><span class=\"line\">Axdqtserd184wvJc86Dxen386UXqbK2wrgb-*******</span><br><span class=\"line\"></span><br><span class=\"line\">Before continuing, verify the record is deployed.</span><br><span class=\"line\">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class=\"line\">Press Enter to Continue</span><br></pre></td></tr></table></figure><p>这里会生成一串随机字符并阻塞住，需要去设置一条对应的 TXT 类型的 DNS 解析记录再继续，在设置好之后可以用<code>nslookup</code>进行本地验证：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nslookup -type=txt _acme-challenge.pdown.org</span><br><span class=\"line\">服务器:  UnKnown</span><br><span class=\"line\">Address:  192.168.200.200</span><br><span class=\"line\"></span><br><span class=\"line\">非权威应答:</span><br><span class=\"line\">_acme-challenge.pdown.org       text =</span><br><span class=\"line\"></span><br><span class=\"line\">        &quot;Tit0SAHaO3MVZ4S-d6CjKLv6Z-********&quot;</span><br></pre></td></tr></table></figure><p>本地验证通过之后按回车键继续，接着 Let’s Encrypt 就会校验这个 DNS 解析记录是否正确，校验通过后就会进行下一个域名的验证直到全部验证通过。</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Waiting for verification...</span><br><span class=\"line\">Cleaning up challenges</span><br><span class=\"line\"></span><br><span class=\"line\">IMPORTANT NOTES:</span><br><span class=\"line\"> - Congratulations! Your certificate and chain have been saved at:</span><br><span class=\"line\">   /etc/letsencrypt/live/pdown.org/fullchain.pem</span><br><span class=\"line\">   Your key file has been saved at:</span><br><span class=\"line\">   /etc/letsencrypt/live/pdown.org/privkey.pem</span><br><span class=\"line\">   Your cert will expire on 2019-12-02. To obtain a new or tweaked</span><br><span class=\"line\">   version of this certificate in the future, simply run certbot</span><br><span class=\"line\">   again. To non-interactively renew *all* of your certificates, run</span><br><span class=\"line\">   &quot;certbot renew&quot;</span><br><span class=\"line\"> - If you like Certbot, please consider supporting our work by:</span><br><span class=\"line\"></span><br><span class=\"line\">   Donating to ISRG / Let&apos;s Encrypt:   https://letsencrypt.org/donate</span><br><span class=\"line\">   Donating to EFF:                    https://eff.org/donate-le</span><br></pre></td></tr></table></figure><p>当验证通过的时候会输出证书生成的目录，里面会包含证书和对应的私钥，这里目录是<code>/etc/letsencrypt/live/pdown.org/</code>。</p><p>证书截图：<br><img src=\"/2019/08/14/free-ssl-cert/2019-09-03-14-49-10.png\" alt></p><p><img src=\"/2019/08/14/free-ssl-cert/2019-09-03-14-49-28.png\" alt></p><p>这样证书就生成好了，之后只需要把证书和私钥配置到<code>nginx</code>中就可以用<code>https</code>访问了。</p><h2 id=\"使用-certbot-hook-自动续签\"><a href=\"#使用-certbot-hook-自动续签\" class=\"headerlink\" title=\"使用 certbot hook 自动续签\"></a>使用 certbot hook 自动续签</h2><p>上面证书虽然是生成好了，但是证书的有效期只有三个月，意味着每过三个月就得重新签发一个新的证书，一不注意证书就过期了，而且每次手动签发都非常的繁琐需要去手动设置 DNS 解析，所以<code>certbot</code>提供了一种自动续签的方案：hook</p><p>在创建证书的时候<code>certbot</code>提供了两个<code>hook</code>参数：</p><ul><li>manual-auth-hook<br>指定用于验证域名的脚本文件</li><li>manual-cleanup-hook<br>指定用于清理的脚本文件，即验证完成之后</li></ul><p>通过自定义这两个脚本就可以做到自动续签了，文档参考<a href=\"https://certbot.eff.org/docs/using.html#pre-and-post-validation-hooks\" target=\"_blank\" rel=\"noopener\">pre-and-post-validation-hooks</a>。</p><p>在此基础上，官方已经提供了很多云厂商的自动续签方案，但是我用的阿里云官方并没有提供，于是参照官网文档，写了一个基于阿里云的自动续签脚本，在验证域名的脚本中通过阿里提供的 DNS API 添加一条域名解析记录，在验证完成之后再把刚刚那条域名解析记录删除，命令行调用如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">certbot certonly --cert-name pdown.org -d *.pdown.org,*.proxyee-down.com --manual --register-unsafely-without-email --manual-auth-hook /path/to/dns/authenticator.sh --manual-cleanup-hook /path/to/dns/cleanup.sh --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory</span><br></pre></td></tr></table></figure><p>为了方便使用，提供了一个<code>docker镜像</code>，通过环境变量将阿里云 API 调用的 AK 传递就可以生成和续签证书了。</p><ul><li>启动容器</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run \\</span><br><span class=\"line\">--name cert \\</span><br><span class=\"line\">-itd \\</span><br><span class=\"line\">-v /etc/letsencrypt:/etc/letsencrypt \\</span><br><span class=\"line\">-e ACCESS_KEY_ID=XXX \\</span><br><span class=\"line\">-e ACCESS_KEY_SECRET=XXX \\</span><br><span class=\"line\">liwei2633/certbot-aliyun</span><br></pre></td></tr></table></figure><ul><li>首次创建证书</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it cert ./create.sh *.pdown.org</span><br></pre></td></tr></table></figure><p>创建过程中会等待一段时间，来确保 dns 记录生效，完成之后在<code>/etc/letsencrypt/live</code>目录下可以找到对应的证书文件</p><ul><li>续签证书</li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec cert ./renew.sh</span><br></pre></td></tr></table></figure><p>代码开源在<a href=\"https://github.com/monkeyWie/certbot-dns-aliyun\" target=\"_blank\" rel=\"noopener\">github</a>，欢迎 start。</p>","categories":["运维"],"tags":["https","docker","go","shell"]},{"title":"Go语言之交叉编译","url":"/2019/10/10/go-cross-compile/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>当初学习 go 语言的原因之一就是看中了 go 可以直接编译成机器码运行，并且支持跨操作系统的交叉编译，这对开发跨操作系统软件提供了极大的便利，这篇文章目的就是记录下 go 是如何交叉编译的。</p><h2 id=\"交叉编译\"><a href=\"#交叉编译\" class=\"headerlink\" title=\"交叉编译\"></a>交叉编译</h2><p>go 语言里交叉编译支持非常多的操作系统，可以通过<code>go tool dist list</code>命令来查看支持的操作系统列表。</p><a id=\"more\"></a><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go tool dist list</span><br><span class=\"line\">aix/ppc64</span><br><span class=\"line\">android/386</span><br><span class=\"line\">android/amd64</span><br><span class=\"line\">android/arm</span><br><span class=\"line\">android/arm64</span><br><span class=\"line\">darwin/386</span><br><span class=\"line\">darwin/amd64</span><br><span class=\"line\">darwin/arm</span><br><span class=\"line\">darwin/arm64</span><br><span class=\"line\">dragonfly/amd64</span><br><span class=\"line\">freebsd/386</span><br><span class=\"line\">freebsd/amd64</span><br><span class=\"line\">freebsd/arm</span><br><span class=\"line\">illumos/amd64</span><br><span class=\"line\">js/wasm</span><br><span class=\"line\">linux/386</span><br><span class=\"line\">linux/amd64</span><br><span class=\"line\">linux/arm</span><br><span class=\"line\">linux/arm64</span><br><span class=\"line\">linux/mips</span><br><span class=\"line\">linux/mips64</span><br><span class=\"line\">linux/mips64le</span><br><span class=\"line\">linux/mipsle</span><br><span class=\"line\">linux/ppc64</span><br><span class=\"line\">linux/ppc64le</span><br><span class=\"line\">linux/s390x</span><br><span class=\"line\">nacl/386</span><br><span class=\"line\">nacl/amd64p32</span><br><span class=\"line\">nacl/arm</span><br><span class=\"line\">netbsd/386</span><br><span class=\"line\">netbsd/amd64</span><br><span class=\"line\">netbsd/arm</span><br><span class=\"line\">netbsd/arm64</span><br><span class=\"line\">openbsd/386</span><br><span class=\"line\">openbsd/amd64</span><br><span class=\"line\">openbsd/arm</span><br><span class=\"line\">openbsd/arm64</span><br><span class=\"line\">plan9/386</span><br><span class=\"line\">plan9/amd64</span><br><span class=\"line\">plan9/arm</span><br><span class=\"line\">solaris/amd64</span><br><span class=\"line\">windows/386</span><br><span class=\"line\">windows/amd64</span><br><span class=\"line\">windows/arm</span><br></pre></td></tr></table></figure><p>编译的时候只需要指定环境变量<code>GOOS</code>(系统内核)和<code>GOARCH</code>(CPU 架构)即可进行交叉编译。</p><h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><ul><li>Windows 上编译 Mac 和 Linux 上 64 位可执行程序</li></ul><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SET</span> CGO_ENABLED=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">SET</span> GOOS=darwin</span><br><span class=\"line\"><span class=\"built_in\">SET</span> GOARCH=amd64</span><br><span class=\"line\">go build main.go</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SET</span> CGO_ENABLED=<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">SET</span> GOOS=linux</span><br><span class=\"line\"><span class=\"built_in\">SET</span> GOARCH=amd64</span><br><span class=\"line\">go build main.go</span><br></pre></td></tr></table></figure><ul><li>Linux 上编译 Mac 和 Windows 上 64 位可执行程序</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go</span><br><span class=\"line\">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><ul><li>Mac 上编译 Linux 和 Windows 上 64 位可执行程序</li></ul><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br><span class=\"line\">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure><h3 id=\"cgo-程序交叉编译\"><a href=\"#cgo-程序交叉编译\" class=\"headerlink\" title=\"cgo 程序交叉编译\"></a>cgo 程序交叉编译</h3><p>上面的示例都是基于程序里没有使用<code>cgo</code>的情况下进行的，可以看到<code>CGO_ENABLED=0</code>这个选项就是关闭<code>cgo</code>，因为 go 的交叉编译是不支持<code>cgo</code>的，如果程序里使用到了<code>cgo</code>时要进行交叉编译就没这么简单了，需要安装一个跨平台的 C/C++ 编译器才可能实现交叉编译。</p><p>好在已经有大佬把常用的编译环境都做成到 docker 镜像了，并且提供命令行工具让我们很方便的进行交叉编译，这个工具就是<a href=\"https://github.com/karalabe/xgo\" target=\"_blank\" rel=\"noopener\">https://github.com/karalabe/xgo</a>，但是此仓库作者好像不怎么更新了，并且不支持<code>go mod</code>，于是我找到了另一位大佬的 fork: <a href=\"https://github.com/techknowlogick/xgo\" target=\"_blank\" rel=\"noopener\">https://github.com/techknowlogick/xgo</a>，支持<code>go mod</code>并且支持最新的<code>go 1.13</code>版本。</p><h3 id=\"xgo-示例\"><a href=\"#xgo-示例\" class=\"headerlink\" title=\"xgo 示例\"></a>xgo 示例</h3><p>首先要保证机器上有安装 <code>golang</code> 和 <code>docker</code>，接着按照教程来进行。</p><ol><li>拉取镜像</li></ol><p>镜像比较大，1 个多 G，拉取要一点时间</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull techknowlogick/xgo:latest</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>安装 xgo</li></ol><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get src.techknowlogick.com/xgo</span><br></pre></td></tr></table></figure><ol start=\"3\"><li>准备代码</li></ol><p>这里引用了<code>go-sqlite3</code>这个库，里面用到了<code>cgo</code>。</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"database/sql\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"log\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"os\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t_ <span class=\"string\">\"github.com/mattn/go-sqlite3\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tos.Remove(<span class=\"string\">\"./foo.db\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tdb, err := sql.Open(<span class=\"string\">\"sqlite3\"</span>, <span class=\"string\">\"./foo.db\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> db.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\tsqlStmt := <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">\tcreate table foo (id integer not null primary key, name text);</span></span><br><span class=\"line\"><span class=\"string\">\tdelete from foo;</span></span><br><span class=\"line\"><span class=\"string\">\t`</span></span><br><span class=\"line\">\t_, err = db.Exec(sqlStmt)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">\"%q: %s\\n\"</span>, err, sqlStmt)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttx, err := db.Begin()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstmt, err := tx.Prepare(<span class=\"string\">\"insert into foo(id, name) values(?, ?)\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> stmt.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++ &#123;</span><br><span class=\"line\">\t\t_, err = stmt.Exec(i, fmt.Sprintf(<span class=\"string\">\"こんにちわ世界%03d\"</span>, i))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttx.Commit()</span><br><span class=\"line\"></span><br><span class=\"line\">\trows, err := db.Query(<span class=\"string\">\"select id, name from foo\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rows.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> rows.Next() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> id <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> name <span class=\"keyword\">string</span></span><br><span class=\"line\">\t\terr = rows.Scan(&amp;id, &amp;name)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Println(id, name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = rows.Err()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstmt, err = db.Prepare(<span class=\"string\">\"select name from foo where id = ?\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> stmt.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> name <span class=\"keyword\">string</span></span><br><span class=\"line\">\terr = stmt.QueryRow(<span class=\"string\">\"3\"</span>).Scan(&amp;name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(name)</span><br><span class=\"line\"></span><br><span class=\"line\">\t_, err = db.Exec(<span class=\"string\">\"delete from foo\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t_, err = db.Exec(<span class=\"string\">\"insert into foo(id, name) values(1, 'foo'), (2, 'bar'), (3, 'baz')\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\trows, err = db.Query(<span class=\"string\">\"select id, name from foo\"</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> rows.Close()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> rows.Next() &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> id <span class=\"keyword\">int</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> name <span class=\"keyword\">string</span></span><br><span class=\"line\">\t\terr = rows.Scan(&amp;id, &amp;name)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tlog.Fatal(err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Println(id, name)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\terr = rows.Err()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Fatal(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ol start=\"4\"><li>编译</li></ol><p>在项目目录下运行，编译 Mac,Windows,Linux 下的 64 位可执行程序,<code>-ldflags=&quot;-w -s&quot;</code>选项可以减小编译后的程序体积。</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">xgo -targets=darwin/amd64,windows/amd64,linux/amd64 -ldflags=<span class=\"string\">\"-w -s\"</span> .</span><br></pre></td></tr></table></figure><p>这样使用<code>xgo</code>轻松就完成了多操作系统的交叉编译，并且<code>xgo</code>还有很多的特性，可以自行去 github 上看看。</p><h2 id=\"使用-xgo-碰到的问题\"><a href=\"#使用-xgo-碰到的问题\" class=\"headerlink\" title=\"使用 xgo 碰到的问题\"></a>使用 xgo 碰到的问题</h2><p>上面提到使用<code>techknowlogick/xgo</code>可以解决 go mod 交叉编译的问题，但是默认只会编译项目根目录下的 <code>main.go</code> 文件，例如：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── main.go</span><br><span class=\"line\">└── README.md</span><br></pre></td></tr></table></figure><p>但是我需要编译指定目录下的<code>main.go</code>文件，例如：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── cmd</span><br><span class=\"line\">│   └── main.go</span><br><span class=\"line\">├── main.go</span><br><span class=\"line\">└── README.md</span><br></pre></td></tr></table></figure><p>需要编译 cmd/main.go，通过查看 xgo 源码可以看到有个<code>-pkg</code>的参数就是用于指定编译路径的，遂尝试使用<code>-pkg</code>进行交叉编译：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xgo -targets=darwin/amd64,windows/amd64,linux/amd64 -ldflags=&quot;-w -s&quot; -pkg=cmd/main.go .</span><br></pre></td></tr></table></figure><p>然而并没有编译成功，然后去看了一下源码，最后在<a href=\"https://github.com/techknowlogick/xgo/blob/master/docker/base/build.sh#L154\" target=\"_blank\" rel=\"noopener\">build.sh:154</a>这行代码发现，如果启用了 go mod 的话，pkg 参数就会失效，为什么要这样做我也没太明白，不过既然知道原因了那就 <a href=\"https://github.com/monkeyWie/xgo\" target=\"_blank\" rel=\"noopener\">fork</a> 一份修复吧。</p><p>最终代码为：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Go module-based builds error with 'cannot find main module'</span></span><br><span class=\"line\"><span class=\"comment\"># when $PACK is defined</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"string\">\"<span class=\"variable\">$USEMODULES</span>\"</span> = <span class=\"literal\">true</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  NAME=`sed -n <span class=\"string\">'s/module\\ \\(.*\\)/\\1/p'</span> /<span class=\"built_in\">source</span>/go.mod`</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Support go module package</span></span><br><span class=\"line\">PACK_RELPATH=<span class=\"string\">\"./<span class=\"variable\">$PACK</span>\"</span></span><br></pre></td></tr></table></figure><p>顺便把所有的 Dockerfile 更新了一遍，把过时的<code>MAINTAINER</code>替换成<code>LABEL MAINTAINER=&quot;&quot;</code>，接着就开始构建 docker 镜像：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker build -t liwei2633/xgo:base docker/base</span><br></pre></td></tr></table></figure><p>但是由于国内的网络问题，经常有请求超时导致构建失败，所以一次都没构建成功过，然后想起来前几天申请的<code>github actions</code>内测资格通过了，可以试试<code>github actions</code>,因为<code>github actions</code>用的国外网络环境，应该构建不成问题,于是按照官方文档写了一个构建配置<code>.github/workflows/main.yml</code>：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">name: CI</span><br><span class=\"line\"></span><br><span class=\"line\"># 当master分支有push时，并且docker/base目录下文件发生变动时触发构建</span><br><span class=\"line\">on:</span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">      - master</span><br><span class=\"line\">    paths:</span><br><span class=\"line\">      - &quot;docker/base/*&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build:</span><br><span class=\"line\">    runs-on: ubuntu-latest</span><br><span class=\"line\"></span><br><span class=\"line\">    steps:</span><br><span class=\"line\">\t  # 拉取源码</span><br><span class=\"line\">      - name: Checkout source</span><br><span class=\"line\">        uses: actions/checkout@v1</span><br><span class=\"line\">\t  # 登录docker hub</span><br><span class=\"line\">      - name: Docker login</span><br><span class=\"line\">        run: docker login -u liwei2633 -p $&#123;&#123; secrets.DOCKER_HUB_PWD &#125;&#125;</span><br><span class=\"line\">      - name: Docker build base</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          docker build -t liwei2633/xgo:base ./docker/base</span><br><span class=\"line\">          docker push liwei2633/xgo:base</span><br><span class=\"line\">      - name: Docker build other</span><br><span class=\"line\">        run: |</span><br><span class=\"line\">          docker build -t liwei2633/xgo:go-1.12.10 ./docker/go-1.12.10</span><br><span class=\"line\">          docker push liwei2633/xgo:go-1.12.10</span><br><span class=\"line\">          docker build -t liwei2633/xgo:go-1.12.x ./docker/go-1.12.x</span><br><span class=\"line\">          docker push liwei2633/xgo:go-1.12.x</span><br><span class=\"line\">          docker build -t liwei2633/xgo:go-1.13.1 ./docker/go-1.13.1</span><br><span class=\"line\">          docker push liwei2633/xgo:go-1.13.1</span><br><span class=\"line\">          docker build -t liwei2633/xgo:go-1.13.x ./docker/go-1.13.x</span><br><span class=\"line\">          docker push liwei2633/xgo:go-1.13.x</span><br><span class=\"line\">          docker build -t liwei2633/xgo:go-latest ./docker/go-latest</span><br><span class=\"line\">          docker push liwei2633/xgo:go-latest</span><br></pre></td></tr></table></figure><p>然后推送代码触发构建，这次构建成功了，但是非常的耗时大概要 30 多分钟，得想办法优化优化，由于<code>github actions</code>是不支持缓存的，即每次构建都是一个全新的虚拟机，没法入手，只能通过 docker 的缓存机制来进行优化了，通过 google 发现有一个<code>--cache-from</code>的构建参数，可以指定构建缓存镜像来源，于是构建流程改造成先<code>pull</code>历史镜像，再指定历史镜像作为构建缓存镜像来进行构建，具体脚本如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull liwei2633/xgo:base</span><br><span class=\"line\">docker build --cache-from=liwei2633/xgo:base -t liwei2633/xgo:base ./docker/base</span><br><span class=\"line\">docker push liwei2633/xgo:base</span><br></pre></td></tr></table></figure><p>这样的话因为下载镜像的耗时远比 Dockerfile 里的各种<code>apt-get install</code>耗时要小，所以如果有了第一次构建的镜像之后，就可以通过 docker 的缓存机制来跳过许多耗时的步骤，就比如 xgo 中 Dockerfile 的一个<code>RUN</code>语句：</p><figure class=\"highlight docker\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"bash\"> \\</span></span><br><span class=\"line\"><span class=\"bash\">  apt-get update &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">  apt-get install -y automake autogen build-essential ca-certificates                    \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-arm-linux-gnueabi g++-5-arm-linux-gnueabi libc6-dev-armel-cross                \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-arm-linux-gnueabihf g++-5-arm-linux-gnueabihf libc6-dev-armhf-cross            \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-aarch64-linux-gnu g++-5-aarch64-linux-gnu libc6-dev-arm64-cross                \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-mips-linux-gnu g++-5-mips-linux-gnu libc6-dev-mips-cross                       \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-mipsel-linux-gnu g++-5-mipsel-linux-gnu libc6-dev-mipsel-cross                 \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-mips64-linux-gnuabi64 g++-5-mips64-linux-gnuabi64 libc6-dev-mips64-cross       \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-mips64el-linux-gnuabi64 g++-5-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-5-multilib g++-5-multilib gcc-mingw-w64 g++-mingw-w64 clang llvm-dev             \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-arm-linux-gnueabi g++-6-arm-linux-gnueabi libc6-dev-armel-cross                \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-arm-linux-gnueabihf g++-6-arm-linux-gnueabihf libc6-dev-armhf-cross            \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-aarch64-linux-gnu g++-6-aarch64-linux-gnu libc6-dev-arm64-cross                \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-mips-linux-gnu g++-6-mips-linux-gnu libc6-dev-mips-cross                       \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-mipsel-linux-gnu g++-6-mipsel-linux-gnu libc6-dev-mipsel-cross                 \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-mips64-linux-gnuabi64 g++-6-mips64-linux-gnuabi64 libc6-dev-mips64-cross       \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-mips64el-linux-gnuabi64 g++-6-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \\</span></span><br><span class=\"line\"><span class=\"bash\">    gcc-6-multilib gcc-7-multilib g++-6-multilib gcc-mingw-w64 g++-mingw-w64 clang llvm-dev \\</span></span><br><span class=\"line\"><span class=\"bash\">    libtool libxml2-dev uuid-dev libssl-dev swig openjdk-8-jdk pkg-config patch \\</span></span><br><span class=\"line\"><span class=\"bash\">    make xz-utils cpio wget zip unzip p7zip git mercurial bzr texinfo help2man cmake     \\</span></span><br><span class=\"line\"><span class=\"bash\">    --no-install-recommends</span></span><br></pre></td></tr></table></figure><p>这种情况下使用缓存无疑可以节省非常多的时间，修改之后提交，再看看构建记录：<br><img src=\"/2019/10/10/go-cross-compile/2019-10-14-14-31-01.png\" alt></p><p>可以看到已经走了缓存，最终耗时在 10 分钟左右节省了 2/3 的时间，<code>github actions</code>真香！！！</p><p>最后把<a href=\"https://github.com/monkeyWie/xgo/blob/master/xgo.go\" target=\"_blank\" rel=\"noopener\">xgo.go</a>代码修改一下，顺带修复了个 BUG(docker image 检测问题)，推到 github 上。</p><p>测试使用：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/monkeyWie/xgo</span><br><span class=\"line\">xgo -targets=windows/amd64,linux/amd64,darwin/amd64 -ldflags=&quot;-w -s&quot; -pkg=cmd/main.go .</span><br></pre></td></tr></table></figure><p>成功编译，完结撒花！</p><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>感谢 <a href=\"https://github.com/karalabe/xgo\" target=\"_blank\" rel=\"noopener\">https://github.com/karalabe/xgo</a>和<a href=\"https://github.com/techknowlogick/xgo\" target=\"_blank\" rel=\"noopener\">https://github.com/techknowlogick/xgo</a>为 go 交叉编译做出的贡献，然后就是<code>github actions</code>真香，希望可以早日推出正式版。</p>","categories":["后端"],"tags":["go"]},{"title":"服务器推送技术与websocket协议","url":"/2019/08/08/server-push-and-websocket/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>websocket 作为现代浏览器的长连接标准，可以很好的解决浏览器与服务器实时通讯的问题，那么在 websocket 出现之前是怎么解决这个问题的呢？首先来回顾一下在此之前浏览器和服务器的”长连接”之路。</p><h2 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h2><p>在 websocket 协议出来之前，主要是有三种方向去实现类似 websocket 的功能的。</p><h3 id=\"Flash\"><a href=\"#Flash\" class=\"headerlink\" title=\"Flash\"></a>Flash</h3><p>flash 支持 socket 通讯功能，基于 flash 可以很简单的实现与服务器建立通讯。</p><ul><li>优点：开发简单、兼容性高</li><li>缺点：需要浏览器启用 flash 功能，并且逐渐被浏览器淘汰</li></ul><h3 id=\"AJAX-Polling\"><a href=\"#AJAX-Polling\" class=\"headerlink\" title=\"AJAX Polling\"></a>AJAX Polling</h3><p>浏览器使用 ajax 去轮询服务器，服务器有内容就返回，轮询也分为短轮询和长轮询。</p><a id=\"more\"></a><h4 id=\"短轮询\"><a href=\"#短轮询\" class=\"headerlink\" title=\"短轮询\"></a>短轮询</h4><p>短轮询即浏览器通过 ajax 按照一定时间的间隔去请求服务器，服务器会立即响应，不管有没有可用数据。</p><ul><li><p>流程图：<br><img src=\"/2019/08/08/server-push-and-websocket/2019-08-08-10-08-54.png\" alt></p></li><li><p>优点：短链接、服务器处理方便。</p></li><li>缺点：实时性低、很多无效请求、性能开销大</li></ul><h4 id=\"长轮询\"><a href=\"#长轮询\" class=\"headerlink\" title=\"长轮询\"></a>长轮询</h4><p>长短轮询则是浏览器通过 ajax 与服务器建立连接，服务器在没有数据返回时一直阻塞着，直到有数据之后才返回响应。</p><ul><li><p>流程图：<br><img src=\"/2019/08/08/server-push-and-websocket/2019-08-08-10-22-13.png\" alt></p></li><li><p>优点：实时性高</p></li><li>缺点：每个连接只能返回一次数据</li></ul><h3 id=\"COMET\"><a href=\"#COMET\" class=\"headerlink\" title=\"COMET\"></a>COMET</h3><p>comet 也是常用的一种服务器推送技术，主要的原理是通过<code>HTTP Chunked</code>响应，将消息源源不断的推送给浏览器，通常情况下服务器返回的响应内容都是定长的，会使用<code>Content-Length</code>来指定响应报文的长度，而<code>Chunked</code>编码的响应则是通过一种特殊的编码，只要浏览器没有遇到结束标识，就会边解析边执行对应的响应内容。</p><ul><li>chunked 编码报文示例:</li></ul><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/html</span><br><span class=\"line\"><span class=\"attribute\">Date</span>: Thu, 08 Aug 2019 02:50:06 GMT</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">11</span></span><br><span class=\"line\"><span class=\"attribute\">callback('data1')</span></span><br><span class=\"line\"><span class=\"attribute\">11</span></span><br><span class=\"line\"><span class=\"attribute\">callback('data2')</span></span><br><span class=\"line\"><span class=\"attribute\">0</span></span><br></pre></td></tr></table></figure><p>报文格式为：</p><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;length&gt;\\r\\n</span><br><span class=\"line\">&lt;chunk data&gt;\\r\\n</span><br><span class=\"line\">&lt;length&gt;\\r\\n</span><br><span class=\"line\">&lt;chunk data&gt;\\r\\n</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"attribute\">0\\r\\n</span></span><br></pre></td></tr></table></figure><p>由 16 进制的数字来标识一个<code>chunk data</code>数据的长度，在读取到<code>0\\r\\n</code>时结束，通过一直读取<code>chunk data</code>来执行 js 代码，从而向客户端推送数据。</p><ul><li>go 语言实现：</li></ul><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">\"/push\"</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\tw.Header().Set(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/html\"</span>)</span><br><span class=\"line\">\t\tflusher := w.(http.Flusher)</span><br><span class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"&lt;script&gt;console.log('data1')&lt;/script&gt;\"</span>))</span><br><span class=\"line\">\t\tflusher.Flush()</span><br><span class=\"line\">\t\t<span class=\"comment\">// 延迟一秒，以便观察浏览器的边解析边执行</span></span><br><span class=\"line\">\t\ttime.Sleep(time.Second)</span><br><span class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">\"&lt;script&gt;console.log('data2')&lt;/script&gt;\"</span>))</span><br><span class=\"line\">\t\tflusher.Flush()</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"通过-iframe-实现\"><a href=\"#通过-iframe-实现\" class=\"headerlink\" title=\"通过 iframe 实现\"></a>通过 iframe 实现</h4><p>iframe 实现是通过隐藏一个<code>&lt;iframe&gt;</code>，通过<code>iframe</code>连接到服务器，服务器响应带有<code>&lt;script&gt;</code>标签的内容，通过动态执行 js 代码从而实现服务器推送数据。</p><p><strong>前端示例：</strong></p><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">style</span>=<span class=\"string\">\"visibility: hidden;\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/push\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>优点：兼容性高、实时性高、支持多次推送</li><li>缺点：一些浏览器会一直处于加载状态</li></ul><h4 id=\"通过-ajax-实现\"><a href=\"#通过-ajax-实现\" class=\"headerlink\" title=\"通过 ajax 实现\"></a>通过 ajax 实现</h4><p>ajax 实现是通过<code>onreadystatechange</code>回调，每次读取到一个<code>chunk data</code>时，都会执行一次<code>readyState=3</code>为的回调，通过这个机制也可以实现服务器推送数据。</p><p><strong>前端示例：</strong></p><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span></span><br><span class=\"line\"><span class=\"actionscript\">    xhr.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"/push\"</span>, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">var</span> received = <span class=\"number\">0</span>;</span></span><br><span class=\"line\"><span class=\"actionscript\">    xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123;</span></span><br><span class=\"line\">      if (xhr.readyState == 3) &#123;</span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"comment\">// 由于取responseText会把之前的响应一起拿到，所以要进行切分处理</span></span></span><br><span class=\"line\"><span class=\"actionscript\">        <span class=\"keyword\">var</span> response = xhr.responseText.substring(received);</span></span><br><span class=\"line\">        received += response.length;</span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.log(response);</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>优点：实时性高、支持多次推送、浏览器不会处于加载状态</li><li>缺点：兼容性低，一些浏览器不支持 readyState=3 回调</li></ul><h2 id=\"Websocket\"><a href=\"#Websocket\" class=\"headerlink\" title=\"Websocket\"></a>Websocket</h2><p>Websocket 是一种与 HTTP 不同的协议，两者都位与 OSI 模型的应用层， IETF 标准为<a href=\"https://tools.ietf.org/html/rfc6455\" target=\"_blank\" rel=\"noopener\">RFC 6455</a>。</p><p>WebSocket 是 HTML5 提供的一种在单个 TCP 连接上进行全双工通讯的协议。浏览器和服务器只需要做一个 HTTP 握手的动作，然后浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>Websocket 和之前的方案最大的区别是，它是可以支持双向通讯的。而之前的技术实现上如果客户端需要发送一个新的请求，就需要创建一个新的连接。</p><h3 id=\"示例：\"><a href=\"#示例：\" class=\"headerlink\" title=\"示例：\"></a>示例：</h3><ul><li>浏览器<br>浏览器上使用 Websocket 非常简单，下面看一段示例代码：</li></ul><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">\"wss://echo.websocket.org\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接成功</span></span><br><span class=\"line\">ws.onopen = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Connection open ...\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">  ws.send(<span class=\"string\">\"Hello WebSockets!\"</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">ws.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Received Message: \"</span> + evt.data);</span><br><span class=\"line\">  ws.close();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接关闭</span></span><br><span class=\"line\">ws.onclose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Connection closed.\"</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><ul><li>服务器</li></ul><p>现在基本上所有的服务器开发语言都有对 websocket 的支持，下面来看一段 go 编写的 websocket 服务器的示例代码，使用的是<code>github.com/gorilla/websocket</code>库：</p><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> upgrader = websocket.Upgrader&#123;</span><br><span class=\"line\">\tCheckOrigin: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(r *http.Request)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http.HandleFunc(<span class=\"string\">\"/ws\"</span>, <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// websocket握手处理</span></span><br><span class=\"line\">\tconn, err := upgrader.Upgrade(w, r, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Error(err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">    <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">    conn.WriteMessage(websocket.TextMessage,[]<span class=\"keyword\">byte</span>(<span class=\"string\">\"hello\"</span>))</span><br><span class=\"line\">    <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tmt, b, err := conn.ReadMessage()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> mt == websocket.TextMessage &#123;</span><br><span class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"Received Message: %s\\n\"</span>,<span class=\"keyword\">string</span>(b))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">log.Fatal(http.ListenAndServe(<span class=\"string\">\":8080\"</span>, <span class=\"literal\">nil</span>))</span><br></pre></td></tr></table></figure><h3 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h3><h4 id=\"流程图：\"><a href=\"#流程图：\" class=\"headerlink\" title=\"流程图：\"></a>流程图：</h4><p><img src=\"/2019/08/08/server-push-and-websocket/2019-08-08-13-44-29.png\" alt></p><h4 id=\"握手\"><a href=\"#握手\" class=\"headerlink\" title=\"握手\"></a>握手</h4><p>通过上面流程图可以看到，在建立 Websocket 连接时首先需要客户端和服务器需要完成一次握手，握手请求是使用 HTTP 协议，下面看一个例子：</p><ul><li>Handshake request</li></ul><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">ws://localhost:8800/</span> HTTP/1.1</span><br><span class=\"line\"><span class=\"attribute\">Host</span>: localhost</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: Upgrade</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span>: websocket</span><br><span class=\"line\"><span class=\"attribute\">Origin</span>: http://www.websocket-test.com</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Version</span>: 13</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Key</span>: GbHJKViBFhiUi4yT7CK3gA==</span><br></pre></td></tr></table></figure><p>请求详解：</p><ol><li>GET 请求的地址是以 ws://开头的地址。</li><li>请求头 Connection: Upgrade 表示这个连接需要升级。</li><li>请求头 Upgrade: websocket 表示升级到 websocket 协议。</li><li>请求头 Sec-WebSocket-Key 是用于标识这个连接，在服务器响应时需要通过这个 key 来做对应匹配，以防止恶意的连接，或者无意的连接。</li><li>请求头 Sec-WebSocket-Version 指定了客户端 WebSocket 的协议版本。</li></ol><ul><li>Handshake response</li></ul><figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">101</span> Switching Protocols</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span>: websocket</span><br><span class=\"line\"><span class=\"attribute\">Connection</span>: Upgrade</span><br><span class=\"line\"><span class=\"attribute\">Sec-WebSocket-Accept</span>: BcfEmZdVyUas6UtFTbjKohgqBs8=</span><br></pre></td></tr></table></figure><p>响应详解：</p><p>根据规范，在服务器接收到 websocket 握手请求时，如果支持客户端对应 WebSocket 协议版本时，同样需要返回<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>响应头，并且返回对应的<code>Sec-WebSocket-Accept</code>响应头。</p><p><code>Sec-WebSocket-Accept</code>的值通过握手请求中的<code>Sec-WebSocket-Key</code>计算出来，计算公式为：</p><ol><li>将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接。</li><li>通过 SHA1 计算出摘要，并转成 base64 字符串。</li></ol><p>伪代码：</p><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">base64(sha1(<span class=\"string\">`<span class=\"subst\">$&#123;Sec - WebSocket - Key&#125;</span>258EAFA5-E914-47DA-95CA-C5AB0DC85B11`</span>));</span><br></pre></td></tr></table></figure><h4 id=\"通讯格式\"><a href=\"#通讯格式\" class=\"headerlink\" title=\"通讯格式\"></a>通讯格式</h4><p>在握手完成之后即可开始双向通讯了，通讯报文格式如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> 0                   1                   2                   3</span><br><span class=\"line\"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">| |1|2|3|       |K|             |                               |</span><br><span class=\"line\">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">|     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">|                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">+-------------------------------+-------------------------------+</span><br><span class=\"line\">| Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">:                     Payload Data continued ...                :</span><br><span class=\"line\">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">|                     Payload Data continued ...                |</span><br><span class=\"line\">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ol><li><p>FIN: 占 1 个 bit</p><p>0：不是消息的最后一个分片</p><p>1：是消息的最后一个分片</p></li><li><p>RSV1, RSV2, RSV3：各占 1 个 bit</p><p>一般情况下全为 0。当客户端、服务端协商采用 WebSocket 扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。</p></li><li><p>Opcode: 4 个 bit</p><p>%x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；</p><p>%x1：表示这是一个文本帧（frame）；</p><p>%x2：表示这是一个二进制帧（frame）；</p><p>%x3-7：保留的操作代码，用于后续定义的非控制帧；</p><p>%x8：表示连接断开；</p><p>%x9：表示这是一个 ping 操作；</p><p>%xA：表示这是一个 pong 操作；</p><p>%xB-F：保留的操作代码，用于后续定义的控制帧。</p></li><li><p>Mask: 1 个 bit</p><p>表示是否要对数据载荷进行掩码异或操作。</p><p>0：否</p><p>1：是</p></li><li><p>Payload length: 7bit or 7 + 16bit or 7 + 64bit</p><p>表示传输数据的长度</p><p>当 length == [0,126)：数据的长度为 length 字节；</p><p>当 length == 126：后续 2 个字节代表一个 16 位的无符号整数，该无符号整数的值为数据的长度；</p><p>当 length == 127：后续 8 个字节代表一个 64 位的无符号整数（最高位为 0），该无符号整数的值为数据的长度。</p><blockquote><p>这么定义的目的是在传输数据量小的时候可以节省网络传输开销。</p></blockquote></li><li><p>Masking-key: 0 or 4bytes</p><p>当 Mask 为 1，则携带了 4 字节的 Masking-key；</p><p>当 Mask 为 0，则没有 Masking-key。</p><blockquote><p>掩码的作用并不是为了防止数据泄密，而是为了防止早期版本的协议中存在的代理缓存污染攻击（proxy cache poisoning attacks）等问题。</p></blockquote></li><li><p>Payload Data: 传输的数据</p></li></ol><h4 id=\"掩码算法\"><a href=\"#掩码算法\" class=\"headerlink\" title=\"掩码算法\"></a>掩码算法</h4><p>在前面可以看到<code>mask</code>和<code>mask key</code>，当<code>mask</code>为 1 时表示数据需要通过掩码处理，并且在报文中会带上一个 4 个字节长度的<code>mask key</code>，掩码算法为：</p><ol><li><code>originalData</code> 作为原始的 Payload Data 数据，类型是[]byte</li><li><code>transformedData</code> 作为掩码处理后的数据，类型是[]byte</li><li><code>key</code> 作为 mask key，类型是[]byte</li><li><code>i</code>作为 originalData 读取 的下标</li><li><code>j</code>作为 key 读取 的下标，公式为：i % 4</li><li>transformedData[i] = originalData[i] ^ key[j]</li></ol><p>完整示例，java 版：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mask</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] key,<span class=\"keyword\">byte</span>[] data)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = i%<span class=\"number\">4</span>;</span><br><span class=\"line\">        data[i] = (<span class=\"keyword\">byte</span>) (data[i]^key[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>最后，厚颜无耻的推荐一下我的开源项目，一个用 netty 开发的 websocket 服务器：<a href=\"https://github.com/monkeyWie/simple-websocket-server\" target=\"_blank\" rel=\"noopener\">https://github.com/monkeyWie/simple-websocket-server</a>，感兴趣的童鞋可以看看。</p>","categories":["后端"],"tags":["go","js","websocket"]},{"title":"Spring AOP调用本类方法没有生效的问题","url":"/2020/07/22/spring-aop-call-self-method/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>首先请思考一下以下代码执行的结果：</p><ul><li>LogAop.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明一个AOP拦截service包下的所有方法</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LogAop</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Around</span>(<span class=\"string\">\"execution(* com.demo.service.*.*(..))\"</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">log</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">          Method method = methodSignature.getMethod();</span><br><span class=\"line\">          Object ret = joinPoint.proceed();</span><br><span class=\"line\">          <span class=\"comment\">//执行完目标方法之后打印</span></span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"after execute method:\"</span>+method.getName());</span><br><span class=\"line\">          <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> throwable;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a><ul><li>UserService.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">save</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//注册</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存用户</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.save(user);</span><br><span class=\"line\">    <span class=\"comment\">//发送邮件给用户</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sendEmail(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><ul><li>UserServiceTest.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceTest</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    userService.save(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    userService.sendEmail(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    UserService.register(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在执行<code>save</code>方法后，控制台输出为：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after execute method:save</span><br></pre></td></tr></table></figure><p>在执行<code>sendEmail</code>方法后，控制台输出为：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after execute method:sendEmail</span><br></pre></td></tr></table></figure><p>请问在执行<code>register()</code>方法后会打印出什么内容？</p><h2 id=\"反直觉\"><a href=\"#反直觉\" class=\"headerlink\" title=\"反直觉\"></a>反直觉</h2><p>这个时候可能很多人都会和我之前想的一样，在<code>register</code>方法里调用了<code>save</code>和<code>sendEmail</code>，那 AOP 会处理<code>save</code>和<code>sendEmail</code>，输出：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after execute method:save</span><br><span class=\"line\">after execute method:sendEmail</span><br><span class=\"line\">after execute method:register</span><br></pre></td></tr></table></figure><p>然而事实并不是这样的，而是输出：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after execute method:register</span><br></pre></td></tr></table></figure><p>在这种认知的情况下，很可能就会写出有<code>bug</code>的代码，例如：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//用户下单一个商品</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">order</span><span class=\"params\">(User user,String orderId)</span></span>&#123;</span><br><span class=\"line\">    Order order = findOrder(orderId);</span><br><span class=\"line\">    pay(user,order);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pay</span><span class=\"params\">(User user,Order order)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//扣款</span></span><br><span class=\"line\">    user.setMoney(user.getMoney()-order.getPrice());</span><br><span class=\"line\">    save(user);</span><br><span class=\"line\">    <span class=\"comment\">//...其它处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>当用户下单时调用的<code>order</code>方法，在该方法里面调用了<code>@Transactional</code>注解修饰的<code>pay</code>方法，这个时候<code>pay</code>方法的事务管理已经不生效了，在发生异常时就会出现问题。</p><h2 id=\"理解-AOP\"><a href=\"#理解-AOP\" class=\"headerlink\" title=\"理解 AOP\"></a>理解 AOP</h2><p>我们知道 Spring AOP 默认是基于动态代理来实现的，那么先化繁为简，只要搞懂最基本的动态代理自然就明白之前的原因了，这里直接以 JDK 动态代理为例来演示一下上面的情况。</p><p>由于 JDK 动态代理一定需要接口类，所以首先声明一个<code>IUserService</code>接口</p><ul><li>IUserService.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IUserService</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">User <span class=\"title\">save</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">User <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类</p><ul><li>UserService.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserService</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">save</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sendEmail</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//注册</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保存用户</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.save(user);</span><br><span class=\"line\">    <span class=\"comment\">//发送邮件给用户</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sendEmail(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编写日志处理动态代理实现</p><ul><li>ServiceLogProxy.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceLogProxy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(Class&lt;?&gt; clazz, Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class=\"keyword\">new</span> Class[]&#123;clazz&#125;, <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">                    Object ret = method.invoke(target, args);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"after execute method:\"</span> + method.getName());</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行代码</p><ul><li>Main.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取代理类</span></span><br><span class=\"line\">        IUserService userService = (IUserService) ServiceLogProxy.getProxy(IUserService<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">new</span> <span class=\"title\">UserService</span>())</span>;</span><br><span class=\"line\">        userService.save(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">        userService.sendEmail(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">        userService.register(<span class=\"keyword\">new</span> User());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after execute method:save</span><br><span class=\"line\">after execute method:sendEmail</span><br><span class=\"line\">after execute method:register</span><br></pre></td></tr></table></figure><p>可以发现和之前 Spring AOP 的情况一样，<code>register</code>方法中调用的<code>save</code>和<code>sendEmail</code>方法同样的没有被动态代理拦截到，这是为什么呢，接下来就看看下动态代理的底层实现。</p><h2 id=\"动态代理原理\"><a href=\"#动态代理原理\" class=\"headerlink\" title=\"动态代理原理\"></a>动态代理原理</h2><p>其实动态代理就是在运行期间动态的生成了一个<code>class</code>在 jvm 中，然后通过这个<code>class</code>的实例调用真正的实现类的方法，伪代码如下：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserService</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//这个类就是之前动态代理里的new InvocationHandler()&#123;&#125;对象</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> InvocationHandler h;</span><br><span class=\"line\">  <span class=\"comment\">//从接口中拿到的register Method</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Method registerMethod;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//执行前面ServiceLogProxy编写好的invoke方法，实现代理功能</span></span><br><span class=\"line\">    h.invoke(<span class=\"keyword\">this</span>,registerMethod,<span class=\"keyword\">new</span> Object[]&#123;user&#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>回到刚刚的<code>main</code>方法，那个<code>userService</code>变量的实例类型其实就是动态生成的类，可以把它的 class 打印出来看看：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IUserService userService = (IUserService) ServiceLogProxy.getProxy(IUserService<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">new</span> <span class=\"title\">UserService</span>())</span>;</span><br><span class=\"line\">System.out.println(userService.getClass());</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xxx.xxx.$Proxy0</span><br></pre></td></tr></table></figure><p>在了解这个原理之后，再接着解答之前的疑问，可以看到通过<code>代理类的实例</code>执行的方法才会进入到拦截处理中，而在<code>InvocationHandler#invoke()</code>方法中，是这样执行目标方法的：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注意这个target是new UserService()实例对象</span></span><br><span class=\"line\">Object ret = method.invoke(target, args);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"after execute method:\"</span> + method.getName());</span><br></pre></td></tr></table></figure><p>在<code>register</code>方法中调用<code>this.save</code>和<code>this.sendEmail</code>方法时，<code>this</code>是指向本身<code>new UserService()</code>实例，所以本质上就是：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">UserService userService = <span class=\"keyword\">new</span> UserService();</span><br><span class=\"line\">userService.save(user);</span><br><span class=\"line\">userService.sendEmail(user);</span><br></pre></td></tr></table></figure><p>不是动态代理生成的类去执行目标方法，那必然不会进行动态代理的拦截处理中，明白这个之后原理之后，就可以改造下之前的方法，让方法内调用本类方法也能使动态代理生效，就是用动态代理生成的类去调用方法就好了，改造如下：</p><ul><li>UserService.java</li></ul><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> <span class=\"keyword\">implements</span> <span class=\"title\">IUserService</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//注册</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取到代理类</span></span><br><span class=\"line\">    IUserService self = (IUserService) ServiceLogProxy.getProxy(IUserService<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">this</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//通过代理类保存用户</span></span><br><span class=\"line\">    self.save(user);</span><br><span class=\"line\">    <span class=\"comment\">//通过代理类发送邮件给用户</span></span><br><span class=\"line\">    self.sendEmail(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>main</code>方法，结果如下：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">after execute method:save</span><br><span class=\"line\">after execute method:sendEmail</span><br><span class=\"line\">after execute method:save</span><br><span class=\"line\">after execute method:sendEmail</span><br><span class=\"line\">after execute method:register</span><br></pre></td></tr></table></figure><p>可以看到已经达到预期效果了。</p><h2 id=\"Spring-AOP-中方法调用本类方法的解决方案\"><a href=\"#Spring-AOP-中方法调用本类方法的解决方案\" class=\"headerlink\" title=\"Spring AOP 中方法调用本类方法的解决方案\"></a>Spring AOP 中方法调用本类方法的解决方案</h2><p>同样的，只要使用代理类来执行目标方法就行，而不是用<code>this</code>引用，修改后如下：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//拿到代理类</span></span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService self;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//注册</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过代理类保存用户</span></span><br><span class=\"line\">    self.save(user);</span><br><span class=\"line\">    <span class=\"comment\">//通过代理类发送邮件给用户</span></span><br><span class=\"line\">    self.sendEmail(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>好了，问题到此就解决了，但是需要注意的是<code>Spring</code>官方是不提倡这样的做法的，官方提倡的是使用一个新的类来解决此类问题，例如创建一个<code>UserRegisterService</code>类：</p><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserRegisterService</span></span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//注册</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(User user)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过代理类保存用户</span></span><br><span class=\"line\">    userService.save(user);</span><br><span class=\"line\">    <span class=\"comment\">//通过代理类发送邮件给用户</span></span><br><span class=\"line\">    userService.sendEmail(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p><a href=\"https://monkeywie.github.io/2018/07/25/jvm-dump-class/\">从JVM中拿到动态代理生成的class文件</a><br><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-understanding-aop-proxies\" target=\"_blank\" rel=\"noopener\">aop-understanding-aop-proxies</a></p>","categories":["后端"],"tags":["java","spring"]},{"title":"Github Actions尝鲜","url":"/2019/10/29/hello-github-actions/","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><a href=\"https://github.com/features/actions\" target=\"_blank\" rel=\"noopener\">Github Actions</a>是 github 官方推出的一款 CI(持续集成)工具，目前还处于<code>Beta</code>版本，需要<a href=\"https://github.com/features/actions/signup/\" target=\"_blank\" rel=\"noopener\">申请</a>内测资格才能使用，申请成功之后在自己的代码仓库就可以看到<code>Actions</code>了。</p><p><img src=\"/2019/10/29/hello-github-actions/2019-10-30-11-30-13.png\" alt></p><a id=\"more\"></a><h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p>这里简单介绍下 <code>Github Actions</code>中的概念，具体可以参考<a href=\"https://help.github.com/en/github/automating-your-workflow-with-github-actions\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p><h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><ol><li><strong>workflow</strong><br>表示一次持续集成的过程</li><li><strong>job</strong><br>表示构建任务，每个 workflow 可以由一个或者多个 job 组成，可支持并发执行 job，所有 job 执行完也就代表着 workflow 结束</li><li><strong>step</strong><br>每个 job 由一个或多个 step 组成，按顺序依次执行</li><li><strong>action</strong><br>每个 step 由一个或多个 action 组成，按顺序依次执行，这里 action 需要特别说明一下，action 是可以是自定义脚本或引用第三方的脚本，依赖着 github 开源社区，许多 action 都可以直接复用，无需自己编写，github 已经提供了一个<a href=\"https://github.com/marketplace?type=actions\" target=\"_blank\" rel=\"noopener\">action 市场</a>，可以搜索到各种第三方 actions，并且<a href=\"https://github.com/actions\" target=\"_blank\" rel=\"noopener\">官方</a>也提供了许多 actions。</li></ol><h3 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h3><p>每个 job 都可以指定对应的操作系统，支持<code>Windows、Linux、macOS</code>，github 会提供一个虚拟机来执行对应的 job。</p><p>硬件规格：</p><ul><li>双核 CPU</li><li>7GB 内存</li><li>14GB 固态硬盘</li></ul><p>使用限制：</p><ul><li>每个仓库只能同时支持 20 个 workflow 并行</li><li>每小时可以调用 1000 次 github API</li><li>每个 job 最多可以执行 6 个小时</li><li>免费版的用户最大支持 20 个 job 并发执行，macOS 系统的话最大只支持 5 个</li></ul><p>可以看到这个配置下，普通的项目持续集成肯定没什么问题的。</p><h3 id=\"构建记录\"><a href=\"#构建记录\" class=\"headerlink\" title=\"构建记录\"></a>构建记录</h3><p>通过仓库中的<code>Actions</code>选项卡，可以看到项目中的 workflow 构建记录：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-16-07-59.png\" alt></p><p>点击一条记录可以进入详情页面，可以<code>实时</code>查看每一个<code>action</code>的控制台输出，方便调试：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-16-10-30.png\" alt></p><h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><p>前面大概介绍了一下基本的概念，下面就直接通过几个实例看看 <code>Github Actions</code>是如何使用的。</p><h3 id=\"自动部署-Hexo-博客到-Github-Page\"><a href=\"#自动部署-Hexo-博客到-Github-Page\" class=\"headerlink\" title=\"自动部署 Hexo 博客到 Github Page\"></a>自动部署 Hexo 博客到 Github Page</h3><p>首先第一个想到能用到<code>Github Actions</code>的就是我的博客了，项目托管在<a href=\"https://github.com/monkeyWie/monkeywie.github.io\" target=\"_blank\" rel=\"noopener\">https://github.com/monkeyWie/monkeywie.github.io</a>，目前项目有两个分支，<code>master</code>分支用于存放 hexo 编译之后的静态文件，另一个<code>hexo</code>分支用于存放 hexo 项目环境和 markdown 文章，<code>master</code>分支通过<code>Github Page</code>配置之后可以通过<code>monkeywie.github.io</code>域名访问。<br><img src=\"/2019/10/29/hello-github-actions/2019-10-30-14-18-15.png\" alt></p><p>之前写完博客之后都是需要手动执行一遍命令进行部署：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><p>然后再把<code>hexo</code>分支代码推送到 github 上</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure><p>在使用<code>Github Actions</code>之后，只需要把<code>hexo</code>分支代码推送到 github 上，剩下的全部交给<code>Github Actions</code>即可，在此之前我们需要生成一对<code>公私钥</code>用于 hexo 的部署操作，因为 hexo 自带的部署命令<code>hexo d</code>需要有 git 远程仓库读写权限。</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br><span class=\"line\">Generating public/private rsa key pair.</span><br><span class=\"line\">Enter file <span class=\"keyword\">in</span> <span class=\"built_in\">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class=\"line\">Created directory <span class=\"string\">'/root/.ssh'</span>.</span><br><span class=\"line\">Enter passphrase (empty <span class=\"keyword\">for</span> no passphrase):</span><br><span class=\"line\">Enter same passphrase again:</span><br><span class=\"line\">Your identification has been saved <span class=\"keyword\">in</span> /root/.ssh/id_rsa.</span><br><span class=\"line\">Your public key has been saved <span class=\"keyword\">in</span> /root/.ssh/id_rsa.pub.</span><br><span class=\"line\">The key fingerprint is:</span><br><span class=\"line\">SHA256:XG1vkchp5b27tteZASx6ZrPRtTayGYmacRdjjRxR1Y0 root@8fe85d51123b</span><br><span class=\"line\">The key<span class=\"string\">'s randomart image is:</span></span><br><span class=\"line\"><span class=\"string\">+---[RSA 2048]----+</span></span><br><span class=\"line\"><span class=\"string\">|             .+o=|</span></span><br><span class=\"line\"><span class=\"string\">|           o *Eoo|</span></span><br><span class=\"line\"><span class=\"string\">|          . X B .|</span></span><br><span class=\"line\"><span class=\"string\">|       . . + X +.|</span></span><br><span class=\"line\"><span class=\"string\">|        S . = O..|</span></span><br><span class=\"line\"><span class=\"string\">|         o O B =.|</span></span><br><span class=\"line\"><span class=\"string\">|          O = *.*|</span></span><br><span class=\"line\"><span class=\"string\">|         o . o ++|</span></span><br><span class=\"line\"><span class=\"string\">|              .oo|</span></span><br><span class=\"line\"><span class=\"string\">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p>先把<code>~/.ssh/id_rsa.pub</code>中的公钥添加到 Github 对应仓库的<code>Deploye keys</code>中：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-30-16-19-20.png\" alt></p><p>再将<code>~/.ssh/id_rsa</code>中的私钥添加到 Github 对应仓库的<code>Secrets</code>中，Name 定义为<code>ACTION_DEPLOY_KEY</code>，目的是在构建的时候可以读取该私钥并配添加到虚拟机中，以获取 git 仓库访问权限：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-30-17-04-55.png\" alt></p><p>准备工作完成后，接着就按照<a href=\"https://help.github.com/en/github/automating-your-workflow-with-github-actions/configuring-a-workflow#creating-a-workflow-file\" target=\"_blank\" rel=\"noopener\">教程</a>，在<code>hexo</code>分支创建<code>.github/workflows/main.yaml</code>文件用于配置 hexo 部署。</p><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">hexo</span></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">source</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">ref:</span> <span class=\"string\">hexo</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Use</span> <span class=\"string\">Node.js</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">matrix.node_version</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">version:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">matrix.node_version</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Setup</span> <span class=\"string\">hexo</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">ACTION_DEPLOY_KEY:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.ACTION_DEPLOY_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">mkdir</span> <span class=\"string\">-p</span> <span class=\"string\">~/.ssh/</span></span><br><span class=\"line\">          <span class=\"string\">echo</span> <span class=\"string\">\"$ACTION_DEPLOY_KEY\"</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">          <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">          <span class=\"string\">ssh-keyscan</span> <span class=\"string\">github.com</span> <span class=\"string\">&gt;&gt;</span> <span class=\"string\">~/.ssh/known_hosts</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">\"liwei2633@163.com\"</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">\"monkeyWie\"</span></span><br><span class=\"line\">          <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-cli</span> <span class=\"string\">-g</span></span><br><span class=\"line\">          <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Hexo</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br></pre></td></tr></table></figure><p>具体的配置语法这里就不详细说明了，可以自行在官方文档中查阅。</p><p>构建流程如下：</p><ol><li>监听<code>hexo</code>分支的 push 操作</li><li>运行一个 job，在<code>ubuntu</code>虚拟机环境下</li><li>使用官方提供的<a href=\"https://github.com/actions/checkout\" target=\"_blank\" rel=\"noopener\">actions/checkout@v1</a>来拉取源码</li><li>使用官方提供的<a href=\"https://github.com/actions/setup-node\" target=\"_blank\" rel=\"noopener\">actions/setup-node@v1</a>来安装 node 环境</li><li>使用 <code>$</code>读取刚刚生成的私钥，并设置成环境变量，<code>$</code>写法为 actions 内置的表达式语法，详细文档参考：<a href=\"https://help.github.com/en/github/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions\" target=\"_blank\" rel=\"noopener\">contexts-and-expression-syntax-for-github-actions</a></li><li>将私钥写入到<code>~/.ssh/id_rsa</code>文件中，并把<code>github.com</code>域名加入到<code>~/.ssh/known_hosts</code>文件中，以免第一次 ssh 访问时弹出交互式命令。</li><li>配置 git 用户信息</li><li>安装 hexo 命令行工具和项目的依赖</li><li>调用 hexo 命令进行部署</li></ol><p>把<code>hexo</code>分支代码推到 github 上触发 workflow ，通过<code>Actions</code>选项卡进入就可以看到项目的构建情况了。<br><img src=\"/2019/10/29/hello-github-actions/2019-10-30-17-15-15.png\" alt></p><p>至此改造完成，以后只需要写完文章直接提交代码就可以自动部署了，甚至都可以不装 node 环境进行写作简直不要太方便。</p><h3 id=\"自动创建项目-Release\"><a href=\"#自动创建项目-Release\" class=\"headerlink\" title=\"自动创建项目 Release\"></a>自动创建项目 Release</h3><p>有些项目在发布新版本时，一般都会创建一个<code>Github Release</code>，并且把对应编译好之后的文件上传到<code>Release</code>的资源列表中，例如：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-30-17-44-19.png\" alt></p><p>如果这个使用手动操作的话，不仅步骤重复又繁琐(每次都要编译出各个操作系统对应的发行包再进行上传)，而且最蛋疼的是对于国内的网络环境来说，上传文件速度简直不能忍，好不容易上传了一大半搞不好就因为网络原因又要重新上传，相信用过的人都深有体会。</p><p>我就在想如果能用<code>Github Actions</code>来创建<code>Release</code>,并且做对应的编译和上传，那上面的问题都可以迎刃而解了，于是在官方市场搜索了一下<code>Release</code>关键字，果然已经有提供对应的<code>actions</code>了：</p><ul><li><a href=\"https://github.com/actions/create-release\" target=\"_blank\" rel=\"noopener\">create-release</a>: 用于创建 release</li><li><a href=\"https://github.com/actions/upload-release-asset\" target=\"_blank\" rel=\"noopener\">upload-release-asset</a>: 用于上传资源到对应的 release 中</li></ul><p>接着创建一个<code>Github仓库</code>，我测试的仓库地址是<a href=\"https://github.com/monkeyWie/github-actions-demo\" target=\"_blank\" rel=\"noopener\">https://github.com/monkeyWie/github-actions-demo</a>，项目用 go 语言写的，代码非常简单就是两个 hello world 级别的代码，里面包含了普通的 go 程序和 cgo 程序。</p><p>项目的构建流程是在项目<code>git push --tags</code>的时候，触发 workflow，通过<code>Github Actions</code>编译出来<code>Windows、Linux、macOS</code>三个操作系统对应的 64 位可执行文件，再根据<code>tag name</code>和<code>tag message</code>来创建对应的<code>Github Release</code>，并将编译好的文件上传。</p><p>同样的创建一个<code>.github/workflows/main.yml</code>文件，内容如下：</p><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"comment\"># Sequence of patterns matched against refs/tags</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"v*\"</span> <span class=\"comment\"># Push events to matching v*, i.e. v1.0, v20.15.10</span></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">source</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Use</span> <span class=\"string\">Golang</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-go@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">go-version:</span> <span class=\"string\">\"1.13.x\"</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Build</span> <span class=\"string\">normal</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">CGO_ENABLED=0</span> <span class=\"string\">GOOS=windows</span> <span class=\"string\">GOARCH=amd64</span> <span class=\"string\">go</span> <span class=\"string\">build</span> <span class=\"string\">-o</span> <span class=\"string\">normal-windows-x64.exe</span> <span class=\"string\">cmd/normal/main.go</span></span><br><span class=\"line\">          <span class=\"string\">CGO_ENABLED=0</span> <span class=\"string\">GOOS=linux</span> <span class=\"string\">GOARCH=amd64</span> <span class=\"string\">go</span> <span class=\"string\">build</span> <span class=\"string\">-o</span> <span class=\"string\">normal-linux-x64</span> <span class=\"string\">cmd/normal/main.go</span></span><br><span class=\"line\">          <span class=\"string\">CGO_ENABLED=0</span> <span class=\"string\">GOOS=darwin</span> <span class=\"string\">GOARCH=amd64</span> <span class=\"string\">go</span> <span class=\"string\">build</span> <span class=\"string\">-o</span> <span class=\"string\">normal-darwin-x64</span> <span class=\"string\">cmd/normal/main.go</span></span><br><span class=\"line\">          <span class=\"string\">zip</span> <span class=\"string\">normal-windows-x64.zip</span> <span class=\"string\">normal-windows-x64.exe</span></span><br><span class=\"line\">          <span class=\"string\">zip</span> <span class=\"string\">normal-linux-x64.zip</span> <span class=\"string\">normal-linux-x64</span></span><br><span class=\"line\">          <span class=\"string\">zip</span> <span class=\"string\">normal-darwin-x64.zip</span> <span class=\"string\">normal-darwin-x64</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Build</span> <span class=\"string\">cgo</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">go</span> <span class=\"string\">get</span> <span class=\"string\">github.com/monkeyWie/xgo</span></span><br><span class=\"line\">          <span class=\"string\">~/go/bin/xgo</span> <span class=\"string\">-targets=windows/amd64,linux/amd64,darwin/amd64</span> <span class=\"string\">-ldflags=\"-w</span> <span class=\"string\">-s\"</span> <span class=\"string\">-pkg=cmd/cgo/main.go</span> <span class=\"string\">-out=cgo</span> <span class=\"string\">.</span></span><br><span class=\"line\">          <span class=\"string\">mv</span> <span class=\"string\">cgo-windows-*</span> <span class=\"string\">cgo-windows-x64.exe</span></span><br><span class=\"line\">          <span class=\"string\">mv</span> <span class=\"string\">cgo-linux-*</span> <span class=\"string\">cgo-linux-x64</span></span><br><span class=\"line\">          <span class=\"string\">mv</span> <span class=\"string\">cgo-darwin-*</span> <span class=\"string\">cgo-darwin-x64</span></span><br><span class=\"line\">          <span class=\"string\">zip</span> <span class=\"string\">cgo-windows-x64.zip</span> <span class=\"string\">cgo-windows-x64.exe</span></span><br><span class=\"line\">          <span class=\"string\">zip</span> <span class=\"string\">cgo-linux-x64.zip</span> <span class=\"string\">cgo-linux-x64</span></span><br><span class=\"line\">          <span class=\"string\">zip</span> <span class=\"string\">cgo-darwin-x64.zip</span> <span class=\"string\">cgo-darwin-x64</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Create</span> <span class=\"string\">Release</span></span><br><span class=\"line\">        <span class=\"attr\">id:</span> <span class=\"string\">create_release</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">monkeyWie/create-release@master</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">tag_name:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">github.ref</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">release_name:</span> <span class=\"string\">Release</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">github.ref</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">draft:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">          <span class=\"attr\">prerelease:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Release</span> <span class=\"string\">normal</span> <span class=\"string\">windows</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-release-asset@v1.0.1</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">upload_url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.upload_url</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class=\"line\">          <span class=\"attr\">asset_path:</span> <span class=\"string\">./normal-windows-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_name:</span> <span class=\"string\">normal-$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.tag</span> <span class=\"string\">&#125;&#125;-windows-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_content_type:</span> <span class=\"string\">application/zip</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Release</span> <span class=\"string\">normal</span> <span class=\"string\">linux</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-release-asset@v1.0.1</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">upload_url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.upload_url</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class=\"line\">          <span class=\"attr\">asset_path:</span> <span class=\"string\">./normal-linux-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_name:</span> <span class=\"string\">normal-$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.tag</span> <span class=\"string\">&#125;&#125;-linux-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_content_type:</span> <span class=\"string\">application/zip</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Release</span> <span class=\"string\">normal</span> <span class=\"string\">darwin</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-release-asset@v1.0.1</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">upload_url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.upload_url</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class=\"line\">          <span class=\"attr\">asset_path:</span> <span class=\"string\">./normal-darwin-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_name:</span> <span class=\"string\">normal-$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.tag</span> <span class=\"string\">&#125;&#125;-darwin-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_content_type:</span> <span class=\"string\">application/zip</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Release</span> <span class=\"string\">cgo</span> <span class=\"string\">windows</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-release-asset@v1.0.1</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">upload_url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.upload_url</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class=\"line\">          <span class=\"attr\">asset_path:</span> <span class=\"string\">./cgo-windows-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_name:</span> <span class=\"string\">cgo-$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.tag</span> <span class=\"string\">&#125;&#125;-windows-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_content_type:</span> <span class=\"string\">application/zip</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Release</span> <span class=\"string\">cgo</span> <span class=\"string\">linux</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-release-asset@v1.0.1</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">upload_url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.upload_url</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class=\"line\">          <span class=\"attr\">asset_path:</span> <span class=\"string\">./cgo-linux-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_name:</span> <span class=\"string\">cgo-$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.tag</span> <span class=\"string\">&#125;&#125;-linux-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_content_type:</span> <span class=\"string\">application/zip</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Upload</span> <span class=\"string\">Release</span> <span class=\"string\">cgo</span> <span class=\"string\">darwin</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/upload-release-asset@v1.0.1</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">GITHUB_TOKEN:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.GITHUB_TOKEN</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">upload_url:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.upload_url</span> <span class=\"string\">&#125;&#125;</span> <span class=\"comment\"># This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps</span></span><br><span class=\"line\">          <span class=\"attr\">asset_path:</span> <span class=\"string\">./cgo-darwin-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_name:</span> <span class=\"string\">cgo-$&#123;&#123;</span> <span class=\"string\">steps.create_release.outputs.tag</span> <span class=\"string\">&#125;&#125;-darwin-x64.zip</span></span><br><span class=\"line\">          <span class=\"attr\">asset_content_type:</span> <span class=\"string\">application/zip</span></span><br></pre></td></tr></table></figure><p>构建流程如下：</p><ol><li>监听 tag name 为<code>v</code>开头的 push</li><li>运行一个 job，在<code>ubuntu</code>虚拟机环境下</li><li>拉取源码，安装<code>golang 1.13.x</code>环境</li><li>使用<code>go build</code>交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩</li><li>使用<code>xgo</code>交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩</li><li>使用<code>monkeyWie/create-release@master</code>创建 Release，其中会用到<code>$</code>，这是<code>Github Actions</code>内置的一个<a href=\"https://help.github.com/en/github/automating-your-workflow-with-github-actions/virtual-environments-for-github-actions#github_token-secret\" target=\"_blank\" rel=\"noopener\">秘钥</a>，用于授权访问你自己的 github 存储库，原理就是使用这个<code>TOKEN</code>调用<code>Github API</code>来进行创建 release，还有一个<code>$</code>也是<code>Github Actions</code>内置的一个<a href=\"https://help.github.com/en/github/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context\" target=\"_blank\" rel=\"noopener\">变量</a>，然后通过 action 的<code>with</code>进行参数传递。</li><li>使用<a href=\"mailto:`actions/upload-release-asset@v1.0.1\" target=\"_blank\" rel=\"noopener\">`actions/upload-release-asset@v1.0.1</a><code>上传文件，这里使用了两个表达式</code>$<code>和</code>$<code>，可以获取到指定</code>action<code>的输出，第一个是获取创建好的 release 对应的上传地址，第二个是获取对应的 tag(例如：v1.0.0)，这样就可以在把上传的文件带上版本号。因为这个</code>action`不支持多个文件上传，所以就写了多个 action 进行上传。</li></ol><p>接下来在项目打个<code>tag</code>，然后<code>push</code>上去看看效果：</p><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 创建tag名为v1.0.8，并添加描述</span></span><br><span class=\"line\">git tag -a <span class=\"string\">\"v1.0.8\"</span> -m <span class=\"string\">'发布v1.0.8版本</span></span><br><span class=\"line\"><span class=\"string\">修复了以下bug:</span></span><br><span class=\"line\"><span class=\"string\">1. xxxxx</span></span><br><span class=\"line\"><span class=\"string\">2. xxxxx'</span></span><br><span class=\"line\"><span class=\"comment\"># 把tag推到github上</span></span><br><span class=\"line\">git push --tags</span><br></pre></td></tr></table></figure><p>然后就可以看到已经有一个新的<code>workflow</code>正在运行了：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-13-36-28.png\" alt></p><p>运行完成后在<code>Releases</code>页面查看结果：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-13-40-16.png\" alt></p><p>完美！和预想的结果一致。</p><blockquote><p>注：由于官方的<a href=\"https://github.com/actions/create-release\" target=\"_blank\" rel=\"noopener\">create-release</a>有点不能满足需求，于是我自己<code>fork</code>了一份<a href=\"https://github.com/monkeyWie/create-release\" target=\"_blank\" rel=\"noopener\">create-release</a>代码，就是把<code>tag name</code>给输出来了，这里是相关的<a href=\"https://github.com/actions/create-release/pull/10\" target=\"_blank\" rel=\"noopener\">PR</a>，还没被合并，所以上面的创建 Release 的 action 是用的我自己的仓库<code>monkeyWie/create-release@master</code>，还有关于 go 交叉编译的知识，有兴趣可以看看我的这篇博客：<a href=\"https://monkeywie.github.io/2019/10/10/go-cross-compile\">go-cross-compile</a>。</p></blockquote><h3 id=\"自动构建和部署-docker-镜像\"><a href=\"#自动构建和部署-docker-镜像\" class=\"headerlink\" title=\"自动构建和部署 docker 镜像\"></a>自动构建和部署 docker 镜像</h3><p>在<code>Github Actions</code>提供的虚拟机中，已经内置了<code>docker</code>，而刚好我有一个项目因为国内的网络原因构建<code>docker镜像</code>非常的慢，这是我<code>fork</code>的一个用于 go 项目交叉编译的项目，仓库地址<a href=\"https://github.com/monkeyWie/xgo\" target=\"_blank\" rel=\"noopener\">https://github.com/monkeyWie/xgo</a>，这个项目的主要工作原理就是通过 docker 里内置好各种<code>交叉编译</code>的工具链，然后对外提供 go 项目交叉编译功能，下面节选一点<code>Dockerfile</code>内容：</p><p><img src=\"/2019/10/29/hello-github-actions/2019-10-31-15-54-19.png\" alt></p><p>看这大量的<code>apt-get install</code>，就知道在本地构建有多慢了，下面就改用<code>Github Actions</code>来帮忙构建和部署镜像。</p><p>由于要将镜像推送到<code>docker hub</code>官方镜像仓库上，需要验证账号信息，<br>这里我把自己的用户密码配置到了<code>Secrets</code>中，以便在 workflow 配置文件中可以访问到：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-16-00-38.png\" alt></p><p>编写构建文件<code>.github/workflows/main.yml</code>：</p><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">master</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">\"docker/base/*\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">source</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Docker</span> <span class=\"string\">login</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">docker</span> <span class=\"string\">login</span> <span class=\"string\">-u</span> <span class=\"string\">liwei2633</span> <span class=\"string\">-p</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.DOCKER_HUB_PWD</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Docker</span> <span class=\"string\">build</span> <span class=\"string\">base</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">pull</span> <span class=\"string\">liwei2633/xgo:base</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">build</span> <span class=\"string\">--cache-from=liwei2633/xgo:base</span> <span class=\"string\">-t</span> <span class=\"string\">liwei2633/xgo:base</span> <span class=\"string\">./docker/base</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">push</span> <span class=\"string\">liwei2633/xgo:base</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Docker</span> <span class=\"string\">build</span> <span class=\"string\">other</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">build</span> <span class=\"string\">-t</span> <span class=\"string\">liwei2633/xgo:go-1.12.10</span> <span class=\"string\">./docker/go-1.12.10</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">push</span> <span class=\"string\">liwei2633/xgo:go-1.12.10</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">build</span> <span class=\"string\">-t</span> <span class=\"string\">liwei2633/xgo:go-1.12.x</span> <span class=\"string\">./docker/go-1.12.x</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">push</span> <span class=\"string\">liwei2633/xgo:go-1.12.x</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">build</span> <span class=\"string\">-t</span> <span class=\"string\">liwei2633/xgo:go-1.13.1</span> <span class=\"string\">./docker/go-1.13.1</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">push</span> <span class=\"string\">liwei2633/xgo:go-1.13.1</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">build</span> <span class=\"string\">-t</span> <span class=\"string\">liwei2633/xgo:go-1.13.x</span> <span class=\"string\">./docker/go-1.13.x</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">push</span> <span class=\"string\">liwei2633/xgo:go-1.13.x</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">build</span> <span class=\"string\">-t</span> <span class=\"string\">liwei2633/xgo:go-latest</span> <span class=\"string\">./docker/go-latest</span></span><br><span class=\"line\">          <span class=\"string\">docker</span> <span class=\"string\">push</span> <span class=\"string\">liwei2633/xgo:go-latest</span></span><br></pre></td></tr></table></figure><p>构建流程如下：</p><ol><li>监听 master 分支的 push 操作，并且<code>docker/base</code>目录下文件有修改才进行构建，这样做的目的是在其它与 docker 构建无关的文件改动了不会去触发 workflow</li><li>运行一个 job，在<code>ubuntu</code>虚拟机环境下</li><li>拉取源码</li><li>登录 docker hub，通过之前配置的<code>$</code>，这里不用担心控制台输出会暴露密码，通过<code>secrets</code>访问的变量在控制台输出时都会打上马赛克<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-16-47-31.png\" alt></li><li>构建镜像，这里使用了一个小技巧<code>--cache-from=liwei2633/xgo:base</code>，预先下载好之前的镜像<code>liwei2633/xgo:base</code>，然后可以使用<code>docker</code>的缓存机制加快构建速度<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-16-50-06.png\" alt></li><li>推送镜像并编译和推送不同 go 版本的镜像</li></ol><p>这样通过<code>Github Actions</code>就把构建镜像和部署时间的缩小了到了<code>13分钟</code>：<br><img src=\"/2019/10/29/hello-github-actions/2019-10-31-16-54-35.png\" alt></p><p>虽然还是挺慢的但是跟本地构建比起来快了不是一个量级，有次本地构建等了一个多小时，因为网络原因导致一个软件源安装失败直接没了又要重头开始构建，所以高下立判，<code>Github Actions</code>真香！！</p><h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>通过上面三个实例项目，可以看得出<code>Github Actions</code>为我们节省大量的时间和重复的操作，且通过官方的 actions 市场很方便的就可以实现大部分编排功能，真是一个可以吹爆的良心产品，所以赶紧一起来尝鲜啊。</p>","categories":["运维"],"tags":["DevOps","github"]},{"title":"k8s域名解析超时问题记录","url":"/2019/12/10/k8s-dns-lookup-timeout/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>近期线上 k8s 时不时就会出现一些内部服务间的调用超时问题，通过日志可以得知超时的原因都是出现在<code>域名解析</code>上，并且都是 k8s 内部的域名解析超时，于是直接先将内部域名替换成 k8s service 的 IP，观察一段时间发现没有超时的情况发生了，但是由于使用 service IP 不是长久之计，所以还要去找解决办法。</p><h2 id=\"复现\"><a href=\"#复现\" class=\"headerlink\" title=\"复现\"></a>复现</h2><p>一开始运维同事在调用方 pod 中使用<code>ab</code>工具对目标服务进行了多次压测，并没有发现有超时的请求，我介入之后分析<code>ab</code>这类 http 压测工具应该都会有 dns 缓存，而我们主要是要测试 dns 服务的性能，于是直接动手撸了一个压测工具只做域名解析，代码如下：</p><a id=\"more\"></a><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"context\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"flag\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"net\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"sync/atomic\"</span></span><br><span class=\"line\">\t<span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> host <span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> connections <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> duration <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> limit <span class=\"keyword\">int64</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> timeoutCount <span class=\"keyword\">int64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// os.Args = append(os.Args, \"-host\", \"www.baidu.com\", \"-c\", \"200\", \"-d\", \"30\", \"-l\", \"5000\")</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tflag.StringVar(&amp;host, <span class=\"string\">\"host\"</span>, <span class=\"string\">\"\"</span>, <span class=\"string\">\"Resolve host\"</span>)</span><br><span class=\"line\">\tflag.IntVar(&amp;connections, <span class=\"string\">\"c\"</span>, <span class=\"number\">100</span>, <span class=\"string\">\"Connections\"</span>)</span><br><span class=\"line\">\tflag.Int64Var(&amp;duration, <span class=\"string\">\"d\"</span>, <span class=\"number\">0</span>, <span class=\"string\">\"Duration(s)\"</span>)</span><br><span class=\"line\">\tflag.Int64Var(&amp;limit, <span class=\"string\">\"l\"</span>, <span class=\"number\">0</span>, <span class=\"string\">\"Limit(ms)\"</span>)</span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> count <span class=\"keyword\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> errCount <span class=\"keyword\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\tpool := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">interface</span>&#123;&#125;, connections)</span><br><span class=\"line\">\texit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t\tmin <span class=\"keyword\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tmax <span class=\"keyword\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t\tsum <span class=\"keyword\">int64</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\ttime.Sleep(time.Second * time.Duration(duration))</span><br><span class=\"line\">\t\texit &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">endD:</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> pool &lt;- <span class=\"literal\">nil</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\t\t&lt;-pool</span><br><span class=\"line\">\t\t\t\t&#125;()</span><br><span class=\"line\">\t\t\t\tresolver := &amp;net.Resolver&#123;&#125;</span><br><span class=\"line\">\t\t\t\tnow := time.Now()</span><br><span class=\"line\">\t\t\t\t_, err := resolver.LookupIPAddr(context.Background(), host)</span><br><span class=\"line\">\t\t\t\tuse := time.Since(now).Nanoseconds() / <span class=\"keyword\">int64</span>(time.Millisecond)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> min == <span class=\"number\">0</span> || use &lt; min &#123;</span><br><span class=\"line\">\t\t\t\t\tmin = use</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> use &gt; max &#123;</span><br><span class=\"line\">\t\t\t\t\tmax = use</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tsum += use</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> limit &gt; <span class=\"number\">0</span> &amp;&amp; use &gt;= limit &#123;</span><br><span class=\"line\">\t\t\t\t\ttimeoutCount++</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tatomic.AddInt64(&amp;count, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tfmt.Println(err.Error())</span><br><span class=\"line\">\t\t\t\t\tatomic.AddInt64(&amp;errCount, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;()</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-exit:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span> endD</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"request count：%d\\nerror count：%d\\n\"</span>, count, errCount)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"request time：min(%dms) max(%dms) avg(%dms) timeout(%dn)\\n\"</span>, min, max, sum/count, timeoutCount)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编译好二进制程序直接丢到对应的 pod 容器中进行压测：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 200个并发,持续30秒</span><br><span class=\"line\">./dns -host &#123;service&#125;.&#123;namespace&#125; -c 200 -d 30</span><br></pre></td></tr></table></figure><p>这次可以发现最大耗时有<code>5s</code>多，多次测试结果都是类似：<br><img src=\"/2019/12/10/k8s-dns-lookup-timeout/2019-12-11-11-19-11.png\" alt></p><p>而我们内部服务间 HTTP 调用的超时一般都是设置在<code>3s</code>左右，以此推断出与线上的超时情况应该是同一种情况，在并发高的情况下会出现部分域名解析超时而导致 HTTP 请求失败。</p><h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>起初一直以为是<code>coredns</code>的问题，于是找运维升级了下<code>coredns</code>版本再进行压测，发现问题还是存在，说明不是版本的问题，难道是<code>coredns</code>本身的性能就差导致的？想想也不太可能啊，才 200 的并发就顶不住了那性能也未免太弱了吧，结合之前的压测数据，平均响应都挺正常的(82ms)，但是就有个别请求会延迟，而且都是 5 秒左右，所以就又带着<code>k8s dns 5s</code>的关键字去 google 搜了一下，这不搜不知道一搜吓一跳啊，原来是 k8s 里的一个大坑啊(其实和 k8s 没有太大的关系，只是 k8s 层面没有提供解决方案)。</p><h3 id=\"5s-超时原因\"><a href=\"#5s-超时原因\" class=\"headerlink\" title=\"5s 超时原因\"></a>5s 超时原因</h3><p>linux 中<code>glibc</code>的 resolver 的缺省超时时间是 5s，而导致超时的原因是内核<code>conntrack</code>模块的 bug。</p><blockquote><p>Weave works 的工程师 Martynas Pumputis 对这个问题做了很详细的分析：<a href=\"https://www.weave.works/blog/racy-conntrack-and-dns-lookup-timeouts\" target=\"_blank\" rel=\"noopener\">https://www.weave.works/blog/racy-conntrack-and-dns-lookup-timeouts</a></p></blockquote><p>这里再引用下<a href=\"https://imroc.io/posts/kubernetes/troubleshooting-with-kubernetes-network/\" target=\"_blank\" rel=\"noopener\">https://imroc.io/posts/kubernetes/troubleshooting-with-kubernetes-network/</a>文章中的解释：</p><blockquote><p>DNS client (glibc 或 musl libc) 会并发请求 A 和 AAAA 记录，跟 DNS Server 通信自然会先 connect (建立 fd)，后面请求报文使用这个 fd 来发送，由于 UDP 是无状态协议， connect 时并不会发包，也就不会创建 conntrack 表项, 而并发请求的 A 和 AAAA 记录默认使用同一个 fd 发包，send 时各自发的包它们源 Port 相同(因为用的同一个 socket 发送)，当并发发包时，两个包都还没有被插入 conntrack 表项，所以 netfilter 会为它们分别创建 conntrack 表项，而集群内请求 kube-dns 或 coredns 都是访问的 CLUSTER-IP，报文最终会被 DNAT 成一个 endpoint 的 POD IP，当两个包恰好又被 DNAT 成同一个 POD IP 时，它们的五元组就相同了，在最终插入的时候后面那个包就会被丢掉，如果 dns 的 pod 副本只有一个实例的情况就很容易发生(始终被 DNAT 成同一个 POD IP)，现象就是 dns 请求超时，client 默认策略是等待 5s 自动重试，如果重试成功，我们看到的现象就是 dns 请求有 5s 的延时。</p></blockquote><h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><h3 id=\"方案（一）：使用-TCP-协议发送-DNS-请求\"><a href=\"#方案（一）：使用-TCP-协议发送-DNS-请求\" class=\"headerlink\" title=\"方案（一）：使用 TCP 协议发送 DNS 请求\"></a>方案（一）：使用 TCP 协议发送 DNS 请求</h3><p>通过<code>resolv.conf</code>的<code>use-vc</code>选项来开启 TCP 协议</p><h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><ol><li><p>修改<code>/etc/resolv.conf</code>文件，在最后加入一行文本：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">options use-vc</span><br></pre></td></tr></table></figure></li><li><p>进行压测：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 200个并发,持续30秒,记录超过5s的请求个数</span><br><span class=\"line\">./dns -host &#123;service&#125;.&#123;namespace&#125; -c 200 -d 30 -l 5000</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src=\"/2019/12/10/k8s-dns-lookup-timeout/2019-12-11-11-26-10.png\" alt></p></li></ol><h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>确实没有出现<code>5s</code>的超时问题了，但是部分请求耗时还是比较高，在<code>4s</code>左右，而且平均耗时比 UPD 协议的还高，效果并不好。</p><h3 id=\"方案（二）：避免相同五元组-DNS-请求的并发\"><a href=\"#方案（二）：避免相同五元组-DNS-请求的并发\" class=\"headerlink\" title=\"方案（二）：避免相同五元组 DNS 请求的并发\"></a>方案（二）：避免相同五元组 DNS 请求的并发</h3><p>通过<code>resolv.conf</code>的<code>single-request-reopen</code>和<code>single-request</code>选项来避免：</p><ul><li>single-request-reopen (glibc&gt;=2.9)<br>发送 A 类型请求和 AAAA 类型请求使用不同的源端口。这样两个请求在 conntrack 表中不占用同一个表项，从而避免冲突。</li><li>single-request (glibc&gt;=2.10)<br>避免并发，改为串行发送 A 类型和 AAAA 类型请求，没有了并发，从而也避免了冲突。</li></ul><h4 id=\"测试-single-request-reopen\"><a href=\"#测试-single-request-reopen\" class=\"headerlink\" title=\"测试 single-request-reopen\"></a>测试 single-request-reopen</h4><ol><li><p>修改<code>/etc/resolv.conf</code>文件，在最后加入一行文本：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">options single-request-reopen</span><br></pre></td></tr></table></figure></li><li><p>进行压测：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 200个并发,持续30秒,记录超过5s的请求个数</span><br><span class=\"line\">./dns -host &#123;service&#125;.&#123;namespace&#125; -c 200 -d 30 -l 5000</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src=\"/2019/12/10/k8s-dns-lookup-timeout/2019-12-11-11-33-52.png\" alt></p></li></ol><h4 id=\"测试-single-request\"><a href=\"#测试-single-request\" class=\"headerlink\" title=\"测试 single-request\"></a>测试 single-request</h4><ol><li><p>修改<code>/etc/resolv.conf</code>文件，在最后加入一行文本：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">options single-request</span><br></pre></td></tr></table></figure></li><li><p>进行压测：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 200个并发,持续30秒,记录超过5s的请求个数</span><br><span class=\"line\">./dns -host &#123;service&#125;.&#123;namespace&#125; -c 200 -d 30 -l 5000</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src=\"/2019/12/10/k8s-dns-lookup-timeout/2019-12-11-11-04-03.png\" alt></p></li></ol><h4 id=\"结论-1\"><a href=\"#结论-1\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>通过压测结果可以看到<code>single-request-reopen</code>和<code>single-request</code>选项确实可以显著的降低域名解析耗时。</p><h3 id=\"关于方案（一）和方案（二）的实施步骤和缺点\"><a href=\"#关于方案（一）和方案（二）的实施步骤和缺点\" class=\"headerlink\" title=\"关于方案（一）和方案（二）的实施步骤和缺点\"></a>关于方案（一）和方案（二）的实施步骤和缺点</h3><h4 id=\"实施步骤\"><a href=\"#实施步骤\" class=\"headerlink\" title=\"实施步骤\"></a>实施步骤</h4><p>其实就是要给容器的<code>/etc/resolv.conf</code>文件添加选项，目前有两个方案比较合适：</p><ol><li>通过修改 pod 的 postStart hook 来设置</li></ol><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">lifecycle:</span></span><br><span class=\"line\">  <span class=\"attr\">postStart:</span></span><br><span class=\"line\">    <span class=\"attr\">exec:</span></span><br><span class=\"line\">      <span class=\"attr\">command:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">/bin/sh</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">-c</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">\"/bin/echo 'options single-request-reopen' &gt;&gt; /etc/resolv.conf\"</span></span><br></pre></td></tr></table></figure><ol start=\"2\"><li>通过修改 pod 的 template.spec.dnsConfig 来设置</li></ol><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">template:</span></span><br><span class=\"line\">  <span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">dnsConfig:</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">single-request-reopen</span></span><br></pre></td></tr></table></figure><blockquote><p><code>注</code>: 需要 k8s 版本&gt;=1.9</p></blockquote><h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>不支持<code>alpine</code>基础镜像的容器，因为<code>apline</code>底层使用的<code>musl libc</code>库并不支持这些 resolv.conf 选项，所以如果使用<code>alpine</code>基础镜像构建的应用，还是无法规避超时的问题。</p><h3 id=\"方案（三）：本地-DNS-缓存\"><a href=\"#方案（三）：本地-DNS-缓存\" class=\"headerlink\" title=\"方案（三）：本地 DNS 缓存\"></a>方案（三）：本地 DNS 缓存</h3><p>其实 k8s 官方也意识到了这个问题比较常见，给出了 coredns 以 cache 模式作为 daemonset 部署的解决方案: <a href=\"https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/nodelocaldns\" target=\"_blank\" rel=\"noopener\">https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/nodelocaldns</a></p><p>大概原理就是：</p><blockquote><p>本地 DNS 缓存以 DaemonSet 方式在每个节点部署一个使用 hostNetwork 的 Pod，创建一个网卡绑上本地 DNS 的 IP，本机的 Pod 的 DNS 请求路由到本地 DNS，然后取缓存或者继续使用 TCP 请求上游集群 DNS 解析 (由于使用 TCP，同一个 socket 只会做一遍三次握手，不存在并发创建 conntrack 表项，也就不会有 conntrack 冲突)</p></blockquote><h4 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h4><ol><li>获取当前<code>kube-dns service</code>的 clusterIP</li></ol><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># kubectl -n kube-system get svc kube-dns -o jsonpath=\"&#123;.spec.clusterIP&#125;\"</span></span><br><span class=\"line\">10.96.0.10</span><br></pre></td></tr></table></figure><ol start=\"2\"><li>下载官方提供的 yaml 模板进行关键字替换</li></ol><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget -O nodelocaldns.yaml <span class=\"string\">\"https://github.com/kubernetes/kubernetes/raw/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml\"</span> &amp;&amp; \\</span><br><span class=\"line\">sed -i <span class=\"string\">'s/__PILLAR__DNS__SERVER__/10.96.0.10/g'</span> nodelocaldns.yaml &amp;&amp; \\</span><br><span class=\"line\">sed -i <span class=\"string\">'s/__PILLAR__LOCAL__DNS__/169.254.20.10/g'</span> nodelocaldns.yaml &amp;&amp; \\</span><br><span class=\"line\">sed -i <span class=\"string\">'s/__PILLAR__DNS__DOMAIN__/cluster.local/g'</span> nodelocaldns.yaml &amp;&amp; \\</span><br><span class=\"line\">sed -i <span class=\"string\">'s/__PILLAR__CLUSTER__DNS__/10.96.0.10/g'</span> nodelocaldns.yaml &amp;&amp; \\</span><br><span class=\"line\">sed -i <span class=\"string\">'s/__PILLAR__UPSTREAM__SERVERS__/\\/etc\\/resolv.conf/g'</span> nodelocaldns.yaml</span><br></pre></td></tr></table></figure><ol start=\"3\"><li>最终 yaml 文件如下：</li></ol><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Copyright 2018 The Kubernetes Authors.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Licensed under the Apache License, Version 2.0 (the \"License\");</span></span><br><span class=\"line\"><span class=\"comment\"># you may not use this file except in compliance with the License.</span></span><br><span class=\"line\"><span class=\"comment\"># You may obtain a copy of the License at</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class=\"line\"><span class=\"comment\"># distributed under the License is distributed on an \"AS IS\" BASIS,</span></span><br><span class=\"line\"><span class=\"comment\"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class=\"line\"><span class=\"comment\"># See the License for the specific language governing permissions and</span></span><br><span class=\"line\"><span class=\"comment\"># limitations under the License.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ServiceAccount</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/cluster-service:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">    <span class=\"attr\">addonmanager.kubernetes.io/mode:</span> <span class=\"string\">Reconcile</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">kube-dns-upstream</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">k8s-app:</span> <span class=\"string\">kube-dns</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/cluster-service:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">    <span class=\"attr\">addonmanager.kubernetes.io/mode:</span> <span class=\"string\">Reconcile</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/name:</span> <span class=\"string\">\"KubeDNSUpstream\"</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dns</span></span><br><span class=\"line\">      <span class=\"attr\">port:</span> <span class=\"number\">53</span></span><br><span class=\"line\">      <span class=\"attr\">protocol:</span> <span class=\"string\">UDP</span></span><br><span class=\"line\">      <span class=\"attr\">targetPort:</span> <span class=\"number\">53</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dns-tcp</span></span><br><span class=\"line\">      <span class=\"attr\">port:</span> <span class=\"number\">53</span></span><br><span class=\"line\">      <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span></span><br><span class=\"line\">      <span class=\"attr\">targetPort:</span> <span class=\"number\">53</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">k8s-app:</span> <span class=\"string\">kube-dns</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">addonmanager.kubernetes.io/mode:</span> <span class=\"string\">Reconcile</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">Corefile:</span> <span class=\"string\">|</span></span><br><span class=\"line\">    <span class=\"string\">cluster.local:53</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">        <span class=\"string\">errors</span></span><br><span class=\"line\">        <span class=\"string\">cache</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">                <span class=\"string\">success</span> <span class=\"number\">9984</span> <span class=\"number\">30</span></span><br><span class=\"line\">                <span class=\"string\">denial</span> <span class=\"number\">9984</span> <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">        <span class=\"string\">reload</span></span><br><span class=\"line\">        <span class=\"string\">loop</span></span><br><span class=\"line\">        <span class=\"string\">bind</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span></span><br><span class=\"line\">        <span class=\"string\">forward</span> <span class=\"string\">.</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">                <span class=\"string\">force_tcp</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">        <span class=\"string\">prometheus</span> <span class=\"string\">:9253</span></span><br><span class=\"line\">        <span class=\"string\">health</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span><span class=\"string\">:8080</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">    <span class=\"string\">in-addr.arpa:53</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">        <span class=\"string\">errors</span></span><br><span class=\"line\">        <span class=\"string\">cache</span> <span class=\"number\">30</span></span><br><span class=\"line\">        <span class=\"string\">reload</span></span><br><span class=\"line\">        <span class=\"string\">loop</span></span><br><span class=\"line\">        <span class=\"string\">bind</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span></span><br><span class=\"line\">        <span class=\"string\">forward</span> <span class=\"string\">.</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">                <span class=\"string\">force_tcp</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">        <span class=\"string\">prometheus</span> <span class=\"string\">:9253</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">    <span class=\"string\">ip6.arpa:53</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">        <span class=\"string\">errors</span></span><br><span class=\"line\">        <span class=\"string\">cache</span> <span class=\"number\">30</span></span><br><span class=\"line\">        <span class=\"string\">reload</span></span><br><span class=\"line\">        <span class=\"string\">loop</span></span><br><span class=\"line\">        <span class=\"string\">bind</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span></span><br><span class=\"line\">        <span class=\"string\">forward</span> <span class=\"string\">.</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">                <span class=\"string\">force_tcp</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">        <span class=\"string\">prometheus</span> <span class=\"string\">:9253</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">    <span class=\"string\">.:53</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">        <span class=\"string\">errors</span></span><br><span class=\"line\">        <span class=\"string\">cache</span> <span class=\"number\">30</span></span><br><span class=\"line\">        <span class=\"string\">reload</span></span><br><span class=\"line\">        <span class=\"string\">loop</span></span><br><span class=\"line\">        <span class=\"string\">bind</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span> <span class=\"number\">10.96</span><span class=\"number\">.0</span><span class=\"number\">.10</span></span><br><span class=\"line\">        <span class=\"string\">forward</span> <span class=\"string\">.</span> <span class=\"string\">/etc/resolv.conf</span> <span class=\"string\">&#123;</span></span><br><span class=\"line\">                <span class=\"string\">force_tcp</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\">        <span class=\"string\">prometheus</span> <span class=\"string\">:9253</span></span><br><span class=\"line\">        <span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"meta\">---</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">DaemonSet</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">kube-system</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">k8s-app:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">    <span class=\"attr\">kubernetes.io/cluster-service:</span> <span class=\"string\">\"true\"</span></span><br><span class=\"line\">    <span class=\"attr\">addonmanager.kubernetes.io/mode:</span> <span class=\"string\">Reconcile</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">updateStrategy:</span></span><br><span class=\"line\">    <span class=\"attr\">rollingUpdate:</span></span><br><span class=\"line\">      <span class=\"attr\">maxUnavailable:</span> <span class=\"number\">10</span><span class=\"string\">%</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">k8s-app:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">k8s-app:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">priorityClassName:</span> <span class=\"string\">system-node-critical</span></span><br><span class=\"line\">      <span class=\"attr\">serviceAccountName:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">      <span class=\"attr\">hostNetwork:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">      <span class=\"attr\">dnsPolicy:</span> <span class=\"string\">Default</span> <span class=\"comment\"># Don't use cluster DNS.</span></span><br><span class=\"line\">      <span class=\"attr\">tolerations:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">\"CriticalAddonsOnly\"</span></span><br><span class=\"line\">          <span class=\"attr\">operator:</span> <span class=\"string\">\"Exists\"</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">node-cache</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">k8s.gcr.io/k8s-dns-node-cache:1.15.7</span></span><br><span class=\"line\">          <span class=\"attr\">resources:</span></span><br><span class=\"line\">            <span class=\"attr\">requests:</span></span><br><span class=\"line\">              <span class=\"attr\">cpu:</span> <span class=\"string\">25m</span></span><br><span class=\"line\">              <span class=\"attr\">memory:</span> <span class=\"string\">5Mi</span></span><br><span class=\"line\">          <span class=\"attr\">args:</span></span><br><span class=\"line\">            <span class=\"string\">[</span></span><br><span class=\"line\">              <span class=\"string\">\"-localip\"</span><span class=\"string\">,</span></span><br><span class=\"line\">              <span class=\"string\">\"169.254.20.10,10.96.0.10\"</span><span class=\"string\">,</span></span><br><span class=\"line\">              <span class=\"string\">\"-conf\"</span><span class=\"string\">,</span></span><br><span class=\"line\">              <span class=\"string\">\"/etc/Corefile\"</span><span class=\"string\">,</span></span><br><span class=\"line\">              <span class=\"string\">\"-upstreamsvc\"</span><span class=\"string\">,</span></span><br><span class=\"line\">              <span class=\"string\">\"kube-dns-upstream\"</span><span class=\"string\">,</span></span><br><span class=\"line\">            <span class=\"string\">]</span></span><br><span class=\"line\">          <span class=\"attr\">securityContext:</span></span><br><span class=\"line\">            <span class=\"attr\">privileged:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">53</span></span><br><span class=\"line\">              <span class=\"attr\">name:</span> <span class=\"string\">dns</span></span><br><span class=\"line\">              <span class=\"attr\">protocol:</span> <span class=\"string\">UDP</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">53</span></span><br><span class=\"line\">              <span class=\"attr\">name:</span> <span class=\"string\">dns-tcp</span></span><br><span class=\"line\">              <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">9253</span></span><br><span class=\"line\">              <span class=\"attr\">name:</span> <span class=\"string\">metrics</span></span><br><span class=\"line\">              <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span></span><br><span class=\"line\">          <span class=\"attr\">livenessProbe:</span></span><br><span class=\"line\">            <span class=\"attr\">httpGet:</span></span><br><span class=\"line\">              <span class=\"attr\">host:</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span></span><br><span class=\"line\">              <span class=\"attr\">path:</span> <span class=\"string\">/health</span></span><br><span class=\"line\">              <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">            <span class=\"attr\">initialDelaySeconds:</span> <span class=\"number\">60</span></span><br><span class=\"line\">            <span class=\"attr\">timeoutSeconds:</span> <span class=\"number\">5</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">mountPath:</span> <span class=\"string\">/run/xtables.lock</span></span><br><span class=\"line\">              <span class=\"attr\">name:</span> <span class=\"string\">xtables-lock</span></span><br><span class=\"line\">              <span class=\"attr\">readOnly:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/coredns</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">kube-dns-config</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/etc/kube-dns</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">xtables-lock</span></span><br><span class=\"line\">          <span class=\"attr\">hostPath:</span></span><br><span class=\"line\">            <span class=\"attr\">path:</span> <span class=\"string\">/run/xtables.lock</span></span><br><span class=\"line\">            <span class=\"attr\">type:</span> <span class=\"string\">FileOrCreate</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">kube-dns-config</span></span><br><span class=\"line\">          <span class=\"attr\">configMap:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">kube-dns</span></span><br><span class=\"line\">            <span class=\"attr\">optional:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">config-volume</span></span><br><span class=\"line\">          <span class=\"attr\">configMap:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">node-local-dns</span></span><br><span class=\"line\">            <span class=\"attr\">items:</span></span><br><span class=\"line\">              <span class=\"bullet\">-</span> <span class=\"attr\">key:</span> <span class=\"string\">Corefile</span></span><br><span class=\"line\">                <span class=\"attr\">path:</span> <span class=\"string\">Corefile.base</span></span><br></pre></td></tr></table></figure><p>通过 yaml 可以看到几个细节：</p><ol><li>部署类型是使用的<code>DaemonSet</code>，即在每个 k8s node 节点上运行一个 dns 服务</li><li><code>hostNetwork</code>属性为<code>true</code>，即直接使用 node 物理机的网卡进行端口绑定，这样在此 node 节点中的 pod 可以直接访问 dns 服务，不通过 service 进行转发，也就不会有 DNAT</li><li><code>dnsPolicy</code>属性为<code>Default</code>，不使用 cluster DNS，在解析外网域名时直接使用本地的 DNS 设置</li><li>绑定在 node 节点<code>169.254.20.10</code>和<code>10.96.0.10</code>IP 上，这样节点下面的 pod 只需要将 dns 设置为<code>169.254.20.10</code>即可直接访问宿主机上的 dns 服务。</li></ol><h4 id=\"测试-1\"><a href=\"#测试-1\" class=\"headerlink\" title=\"测试\"></a>测试</h4><ol><li><p>修改<code>/etc/resolv.conf</code>文件中的 nameserver：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">nameserver 169.254.20.10</span><br></pre></td></tr></table></figure></li><li><p>进行压测：</p><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 200个并发,持续30秒,记录超过5s的请求个数</span><br><span class=\"line\">./dns -host &#123;service&#125;.&#123;namespace&#125; -c 200 -d 30 -l 5000</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src=\"/2019/12/10/k8s-dns-lookup-timeout/2019-12-11-17-13-11.png\" alt></p></li></ol><h4 id=\"结论-2\"><a href=\"#结论-2\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>通过压测发现并没有解决超时的问题，按理说没有<code>conntrack</code>冲突应该表现出的情况与方案(二)类似才对，也可能是我使用的姿势不对，不过虽然这个问题还存在，但是通过<code>DaemonSet</code>将 dns 请求压力分散到各个 node 节点，也可以有效的缓解域名解析超时问题。</p><h4 id=\"实施\"><a href=\"#实施\" class=\"headerlink\" title=\"实施\"></a>实施</h4><ul><li>方案（一）：通过修改 pod 的 template.spec.dnsConfig 来设置，并将<code>dnsPolicy</code>设置为<code>None</code></li></ul><figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">template:</span></span><br><span class=\"line\">  <span class=\"attr\">spec:</span></span><br><span class=\"line\">    <span class=\"attr\">dnsConfig:</span></span><br><span class=\"line\">      <span class=\"attr\">nameservers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"number\">169.254</span><span class=\"number\">.20</span><span class=\"number\">.10</span></span><br><span class=\"line\">      <span class=\"attr\">searches:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">public.svc.cluster.local</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">svc.cluster.local</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"string\">cluster.local</span></span><br><span class=\"line\">      <span class=\"attr\">options:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ndots</span></span><br><span class=\"line\">        <span class=\"attr\">value:</span> <span class=\"string\">\"5\"</span></span><br><span class=\"line\">    <span class=\"attr\">dnsPolicy:</span> <span class=\"string\">None</span></span><br></pre></td></tr></table></figure><ul><li>方案（二）：修改默认的<code>cluster-dns</code>，在 node 节点上将<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>文件中的<code>--cluster-dns</code>参数值修改为<code>169.254.20.10</code>，然后重启<code>kubelet</code></li></ul><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl restart kubelet</span><br></pre></td></tr></table></figure><blockquote><p><code>注</code>：配置文件路径也可能是<code>/etc/kubernetes/kubelet</code></p></blockquote><h2 id=\"最终解决方案\"><a href=\"#最终解决方案\" class=\"headerlink\" title=\"最终解决方案\"></a>最终解决方案</h2><p>最后还是决定使用<code>方案(二)+方案(三)</code>配合使用，来最大程度的优化此问题，并且将线上所有的基础镜像都替换为非<code>apline</code>的镜像版本，至此问题基本解决，也希望 K8S 官方能早日将此功能直接集成进去。</p>","categories":["DevOps"],"tags":["docker","go","k8s"]}]